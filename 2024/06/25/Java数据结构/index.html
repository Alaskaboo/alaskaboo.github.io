

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alaskaboo">
  <meta name="keywords" content="">
  
    <meta name="description" content="一、队列1.多项式相关加法运算实现 12345678910111213141516171819202122232425262728293031323334353637383940Polynomial PolyAdd (Polynomial P1, Polynomial P2)&#123;    Polynomial front, rear, temp;    int sum;    rear&#x3D;(P">
<meta property="og:type" content="article">
<meta property="og:title" content="Java数据结构">
<meta property="og:url" content="http://example.com/2024/06/25/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/index.html">
<meta property="og:site_name" content="Alaskaboo&#39;s Blog">
<meta property="og:description" content="一、队列1.多项式相关加法运算实现 12345678910111213141516171819202122232425262728293031323334353637383940Polynomial PolyAdd (Polynomial P1, Polynomial P2)&#123;    Polynomial front, rear, temp;    int sum;    rear&#x3D;(P">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182533322.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182537561.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182539614.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182544901.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182549178.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182621849.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182624700.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182627334.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182629852.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182632350.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182635532.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182639361.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182645148.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182648267.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182651345.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182654822.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182657858.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182700842.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182705544.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182711860.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182713950.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182716394.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182718754.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182720736.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182725817.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182727840.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182729666.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182731560.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182733530.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182735850.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182738121.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182744065.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182746146.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182748730.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182751506.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182753677.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182756271.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182758620.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182801626.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182804572.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182806784.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182809719.png">
<meta property="og:image" content="e:\Markdown\img\QQ_1727076050087.png">
<meta property="og:image" content="e:\Markdown\img\QQ_1727076062498.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182820828.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182822636.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182825015.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182828346.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182831733.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182835323.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182840204.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182845869.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182848201.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182856620.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182859444.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182905524.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182908617.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182911138.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182913409.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182918157.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182921146.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182923141.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182925212.png">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182927959.png">
<meta property="article:published_time" content="2024-06-25T06:10:22.000Z">
<meta property="article:modified_time" content="2025-06-25T13:45:11.448Z">
<meta property="article:author" content="Alaskaboo">
<meta property="article:tag" content="数据结构">
<meta property="article:tag" content="java">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182533322.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Java数据结构 - Alaskaboo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  


  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Alaskaboo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Java数据结构"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2024-06-25 14:10" pubdate>
          2024年6月25日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          11k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          94 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Java数据结构</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一、队列"><a href="#一、队列" class="headerlink" title="一、队列"></a>一、队列</h1><h2 id="1-多项式相关"><a href="#1-多项式相关" class="headerlink" title="1.多项式相关"></a>1.多项式相关</h2><p>加法运算实现</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">Polynomial <span class="hljs-title function_">PolyAdd</span> <span class="hljs-params">(Polynomial P1, Polynomial P2)</span>&#123;<br>    Polynomial front, rear, temp;<br>    <span class="hljs-type">int</span> sum;<br>    rear=(Polynomial) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<span class="hljs-comment">/*由front记录结果多项式链表头结点*/</span><br>    front = rear;<br>    <span class="hljs-keyword">while</span>(P1 &amp;&amp; P2)<span class="hljs-comment">/*当两个多项式都有非零项待处理时*/</span><br>        <span class="hljs-keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                Attach( P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>                P1 = P1-&gt;link;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>                Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);<br>                P2 = P2-&gt;link;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                sum =P1-&gt;coef + P2-&gt;coef;<br>                <span class="hljs-keyword">if</span> ( sum )Attach(sum, P1-&gt;expon, &amp;rear);<br>                P1 = P1-&gt;link;<br>                P2 = P2-&gt;link;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>	<span class="hljs-comment">/*将未处理完的另一个多项式的所有节点依次复制到结果多项式中去*/</span><br>    <span class="hljs-keyword">for</span>( ; P1; P1=P1-&gt;link)Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>    <span class="hljs-keyword">for</span>( ; P2; P2 = P2-&gt;link)Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);<br>    rear-&gt;link = <span class="hljs-literal">NULL</span>;<br>    temp = front;<br>    front=front-&gt;link;<span class="hljs-comment">/*令front指向结果多项式第一个非零项*/</span><br>    <span class="hljs-built_in">free</span>(temp);<span class="hljs-comment">/*释放临时空表头结点*/</span><br>    <span class="hljs-keyword">return</span> front;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Attach</span><span class="hljs-params">( <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> e, Polynomial *pRear )</span><br>&#123;<br>    Polynomial P;<br>    P=(Polynomial)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<br>    P-&gt;coef=c;<span class="hljs-comment">/*对新结点赋值*/</span><br>    P-&gt;expon = e;<br>    P-&gt;link = <span class="hljs-literal">NULL</span>;<br>    (*pRear)-&gt;link= P;<br>    *pRear = P;<span class="hljs-comment">/*修改pRear值 */</span><br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-多项式练习题"><a href="#2-多项式练习题" class="headerlink" title="2.多项式练习题"></a>2.多项式练习题</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182533322.png" srcset="/img/loading.gif" lazyload alt="image-20240918110651700" style="zoom:33%;" />

<p>方法一：</p>
<p><strong>数组</strong>：编程简单、调试容易；事先确定数组大小</p>
<p><strong>链表</strong>：动态性强；编程略微复杂、调试比较困难</p>
<p>数据结构设计</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span> *<span class="hljs-title">Polynomial</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span>&#123;</span><br>    <span class="hljs-type">int</span> coef;<br>    <span class="hljs-type">int</span> expon;<br>    Polynomial link;<br>&#125;<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182537561.png" srcset="/img/loading.gif" lazyload alt="image-20240918111725133" style="zoom: 33%;" />



<p><strong>程序框架</strong>：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182539614.png" srcset="/img/loading.gif" lazyload alt="image-20240918111924526" style="zoom:33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">读入程序：<br>Polynomial <span class="hljs-title function_">ReadPoly</span><span class="hljs-params">()</span><br>&#123;<br>   Polynomial P, Rear, t;<br>    <span class="hljs-type">int</span> c, e, N;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    P=(Polynomial)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<span class="hljs-comment">/*链表头空结点 */</span><br>    P-&gt;link = <span class="hljs-literal">NULL</span>;<br>    Rear = P;<br>    <span class="hljs-keyword">while</span>(N--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;c, &amp;e);<br>        Attach(c, e, &amp;Rear);<span class="hljs-comment">/*将当前项插入多项式尾部*/</span><br>    &#125;<br>    t=P;P=P-&gt;link; <span class="hljs-built_in">free</span>(t);<span class="hljs-comment">/*删除临时生成的头结点*/</span><br>    <span class="hljs-keyword">return</span> P; <br>&#125;<br><br><span class="hljs-type">void</span>  lynomial *pRear )<br>&#123;<br>    Polynomial P;<br>    P=(Polynomial)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<br>    P-&gt;coef=c;<span class="hljs-comment">/*对新结点赋值*/</span><br>    P-&gt;expon = e;<br>    P-&gt;link = <span class="hljs-literal">NULL</span>;<br>    (*pRear)-&gt;link= P;<br>    *pRear = P;<span class="hljs-comment">/*修改pRear值 */</span><br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h1 id="二、树"><a href="#二、树" class="headerlink" title="二、树"></a>二、树</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 <strong>基本概念</strong></h2><p>定义：n(n≥0)个结点构成的有限集合。当n&#x3D;0时，称为空树；对于任一棵非空树(n&gt;0)，它具备以下性质:</p>
<blockquote>
<ul>
<li>树中有一个称为 “根(Root)” 的特殊结点，用r表示;</li>
<li>其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2…. ，Tm，其中每个集合本身又是一棵树，称为原来树的“<strong>子树(Sub Tree</strong>)”</li>
</ul>
</blockquote>
<p><strong>作用</strong>：用于查找。查找又分为静态和动态.</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182544901.png" srcset="/img/loading.gif" lazyload alt="image-20240921173434959" style="zoom: 33%;" />

<p><strong>特点</strong>：</p>
<blockquote>
<ul>
<li><p>子树是不相交的；</p>
</li>
<li><p>除了根节点外，每个结点有且仅有一个父节点</p>
</li>
<li><p>一棵树<strong>N</strong>个结点的树有<strong>N-1</strong>条边</p>
</li>
</ul>
</blockquote>
<p>树的基本术语</p>
<blockquote>
<ol>
<li><p>结点的度(Degree)：结点的子树个数；</p>
</li>
<li><p>树的度：树的所有结点中最大的度数树的度；</p>
</li>
<li><p>叶结点(Leaf)：度为0的结点；</p>
</li>
<li><p>父结点(Parent)：有子树的结点是其子树的根结点的父结点；</p>
</li>
<li><p>子结点(Child)：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点；</p>
</li>
<li><p>兄弟结点(Sibling)：具有同一父结点的各结点彼此是兄弟结点；</p>
</li>
<li><p>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…，nk，ni是 ni+1的父结点。路径所包含边的个数为路径的长度。</p>
</li>
<li><p>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。</p>
</li>
<li><p>子孙结点(Descendant):：某一结点的子树中的所有结点是这个结点的子孙。</p>
</li>
<li><p>11.结点的层次(Level):规定根结点在1层其它任一结点的层数是其父结点的层数加1.12.树的深度(Depth):树中所有结点中的最大层次是这棵树的深度。</p>
</li>
</ol>
</blockquote>
<hr>
<h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2 二叉树"></a>2 二叉树</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><h4 id="2-1-1-二叉树定义"><a href="#2-1-1-二叉树定义" class="headerlink" title="2.1.1 二叉树定义"></a><strong>2.1.1 二叉树定义</strong></h4><blockquote>
<p>一个又穷的结点集合。这个集合可以为空，若不为空，则它是由根节点和称为其左子树T˪和右子树Tᵣ的两个不相交的二叉树组成</p>
</blockquote>
<p>几个重要性质</p>
<blockquote>
<ul>
<li>一个二叉树第i层的最大结点数为：2ⁱ⁻¹，i≥1。</li>
<li>深度为k的二叉树有最大结点总数为：2ᵏ-1，k≥1</li>
<li>对任何非空二叉树T，若n₀表示叶结点的个数、n₂是度为2的非叶结点个数，那么两者满足关系n₀&#x3D;n₂+1</li>
</ul>
</blockquote>
<h4 id="2-1-2-抽象数据定义"><a href="#2-1-2-抽象数据定义" class="headerlink" title="2.1.2 抽象数据定义"></a><strong>2.1.2 抽象数据定义</strong></h4><blockquote>
<p>数据对象集：一个有穷的结点集合。若不为空，则由根结点和其左、右二叉子树组成。<br>操作集：BT∈BinTree，ltem∈ElementType，重要操作有:</p>
<ol>
<li>Boolean lsEmpty ( BinTree BT)：判别BT是否为空；</li>
<li>void Traversal ( BinTree BT)：遍历，按某顺序访问每个结点；</li>
<li>BinTree CreatBinTree( )：创建一个二叉树。</li>
</ol>
</blockquote>
<h4 id="2-1-3-五种基本形式"><a href="#2-1-3-五种基本形式" class="headerlink" title="2.1.3 五种基本形式"></a><strong>2.1.3 五种基本形式</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182549178.png" srcset="/img/loading.gif" lazyload alt="image-20240921205440389" style="zoom:50%;" />



<h4 id="2-1-4-子树左右顺序之分"><a href="#2-1-4-子树左右顺序之分" class="headerlink" title="2.1.4 子树左右顺序之分"></a><strong>2.1.4 子树左右顺序之分</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182621849.png" srcset="/img/loading.gif" lazyload alt="image-20240921205549032" style="zoom:50%;" />

<h3 id="2-2-特殊二叉树"><a href="#2-2-特殊二叉树" class="headerlink" title="2.2 特殊二叉树"></a><strong>2.2 特殊二叉树</strong></h3><h4 id="2-2-1-斜二叉树"><a href="#2-2-1-斜二叉树" class="headerlink" title="2.2.1 斜二叉树"></a>2.2.1 <strong>斜二叉树</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182624700.png" srcset="/img/loading.gif" lazyload alt="image-20240921210107666" style="zoom: 50%;" />

<h4 id="2-2-2-完美二叉树（满二叉树）"><a href="#2-2-2-完美二叉树（满二叉树）" class="headerlink" title="2.2.2 完美二叉树（满二叉树）"></a>2.2.2 <strong>完美二叉树（满二叉树）</strong></h4><p>​	</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182627334.png" srcset="/img/loading.gif" lazyload alt="image-20240921210411046" style="zoom:50%;" />

<h4 id="2-2-3-完全二叉树"><a href="#2-2-3-完全二叉树" class="headerlink" title="2.2.3 完全二叉树"></a>2.2.3 <strong>完全二叉树</strong></h4><p>跟满二叉树相似，但是不同点是完全二叉树可以比满二叉树少后面连续的几个度。</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182629852.png" srcset="/img/loading.gif" lazyload alt="image-20240921210815710" style="zoom: 50%;" />







<hr>
<h3 id="2-3-存储结构"><a href="#2-3-存储结构" class="headerlink" title="2.3 存储结构"></a>2.3 存储结构</h3><h4 id="2-3-1-顺序存储"><a href="#2-3-1-顺序存储" class="headerlink" title="2.3.1 顺序存储"></a>2.3.1 顺序存储</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182632350.png" srcset="/img/loading.gif" lazyload alt="image-20240921213837317" style="zoom: 50%;" />

<blockquote>
<p>注：一般二叉树也可实现这种方法，但是必须造成空间额外的开销</p>
</blockquote>
<h4 id="2-3-2-链表存储"><a href="#2-3-2-链表存储" class="headerlink" title="2.3.2 链表存储"></a>2.3.2 链表存储</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182635532.png" srcset="/img/loading.gif" lazyload alt="image-20240921214256797" style="zoom:25%;" />





<hr>
<h3 id="2-4-常用的遍历"><a href="#2-4-常用的遍历" class="headerlink" title="2.4 常用的遍历"></a>2.4 常用的遍历</h3><h4 id="2-4-1-先序遍历"><a href="#2-4-1-先序遍历" class="headerlink" title="2.4.1 先序遍历"></a>2.4.1 先序遍历</h4><p>遍历过程（根、左子树、右子树）：①访问根结点；②先序遍历其左子树；③先序遍历其右子树</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Preordertraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>   <span class="hljs-keyword">if</span>( BT )&#123;<br>       <span class="hljs-built_in">printf</span>(“d<span class="hljs-string">&quot;, BT-&gt;Data);</span><br><span class="hljs-string">       PreOrderTraversal( BT -&gt; Left );</span><br><span class="hljs-string">       PreOrderTraversal( BT -&gt; Right );</span><br><span class="hljs-string">	&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>



<p>例：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182639361.png" srcset="/img/loading.gif" lazyload alt="image-20240921215940230" style="zoom:33%;" />

<blockquote>
<p>先序遍历 &#x3D;&gt; <strong>A (B D F E) (C G H I)</strong></p>
</blockquote>
<hr>
<p>先序非递归遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    BinTree T=BT;<br>    Stack S = Creatstack(MaxSize);   	<span class="hljs-comment">/*创建并初始化堆栈S*/</span><br>    <span class="hljs-keyword">while</span>( T || !IsEmpty(S) )&#123;<br>        <span class="hljs-keyword">while</span>( T )&#123; 					<span class="hljs-comment">/*一直向左并将沿途结点压入堆栈*/</span><br>            Push( S, T);<br>            <span class="hljs-built_in">printf</span>(“%<span class="hljs-number">5</span>d”, T-&gt;Data);     <span class="hljs-comment">/*(访问)打印结点*/</span><br>            T = T -&gt; Left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( !IsEmpty(S) ) &#123;<br>            T=Pop(S);					<span class="hljs-comment">/*结点弹出堆栈*/</span><br>            T=T-&gt;Right;					<span class="hljs-comment">/*转向右子树*/</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h4 id="2-4-2-中序遍历"><a href="#2-4-2-中序遍历" class="headerlink" title="2.4.2 中序遍历"></a>2.4.2 中序遍历</h4><p>遍历过程（左子树、根、右子树）：①先序遍历其左子树；②访问根结点；③先序遍历其右子树；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Preordertraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>   <span class="hljs-keyword">if</span>( BT )&#123;<br>       PreOrderTraversal( BT -&gt; Left );<br>       <span class="hljs-built_in">printf</span>(“d<span class="hljs-string">&quot;, BT-&gt;Data);</span><br><span class="hljs-string">       PreOrderTraversal( BT -&gt; Right );</span><br><span class="hljs-string">	&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>



<p>例：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182645148.png" srcset="/img/loading.gif" lazyload alt="image-20240922101547651" style="zoom:33%;" />

<blockquote>
<p>中序遍历&#x3D;&gt; ( D B E F ) A ( G H C I)</p>
</blockquote>
<hr>
<p>中序也可以用递归来实现：</p>
<ul>
<li>遇到一个结点，就把它压栈，并去遍历它的左子树；</li>
<li>当左子树遍历结束后，从栈顶弹出这个结点并访问它；</li>
<li>然后按其右指针再去中序遍历该结点的右子树。</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    BinTree T=BT;<br>    Stack S = Creatstack(MaxSize);   	<span class="hljs-comment">/*创建并初始化堆栈S*/</span><br>    <span class="hljs-keyword">while</span>( T || !IsEmpty(S) )&#123;<br>        <span class="hljs-keyword">while</span>( T )&#123; 					<span class="hljs-comment">/*一直向左并将沿途结点压入堆栈*/</span><br>            Push( S, T);<br>            T = T -&gt; Left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( !IsEmpty(S) ) &#123;<br>            T=Pop(S);					<span class="hljs-comment">/*结点弹出堆栈*/</span><br>            <span class="hljs-built_in">printf</span>(“%<span class="hljs-number">5</span>d”, T-&gt;Data);     <span class="hljs-comment">/*(访问)打印结点*/</span><br>            T=T-&gt;Right;					<span class="hljs-comment">/*转向右子树*/</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h4 id="2-4-3-后序遍历"><a href="#2-4-3-后序遍历" class="headerlink" title="2.4.3 后序遍历"></a>2.4.3 后序遍历</h4><p>遍历过程（左子树、右子树、根）：①先序遍历其左子树；②先序遍历其右子树③访问根结点；</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Preordertraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>   <span class="hljs-keyword">if</span>( BT )&#123;<br>       PreOrderTraversal( BT -&gt; Left );<br>       PreOrderTraversal( BT -&gt; Right );<br>       <span class="hljs-built_in">printf</span>(“d<span class="hljs-string">&quot;, BT-&gt;Data);</span><br><span class="hljs-string">	&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>



<p>例：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182648267.png" srcset="/img/loading.gif" lazyload alt="image-20240922102258463" style="zoom:33%;" />

<blockquote>
<p>后序遍历&#x3D;&gt; (D E F B) (H G I C) A</p>
</blockquote>
<hr>
<p>后续非递归遍历：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    BinTree T=BT;<br>    Stack S = Creatstack(MaxSize);   	<span class="hljs-comment">/*创建并初始化堆栈S*/</span><br>    <span class="hljs-keyword">while</span>( T || !IsEmpty(S) )&#123;<br>        <span class="hljs-keyword">while</span>( T )&#123; 					<span class="hljs-comment">/*一直向左并将沿途结点压入堆栈*/</span><br>            Push( S, T);<br>            T = T -&gt; Left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( !IsEmpty(S) ) &#123;<br>            T=Pop(S);					<span class="hljs-comment">/*结点弹出堆栈*/</span><br>            T=T-&gt;Right;					<span class="hljs-comment">/*转向右子树*/</span><br>            <span class="hljs-built_in">printf</span>(“%<span class="hljs-number">5</span>d”, T-&gt;Data);     <span class="hljs-comment">/*(访问)打印结点*/</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>

<hr>
<h4 id="2-4-4-层次遍历"><a href="#2-4-4-层次遍历" class="headerlink" title="2.4.4 层次遍历"></a>2.4.4 层次遍历</h4><p>层次遍历过程：从上到下、从左到右。</p>
<p>**队列实现：**遍历从根结点开始，首先将根结点入队，然后开始执行循环：（结点出队、访问该结点、其左右儿子入队）</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182651345.png" srcset="/img/loading.gif" lazyload alt="image-20240922105423876" style="zoom: 33%;" />

<p>实现思路：</p>
<blockquote>
<p>先放入A，抛出A。 再依次放入左右儿子B C，再抛出B。再放入B的左右儿子D F，抛出C。放入C的左右孩子G I，抛出D。由于D没有左右孩子，抛出F。放入E，抛出G。放入 H，抛出I，最后抛出E H。</p>
</blockquote>
<hr>
<blockquote>
<p>A B C D F G I E H</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LevelOrderTraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>    Queue Q;<br>    BinTree T;				<span class="hljs-comment">/*若是空树则直接返回*/</span><br>    <span class="hljs-keyword">if</span>( !BT ) <span class="hljs-keyword">return</span>;<br>    Q = CreatQueue( Maxsize );	<span class="hljs-comment">/*创建并初始化队列Q*/</span><br>    AddQ(Q, BT);<br>    <span class="hljs-keyword">while</span>(!IsEmptyQ( Q ))&#123;<br>        T = DeleteQ( Q );<br>        <span class="hljs-built_in">printf</span>(“%d\n”, T-&gt;Data);	<span class="hljs-comment">/*访间取出队列的结点*/</span><br>        <span class="hljs-keyword">if</span>( T -&gt; Left)    AddQ( Q, T-&gt;Left);<br>        <span class="hljs-keyword">if</span>( T -&gt; Right)   AddQ( Q, T-&gt;Right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<hr>
<h3 id="2-5-二叉树的应用"><a href="#2-5-二叉树的应用" class="headerlink" title="2.5 二叉树的应用"></a>2.5 二叉树的应用</h3><h4 id="2-5-1-输出二叉树中的叶子结点"><a href="#2-5-1-输出二叉树中的叶子结点" class="headerlink" title="2.5.1 输出二叉树中的叶子结点"></a>2.5.1 输出二叉树中的叶子结点</h4><p>再二叉树的遍历算法中增加检测结点的“左右子树是否都为空”。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">PrerderPrintLeaves</span><span class="hljs-params">(BinTree B)</span>&#123;<br>    <span class="hljs-keyword">if</span>(BT )&#123;<br>        <span class="hljs-keyword">if</span>( !BT -&gt; Left &amp;&amp; !BT -&gt; Right )&#123;<br>            <span class="hljs-built_in">printf</span>(“%d<span class="hljs-string">&quot;, BT-&gt;Data );</span><br><span class="hljs-string">        PreOrderPrintLeaves(BT -&gt; Left);</span><br><span class="hljs-string">        PreOrderPrintLeaves(BT -&gt; Right); </span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure>



<h4 id="2-5-2-二叉树的高度"><a href="#2-5-2-二叉树的高度" class="headerlink" title="2.5.2 二叉树的高度"></a>2.5.2 二叉树的高度</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182654822.png" srcset="/img/loading.gif" lazyload alt="image-20240922112411335" style="zoom:33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">PostorderGetHeight( Bintree BT )<br>&#123;<br>    <span class="hljs-type">int</span> HL, HR, MaxH;<br>    <span class="hljs-keyword">if</span>(BT )&#123;<br>        HL = PostOrderGetHeight(BT -&gt; Left);	<span class="hljs-comment">/*求左子树的深度*/</span><br>        HR = PostorderGetHeight(BT -&gt; Right);	<span class="hljs-comment">/*求右子树的深度*/</span><br>        MaxH=(HL &gt; HR) ? HL : HR;				<span class="hljs-comment">/*取左右子树较大的深度*/</span><br>        <span class="hljs-keyword">return</span>(MaxH + <span class="hljs-number">1</span>);						<span class="hljs-comment">/*返回树的深度*/</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;							<span class="hljs-comment">/*空树深度为0*/</span><br>&#125;<br></code></pre></td></tr></table></figure>



<blockquote>
<p>注：查找的效率与树的高度有关</p>
</blockquote>
<h4 id="2-5-3-二元运算表达式树及其遍历"><a href="#2-5-3-二元运算表达式树及其遍历" class="headerlink" title="2.5.3 二元运算表达式树及其遍历"></a>2.5.3 二元运算表达式树及其遍历</h4><p>例：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182657858.png" srcset="/img/loading.gif" lazyload alt="image-20240922113444039" style="zoom: 33%;" />

<p>三种不同的访问结果：</p>
<blockquote>
<p>先序：++ a * b c * + * d e f g</p>
<p>中序：a + b * c + d * e + f * g (中序可能带来符号的问题，解决办法可添加符号进行运算)</p>
<p>后序：a b c * +  d e * f + g * +</p>
</blockquote>
<hr>
<h4 id="2-5-4-由两种遍历序列确定二叉树"><a href="#2-5-4-由两种遍历序列确定二叉树" class="headerlink" title="2.5.4 由两种遍历序列确定二叉树"></a>2.5.4 由两种遍历序列确定二叉树</h4><p>必须要有两个中序遍历才行。因为必须确定根节点</p>
<blockquote>
<p>先序序列：a b c d e f g h i j<br>中序序列：c b e d a h g i j f</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182700842.png" srcset="/img/loading.gif" lazyload alt="QQ_1726990340381" style="zoom: 33%;" />



<h4 id="2-5-5-同构树判断"><a href="#2-5-5-同构树判断" class="headerlink" title="2.5.5 同构树判断"></a>2.5.5 同构树判断</h4><blockquote>
<p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。</p>
</blockquote>
<p>输入给出2棵二叉树的信息：</p>
<ul>
<li>先在一行中给出该树的结点数，随后N行</li>
<li>第i行对应编号第i个结点，给出该结点中存储的字母、其左孩子结点的编号、右孩子结点的编号。</li>
<li>如果孩子结点为空，则在相应位置上给出“-”</li>
</ul>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182705544.png" srcset="/img/loading.gif" lazyload alt="QQ_1726991131325" style="zoom:25%;" />

<p>求解思路：</p>
<ol>
<li>二叉树表示</li>
<li>建二叉树</li>
<li>同构判别</li>
</ol>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxTree 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElementType char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Tree int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Null -1</span><br><br><span class="hljs-comment">/*定义数据结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElementType Element;<br>    Tree Left;<br>    Tree Right;<br>&#125;T1[MaxTree], T2[MaxTree];<br>  <br><span class="hljs-comment">/*程序框架*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    Tree R1, R2;<br>    R1 = BuildTree(T1);<br>    R2 = BuildTree(T2);<br>    <span class="hljs-keyword">if</span>(Isomorphic(R1, R2)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br>Tree BuildTree( <span class="hljs-keyword">struct</span> TreeNode T[] )&#123;<br>    ......<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">if</span> (N)&#123;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) check[i]= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %c %c\n&quot;</span>, &amp;T[i].Element, &amp;cl, &amp;cr);<br>            <span class="hljs-keyword">if</span> (cl != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                T[i].Left = cl-<span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">/*将字符转化为数字*/</span><br>                check[T[i].Left]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> T[i].Left = Null;<br>            ......<span class="hljs-comment">/*对cr的对应处理*/</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>            <span class="hljs-keyword">if</span> (!check[i]) <span class="hljs-keyword">break</span>;<br>        Root =i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Root;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Isomorphic</span> <span class="hljs-params">( Tree R1, Tree R2 )</span>&#123;<br>    <span class="hljs-keyword">if</span>((R1 == Null) &amp;&amp; (R2 == Null) )<span class="hljs-comment">/* both empty */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(( (R1==Null) &amp;&amp; (R2 != Null) )|| ( (R1!=Null) &amp;&amp; (R2==Null) ))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">/* one of them is empty */</span><br>    <span class="hljs-keyword">if</span>(T1[R1].Element != T2[R2].Element)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* roots are different */</span><br>    <span class="hljs-keyword">if</span>((T1[R1].Left ==Null) &amp;&amp; (T2[R2].Left == Null))<br>        <span class="hljs-comment">/* both have no left subtree */</span><br>        <span class="hljs-keyword">return</span> Isomorphic( T1[R1].Right, T2[R2].Right );<br>    <span class="hljs-keyword">if</span>(( (T1[R1].Left!=Nul) &amp;&amp; (T2[R2].Left!=Null)) &amp;&amp; <br>       ((T1[T1[R1].Left].Element) == (T2[T2[R2].Left].Element)))<br>        <span class="hljs-comment">/* no need to swap the left and the right */</span><br>        <span class="hljs-keyword">return</span>(lsomorphic( T1[R1].Left, T2[R2].Left )&amp;&amp;<br>               Isomorphic( T1[R1].Right, T2[R2].Right ));<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* need to swap the left and the right */</span><br>        <span class="hljs-keyword">return</span> ( lsomorphic( T1[R1].Left, T2[R2].Right) &amp;&amp;<br>                Isomorphic(T1[R1].Right, T2[R2].Left ));<br>&#125;<br><br></code></pre></td></tr></table></figure>



<hr>
<h2 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3 二叉搜索树"></a>3 二叉搜索树</h2><p>二叉搜索树(BST，Binary Search Tree)，也称二叉排序树或二叉查找树<br>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质:</p>
<blockquote>
<ol>
<li>非空左子树的所有键值小于其根结点的键值。</li>
<li>非空右子树的所有键值大于其根结点的键值。</li>
<li>左、右子树都是二叉搜索树</li>
</ol>
</blockquote>
<h3 id="3-1-查找操作Find"><a href="#3-1-查找操作Find" class="headerlink" title="3.1 查找操作Find"></a>3.1 查找操作Find</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*查找普通元素*/</span><br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( ElementType X, BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( !BST ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*查找失败*/</span><br>    <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data)<br>        <span class="hljs-keyword">return</span> Find(X, BST -&gt; Right );<span class="hljs-comment">/*在右子树中继续查找*/</span><br>    Else <span class="hljs-title function_">if</span><span class="hljs-params">( X &lt; BST-&gt;Data )</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(X, BST -&gt; Left)</span>;<span class="hljs-comment">/*在左子树中继续查找*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/*X == BST -&gt; Data */</span><br>        <span class="hljs-keyword">return</span> BST;<span class="hljs-comment">/*查找成功，返回结点的找到结点的地址*/</span><br>&#125;<br><br><span class="hljs-comment">/*查找最大元素*/</span><br>Position <span class="hljs-title function_">FindMin</span><span class="hljs-params">( BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( !BST ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/*空的二叉搜索树，返回NULL*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !BST -&gt; Left )<br>        <span class="hljs-keyword">return</span> BST;   		<span class="hljs-comment">/*找到最左叶结点井返回*/</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FindMin(BST -&gt; Left);<span class="hljs-comment">/*沿左分支维续查找</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/*查找最小元素*/</span><br>Position <span class="hljs-title function_">FindMax</span><span class="hljs-params">( BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( BST )<br>        <span class="hljs-comment">/*沿右分支继续查找，直到最右叶结点*/</span><br>        <span class="hljs-keyword">while</span>(BST -&gt; Right) BST = BST -&gt; Right;<br>    <span class="hljs-keyword">return</span> BsT;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="3-2-插入操作Insert"><a href="#3-2-插入操作Insert" class="headerlink" title="3.2 插入操作Insert"></a>3.2 插入操作Insert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( ElementType X, BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( !BST )&#123;<br>        <span class="hljs-comment">/*若原树为空，生成并返回一个结点的二叉搜索树*/</span><br>        BST = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>        BST -&gt; Data = X;<br>        BST -&gt; Left = BST -&gt; Right = <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span><br>        <span class="hljs-comment">/*开始找要插入元素的位置*/</span><br>        <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data )<br>            <span class="hljs-comment">/*递归插入左子树*/</span><br>            BST -&gt; Left = Insert(X, BST -&gt; Left);<br>    	<span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)<br>            <span class="hljs-comment">/*递归插入右子树*/</span><br>            BST -&gt; Right = Insert(X, BST -&gt; Right);<br>    <span class="hljs-comment">/*else X已经存在，什么都不做*/</span><br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-3-删除操作"><a href="#3-3-删除操作" class="headerlink" title="3.3 删除操作"></a>3.3 删除操作</h3><p> 要考虑的三种情况：</p>
<ul>
<li><strong>要删除的是叶结点</strong>：直接删除，并再修改其父结点指针设置为NULL</li>
</ul>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182711860.png" srcset="/img/loading.gif" lazyload alt="QQ_1726999640984" style="zoom: 25%;" />

<ul>
<li>要删除的结点只有一个孩子结点：将其父结点的指针指向要删除结点的孩子结点</li>
</ul>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182713950.png" srcset="/img/loading.gif" lazyload alt="QQ_1726999712814" style="zoom: 33%;" />

<ul>
<li>要删除的结点有<strong>左、右两棵子树</strong>：用另一结点替代被删除结点，即<strong>右子树的最小元素</strong>或<strong>者左子树的最大元素</strong></li>
</ul>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182716394.png" srcset="/img/loading.gif" lazyload alt="QQ_1726999848223" style="zoom:33%;" />

<p>取<strong>右子树中的最小元素</strong>替代：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182718754.png" srcset="/img/loading.gif" lazyload alt="QQ_1726999898448" style="zoom:33%;" />

<p>取<strong>左子树中的最大元素</strong>替代：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182720736.png" srcset="/img/loading.gif" lazyload alt="QQ_1726999926936" style="zoom:33%;" />

<p>程序代码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Delete</span><span class="hljs-params">(ElementType X, BinTree BST)</span>&#123;<br>    Position Tmp;<br>    <span class="hljs-keyword">if</span>( !BST ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &lt; BST -&gt; Data )<br>        BST -&gt; Left = Delete( X, BST -&gt; Left );	<span class="hljs-comment">/*左子树递归删除*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST -&gt; Data )<br>        BST -&gt; Right = Delete( X，BS -&gt; Right );<span class="hljs-comment">/*右子树递归删除*/</span><br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-comment">/*找到要删除的结点*/</span><br>        <span class="hljs-comment">/*被删除结点有左右两个子结点 */</span><br>        <span class="hljs-keyword">if</span>( BST -&gt; Left &amp;&amp; BST -&gt; Right)&#123;<br>            <span class="hljs-comment">/*在右子树中找最小的元素填充删除结点*/</span><br>            Tmp = FindMin(BST -&gt; Right);<br>            BST -&gt; Data = Tmp -&gt; Data;<br>            <span class="hljs-comment">/*在删除结点的右子树中删除最小元素*/</span><br>            BST -&gt; Right = Delete( BST -&gt; Data, BST -&gt; Right);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">/*被删除结点有一个或无子结点*/</span><br>            Tmp = BST;<br>            <span class="hljs-comment">/*有右孩子或无子结点，下面的语句是左边是空*/</span><br>            <span class="hljs-keyword">if</span>( !BST -&gt; Left)<br>                BST = BST -&gt; Right;<br>            <span class="hljs-comment">/*有左孩子或无子结点*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !BsT -&gt; Right)<br>                BST = BST -&gt; Left;<br>            <span class="hljs-built_in">free</span>( Tmp );<br>        &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-4-判别是否同一搜索树"><a href="#3-4-判别是否同一搜索树" class="headerlink" title="3.4 判别是否同一搜索树"></a>3.4 判别是否同一搜索树</h3><p>求解思路</p>
<blockquote>
<ol>
<li>分别建两棵搜索树的判别方法</li>
<li>不建树的判别方法</li>
<li>建一棵树，再判别其他序列是否与该树一致</li>
</ol>
</blockquote>
<p>选择第3种进行设计</p>
<blockquote>
<ol>
<li>搜索树表示</li>
<li>建搜索树T</li>
<li>判别一序列是否与搜索树T一致</li>
</ol>
</blockquote>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*搜索树表示*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">Tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> v;<br>    Tree Left, Right;<br>    <span class="hljs-type">int</span> flag;<br>&#125;;<br><br><span class="hljs-comment">/*主函数*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> N, L, i;<br>    Tree T;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">while</span> (N) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;L);<br>        T = MakeTree(N);<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;L; i++)&#123;<br>            <span class="hljs-keyword">if</span> (Judge(T, N)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>            <span class="hljs-comment">/*清除T中的标记flag*/</span><br>            ResetT(T);<br>        &#125;<br>        FreeTree(T);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*如何建搜索树*/</span><br>Tree <span class="hljs-title function_">MakeTree</span><span class="hljs-params">( <span class="hljs-type">int</span> N )</span>&#123;<br>    Tree T;<br>    <span class="hljs-type">int</span> i, V;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>    <span class="hljs-comment">/*申请一个树节点空间函数*/</span><br>    T = NewNode(V);<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;N; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V);<br>        T =Insert(T, V);<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-comment">/*申请一个树节点空间具体实现*/</span><br>Tree <span class="hljs-title function_">NewNode</span><span class="hljs-params">( <span class="hljs-type">int</span> V )</span>&#123;<br>    TreeT = (Tree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    T -&gt; v = V;<br>    T -&gt; Left = T -&gt; Right = <span class="hljs-literal">NULL</span>;<br>    T -&gt; flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br>Tree <span class="hljs-title function_">insert</span><span class="hljs-params">( Tree T, <span class="hljs-type">int</span> V )</span>&#123;<br>    <span class="hljs-keyword">if</span> ( !T ) T = NewNode(V);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>( V &gt; T -&gt; v )<br>            T-&gt;Right = Insert( T-&gt;Right, V );<br>        <span class="hljs-keyword">else</span><br>            T-&gt;Left = Insert( T-&gt;Left, V );<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-comment">/*判别搜索树*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">check</span> <span class="hljs-params">( Tree T, <span class="hljs-type">int</span> V )</span>&#123;<br>    <span class="hljs-keyword">if</span> ( T -&gt; flag )&#123;<br>        <span class="hljs-keyword">if</span> ( V &lt; T -&gt; v ) <span class="hljs-keyword">return</span> check( T -&gt; Left, V);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( V &gt; T -&gt; v ) <span class="hljs-keyword">return</span> check( T -&gt; Right, V);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>( V == T -&gt; v )&#123;<br>            T -&gt; flag =<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Judge</span><span class="hljs-params">( Tree T, <span class="hljs-type">int</span> N )</span>&#123;<br>    <span class="hljs-comment">/*flag:0代表目前还一致，1代表已经不一致*/</span><br>    <span class="hljs-type">int</span> i, V, flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>    <span class="hljs-keyword">if</span>( V != T-&gt;v ) flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> T -&gt; flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>        <span class="hljs-keyword">if</span> ( (!flag) &amp;&amp; (!check(T, V))) flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*清除T中各结点的flag标记*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ResetT</span><span class="hljs-params">(TreeT)</span>&#123;<br>    <span class="hljs-keyword">if</span> ( T -&gt; Left) ResetT( T -&gt; Left);<br>    <span class="hljs-keyword">if</span> (T -&gt; Right) ResetT( T -&gt; Right);<br>    T -&gt; flag = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*释放T的空间*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FreeTree</span><span class="hljs-params">(TreeT)</span>&#123;<br>    <span class="hljs-keyword">if</span> (T -&gt; Left) FreeTree(T -&gt; Left);<br>    <span class="hljs-keyword">if</span> (T -&gt; Right) FreeTree(T -&gt; Right);<br>    <span class="hljs-built_in">free</span>(T);<br>&#125;<br></code></pre></td></tr></table></figure>







<h2 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4 平衡二叉树"></a>4 平衡二叉树</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><blockquote>
<p><strong>平衡二叉树(Balanced Binary Tree) (AVL树)</strong>：空树，或者任一结点左、右子树高度差的绝对值不超过1，即**|BF(T)|≤1**</p>
<p><strong>平衡因子(Balance Factor，简称BF)</strong>：BF(T)&#x3D; h˪-hᵣ其中h˪和hᵣ分别为T的左、右子树的高度。</p>
<p><em><strong>给定结点数为 n 的 AVL 树的最大高度为 O(log₂n)</strong></em></p>
</blockquote>
<p>搜索树节点不同的插入次序，将导致不同的深度和平均查找长度ASL</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182725817.png" srcset="/img/loading.gif" lazyload alt="QQ_1727001784741" style="zoom: 25%;" />

<h3 id="4-2-调平"><a href="#4-2-调平" class="headerlink" title="4.2 调平"></a>4.2 调平</h3><blockquote>
<p>RR旋转</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182727840.png" srcset="/img/loading.gif" lazyload alt="QQ_1727003471268" style="zoom: 25%;" />

<blockquote>
<p>LL旋转</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182729666.png" srcset="/img/loading.gif" lazyload alt="QQ_1727003551389" style="zoom: 25%;" />

<blockquote>
<p>LR旋转</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182731560.png" srcset="/img/loading.gif" lazyload alt="QQ_1727003602596" style="zoom:25%;" />

<blockquote>
<p>RL旋转</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182733530.png" srcset="/img/loading.gif" lazyload alt="QQ_1727003754869" style="zoom:25%;" />





 

<hr>
<h2 id="5-静态查找"><a href="#5-静态查找" class="headerlink" title="5 静态查找"></a>5 静态查找</h2><h3 id="5-1-顺序查找"><a href="#5-1-顺序查找" class="headerlink" title="5.1 顺序查找"></a>5.1 顺序查找</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182735850.png" srcset="/img/loading.gif" lazyload alt="image-20240921165803220" style="zoom: 25%;" />



<h3 id="5-2-二分查找（Binary-Search）"><a href="#5-2-二分查找（Binary-Search）" class="headerlink" title="5.2 二分查找（Binary Search）"></a>5.2 二分查找（Binary Search）</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182738121.png" srcset="/img/loading.gif" lazyload alt="image-20240921170753507" style="zoom: 25%;" />



<p>实现算法</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span> <span class="hljs-params">( List Tbl, ElementType K)</span><br>&#123;<span class="hljs-comment">/*在表Tbl中查找关键字为K的数据元素*/</span><br>    <span class="hljs-type">int</span> left, right, mid, NoFound=<span class="hljs-number">-1</span>;<br><br>    left = <span class="hljs-number">1</span>;					<span class="hljs-comment">/*初始左边界*/</span><br>    right = Tbl-&gt;Length;		<span class="hljs-comment">/*初始右边界*/</span><br>    <span class="hljs-keyword">while</span> ( left &lt;= right )<br>    &#123;<br>        mid =(left+right)/<span class="hljs-number">2</span>;	<span class="hljs-comment">/*计算中间元素坐标*/</span><br>        <span class="hljs-keyword">if</span>( K &lt; Tbl-&gt;Element[mid])           right = mid<span class="hljs-number">-1</span>；<span class="hljs-comment">/*调整右边界*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( K &gt;Tbl-&gt;Element[mid])   left = mid+<span class="hljs-number">1</span>;  <span class="hljs-comment">/*调整左边界*/</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;   <span class="hljs-comment">/*查找成功，返回数据元素的下标*/</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> NotFound;<span class="hljs-comment">/*查找不成功，返回-1*/</span><br>&#125;<br></code></pre></td></tr></table></figure>



<p>生成判断树</p>
<ul>
<li><p>判定树上每个结点需要的查找次数刚好为该结点所在的层数;</p>
</li>
<li><p>查找成功时查找次数不会超过判定树的深度</p>
<blockquote>
<p>n个结点的判定树的深度为[log₂n]+1</p>
</blockquote>
</li>
</ul>
<hr>
<h1 id="三、堆"><a href="#三、堆" class="headerlink" title="三、堆"></a>三、堆</h1><h2 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><p>优先队列（Priority Queue）：特殊的“<strong>队列</strong>”，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。</p>
<p>堆的两个特性：</p>
<blockquote>
<ul>
<li>结构性：用数组表示的完全二叉树；</li>
<li>有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)<ul>
<li>最大堆(MaxHeap)，也称“大顶堆“，最大值</li>
<li>最小堆(MinHeap)，也称“小顶堆”，最小值</li>
</ul>
</li>
</ul>
</blockquote>
<h2 id="2-堆的操作"><a href="#2-堆的操作" class="headerlink" title="2 堆的操作"></a>2 堆的操作</h2><blockquote>
<p>堆的数据结构</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapStruct</span> *<span class="hljs-title">MaxHeap</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapStruct</span> &#123;</span><br>    <span class="hljs-comment">/*存储堆元素的数组*/</span><br>    ElementType *Elements;<br>    <span class="hljs-comment">/*堆的当前元素个数*/</span><br>    <span class="hljs-type">int</span> Size;<br>    <span class="hljs-comment">/*堆的最大容量 */</span><br>    <span class="hljs-type">int</span> Capacity;<br>&#125;;<br></code></pre></td></tr></table></figure>



<h3 id="2-1-堆的创建"><a href="#2-1-堆的创建" class="headerlink" title="2.1 堆的创建"></a>2.1 堆的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">MaxHeap <span class="hljs-title function_">Create</span><span class="hljs-params">(<span class="hljs-type">int</span> MaxSize)</span>&#123;<br>    <span class="hljs-comment">/*创建容量为MaxSize的空的最大堆*/</span><br>    MaxHeap H = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> Heapstruct ) );<br>    <span class="hljs-comment">/*MaxSize + 1代表我们是从下标为1的元素开始存放，一般下表为0不存放元素*/</span><br>    H -&gt; Elements = <span class="hljs-built_in">malloc</span>((MaxSize + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    H -&gt; Size = <span class="hljs-number">0</span>;<br>    H -&gt; Capacity = MaxSize;<br>    H -&gt; Elements[<span class="hljs-number">0</span>] = MaxData;<br>    <span class="hljs-comment">/*定义“哨兵”为大于堆中所有可能元素的值，便于以后更快操作*/</span><br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br></code></pre></td></tr></table></figure>

<p>建立最大堆：将已经存在的N个元素按最大堆的要求存放在个一维数组中</p>
<ul>
<li>方法1：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为0(N log N)。</li>
<li>方法2：在线性时间复杂度下建立最大堆。<ul>
<li>(1)将N个元素按输入顺序存入，先满足完全二叉树的结构特性</li>
<li>(2)调整各结点位置，以满足最大堆的有序特性</li>
</ul>
</li>
</ul>
<h3 id="2-2-堆的插入"><a href="#2-2-堆的插入" class="headerlink" title="2.2 堆的插入"></a>2.2 堆的插入</h3><p>将新增结点插入到从其父结点到根结点的有序序列中 ，<strong>时间复杂度：T(N) &#x3D; O(log N)</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(MaxHeap H, ElementType item)</span>&#123;<br>    <span class="hljs-comment">/*将元素item 插入最大堆H，其中H-&gt;Elements[0]已经定义为哨兵*/</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(IsFu11(H))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已满&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/*i指向插入后堆中的最后一个元素的位置*/</span><br>    i = ++H -&gt; Size;<br>    <span class="hljs-keyword">for</span>(;H-&gt;Elements[i/<span class="hljs-number">2</span>]&lt;item;i/=<span class="hljs-number">2</span>)<br>        <span class="hljs-comment">/*向下过滤结点 */</span><br>        H -&gt; Elements[i] = H-&gt;Elements[i/<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">/*将item 插入*/</span><br>    H-&gt;Elements[il= item;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="2-3-堆的删除"><a href="#2-3-堆的删除" class="headerlink" title="2.3 堆的删除"></a>2.3 堆的删除</h3><p>时间复杂度：T(N) &#x3D; O (log N)</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182744065.png" srcset="/img/loading.gif" lazyload alt="QQ_1727011390447" style="zoom: 33%;" />

<p>删除下标最大的元素</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182746146.png" srcset="/img/loading.gif" lazyload alt="QQ_1727012016153" style="zoom: 33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>ElementType <span class="hljs-title function_">DeleteMax</span><span class="hljs-params">( MaxHeap H )</span>&#123;<br>    <span class="hljs-comment">/*从最大堆H中取出键值为最大的元素，并删除一个结点*/</span><br>    <span class="hljs-type">int</span> Parent, Child;<br>    ElementType MaxItem, temp;<br>    <span class="hljs-keyword">if</span>( IsEmpty(H) )&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已为空&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/*取出根结点最大值*/</span><br>    MaxItem = H -&gt; Elements[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">/*用最大堆中最后一个元素从根结点开始向上过滤下层结点*/</span><br>    temp = H -&gt; Elements[ H -&gt; Size--];<br>    <span class="hljs-comment">/* Parent * 2 &lt;= H -&gt; Size判别是否有左儿子*/</span><br>    <span class="hljs-keyword">for</span>( Parent = <span class="hljs-number">1</span>; Parent * <span class="hljs-number">2</span> &lt;= H -&gt; Size; Parent =Child )&#123;<br>        Child = Parent * <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">/*child指向左右子结点的较大者，Child!= H-&gt;Size是否有右儿子*/</span> <br>        <span class="hljs-keyword">if</span>((Child!= H-&gt;Size) &amp;&amp; (H -&gt; Elements[Child] &lt; H -&gt; Elements[Child+<span class="hljs-number">1</span>]))<br>            Child++;<br>        <span class="hljs-keyword">if</span>(temp &gt;= H -&gt; Elements[Child]) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">/*移动temp元素到下一层*/</span><br>        <span class="hljs-keyword">else</span><br>            H -&gt; Elements[Parent] = H-&gt;Elements[Child];<br>    &#125;<br>    H -&gt; Elements[Parent] = temp;<br>    <span class="hljs-keyword">return</span> MaxItem;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="3-哈夫曼树与哈夫曼编码"><a href="#3-哈夫曼树与哈夫曼编码" class="headerlink" title="3 哈夫曼树与哈夫曼编码"></a>3 哈夫曼树与哈夫曼编码</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><p><strong>定义：</strong></p>
<blockquote>
<p>带权路径长度(WPL)：设二叉树有n个叶子结点，每个叶子结点带有权值Wₖ，从根结点到每个叶子结点的长度为Iₖ ，则每个叶子结点的带权路径长度之和就是：</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182748730.png" srcset="/img/loading.gif" lazyload alt="QQ_1727057924307" style="zoom:33%;" />

<blockquote>
<p>最优二叉树或哈夫曼树：WPL最小的二叉树</p>
<p>时间复杂度：O(N log N)</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">HuffmanTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-type">int</span> weight;<br>    HuffmanTree Left, Right;<br>&#125;<br>HuffmanTree <span class="hljs-title function_">Huffman</span><span class="hljs-params">( MinHeap H)</span>&#123;<br>    <span class="hljs-comment">/*假设H-&gt;size个权值已经存在H-&gt;Elements[]-&gt;weight里*/</span><br>    <span class="hljs-type">int</span> i;<br>    HuffmanTree T;<br>    <span class="hljs-comment">/*将H-&gt;Elements[]按权值调整为最小堆*/</span><br>    BuildMinHeap(H);<br>    <span class="hljs-comment">/*做H-&gt;Size-1次合并*/</span><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">1</span>; i &lt; H -&gt; Size; i++)&#123;<br>        <span class="hljs-comment">/*建立新结点*/</span><br>        T = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>        <span class="hljs-comment">/*从最小堆中删除一个结点，作为新的左子结点*/</span><br>        T -&gt; Left = DeleteMin(H);<br>        <span class="hljs-comment">/*从最小堆中删除一个结点，作为新的右子结点*/</span><br>        T -&gt; Right = DeleteMin(H);<br>        <span class="hljs-comment">/*计算新权值*/</span><br>        T -&gt; Weight = T -&gt; Left -&gt; Weight + T -&gt; Right -&gt; Weight;<br>        <span class="hljs-comment">/*将新T插入最小堆*/</span><br>        Insert(H, T);<br>    &#125;<br>        T = DeleteMin(H);<br>        <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure>



<p><strong>特点：</strong></p>
<blockquote>
<p>没有度为1的结点；<br>n个叶子结点的哈夫曼树共有2n-1个结点；<br>哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树；</p>
</blockquote>
<p>权值WPL相同，但是构造出来的树不同：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182751506.png" srcset="/img/loading.gif" lazyload alt="QQ_1727058807533" style="zoom:33%;" />



<p><strong>用途：<strong>它可以用来</strong>生成文本的索引、单词频率统计和特征向量表示</strong>等任务。 哈夫曼编码在各种需要对数据进行高效压缩和编码表示的应用中具有重要作用，能够显著减小数据的大小，提高数据传输和存储的效率。</p>
<p>例子：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182753677.png" srcset="/img/loading.gif" lazyload alt="QQ_1727059775006" style="zoom:25%;" />



<h2 id="4-集合运算"><a href="#4-集合运算" class="headerlink" title="4 集合运算"></a>4 集合运算</h2><blockquote>
<p>集合运算：交、并、补、差，判定一个元素是否属于某一集合</p>
</blockquote>
<p>例子：</p>
<p>​	有10台电脑{1，2，3，…，9，10}，已知下列电脑之间已经实现了连接：1和2、2和4、3和5、4和7、5和8、6和9、6和10</p>
<p>问：</p>
<p>​	2和7之间，5和9之间是否是连通的?</p>
<p>解决思路</p>
<ul>
<li>(1)将10台电脑看成10个集合{1}，{2}，{3}，…，{9}，{10}；</li>
<li>(2)已知一种连接“x和y”，就将x和y对应的集合合并;</li>
<li>(3)查询“x和y是否是连通的”就是判别x和y是否属于同集合。</li>
</ul>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182756271.png" srcset="/img/loading.gif" lazyload alt="QQ_1727060754223" style="zoom:25%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182758620.png" srcset="/img/loading.gif" lazyload alt="QQ_1727060773106" style="zoom: 33%;" />



<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*数据结构构造*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ElementType Data;<br>    <span class="hljs-type">int</span> Parent;<br>&#125;SetType;<br></code></pre></td></tr></table></figure>



<h3 id="4-1-集合查找"><a href="#4-1-集合查找" class="headerlink" title="4.1 集合查找"></a>4.1 集合查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*查找某个元素所在的集合*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(SetType S[], ElementType X)</span>&#123;<br>    <span class="hljs-comment">/*在数组s中查找值为x的元素所属的集合*/</span><br>    <span class="hljs-comment">/*Maxsize是全局变量，为数组S的最大长度*/</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++);<br>    <span class="hljs-comment">/* 未找到X，返回-1 */</span><br>    <span class="hljs-keyword">if</span>( i &gt;= MaxSize ) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>( ; S[il.Parent &gt;= <span class="hljs-number">0</span>; i = S[i].Parent);<br>    <span class="hljs-comment">/*找到x所属集合，返回树根结点在数组s中的下标*/</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-2-集合的并运算"><a href="#4-2-集合的并运算" class="headerlink" title="4.2 集合的并运算"></a>4.2 集合的并运算</h3><blockquote>
<p>分别找到X1和X2两个元素所在集合树的根结点;</p>
<p>如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标。</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType s[ ], ElementType X1, ElementType X2)</span>&#123;<br>    <span class="hljs-type">int</span> Rootl,Root2;<br>    Root1 = Find(s, X1);<br>    Root2 = Find(s, x2);<br>    <span class="hljs-keyword">if</span>(Root1 != Root2 ) S[Root2].Parent = Root1;<br>&#125;<br></code></pre></td></tr></table></figure>



<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182801626.png" srcset="/img/loading.gif" lazyload alt="QQ_1727061814019" style="zoom: 25%;" />



<blockquote>
<p>简化：</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*默认元素可以用非负整数表示*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Elementrype;<br><span class="hljs-comment">/*默认用根结点的下标作为集合名称*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> setName;<br><span class="hljs-keyword">typedef</span> ElementType SetType[Maxsize];<br><br>SetName <span class="hljs-title function_">Find</span><span class="hljs-params">(SetType S, ElementType X )</span><br>&#123;<br>    <span class="hljs-comment">/*默认集合元素全部初始化为-1*/</span><br>    <span class="hljs-keyword">for</span>( ; S[X] &gt;= <span class="hljs-number">0</span>; X = S[X]);<br>    <span class="hljs-keyword">return</span> X;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType S, SetName Root1,SetName Root2 )</span>&#123;<br>    <span class="hljs-comment">/*这里默认Root1和Root2是不同集合的根结点 */</span><br>    S[Root2]= Root1;<br>&#125;<br></code></pre></td></tr></table></figure>





<h2 id="5-堆中的路径"><a href="#5-堆中的路径" class="headerlink" title="5 堆中的路径"></a>5 堆中的路径</h2><h3 id="5-1-程序设计题"><a href="#5-1-程序设计题" class="headerlink" title="5.1 程序设计题"></a>5.1 程序设计题</h3><p>将一系列给定数字插入一个初始为空的小顶堆H。随后对任意给定的下标“ i ”，打印从H[i]到根结点的路径。</p>
<blockquote>
<p>输入样例:</p>
<p>5 3</p>
<p>46 23 26 24 10</p>
<p>5 4 3</p>
<p>输出样例:</p>
<p>24 23 10</p>
<p>46 23 10</p>
<p>26 10</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182804572.png" srcset="/img/loading.gif" lazyload alt="QQ_1727062119957" style="zoom:33%;" />

<p>程序设计：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINH -10001</span><br><br><span class="hljs-type">int</span> H[MAXN], size;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Create</span><span class="hljs-params">()</span>&#123;<br>    size = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*设置“岗哨”*/</span><br>    H[<span class="hljs-number">0</span>] = MINH;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> X)</span>&#123;<br>    <span class="hljs-comment">/*将X插入H。这里省略检查堆是否已满的代码*/</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = ++size; H[i/<span class="hljs-number">2</span>] &gt; X; i /= <span class="hljs-number">2</span>)<br>        H[i] = H[i/<span class="hljs-number">2</span>];<br>    H[i] = X;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n, m, x, i, j;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-comment">/*堆初始化*/</span><br>    Create();<br>    <span class="hljs-comment">/*以逐个插入方式建堆*/</span><br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        Insert(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;j);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,H[j]);<br>        <span class="hljs-keyword">while</span> ( j &gt; <span class="hljs-number">1</span>)&#123; <br>            <span class="hljs-comment">/*沿根方向输出各结点*/</span><br>            j /= <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, H[j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>例：判断系统是否连通</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182806784.png" srcset="/img/loading.gif" lazyload alt="QQ_1727071326730" style="zoom:33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123; <br>    SetType S;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span> in;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;d\n&quot;</span>, &amp;n);<br>    Initialization(S, n);<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;in);<br>        <span class="hljs-keyword">switch</span>(in)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>: Input <span class="hljs-title function_">connection</span><span class="hljs-params">(S)</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>: Check <span class="hljs-title function_">connection</span><span class="hljs-params">(S)</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>: Check <span class="hljs-title function_">network</span><span class="hljs-params">(S, n)</span>; <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span>(in != <span class="hljs-string">&#x27;S&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Input_connection</span><span class="hljs-params">( SetType S)</span>&#123;<br>    ElementType u, v;<br>    SetName Root1, Root2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, &amp;u, &amp;v);<br>    Root1 =Find(S，u<span class="hljs-number">-1</span>);<br>    Root2 =Find(S，v<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(Rootl != Root2 )<br>        Union(S，Root1，Root2);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Check_connection</span><span class="hljs-params">( SetType S)</span>&#123;<br>    ElementType u, v;<br>    SetName Root1, Root2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, &amp;u, &amp;v);<br>    Root1 =Find(S，u<span class="hljs-number">-1</span>);<br>    Root2 =Find(S，v<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(Rootl == Root2 )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="5-2-按秩归并（优化Union）"><a href="#5-2-按秩归并（优化Union）" class="headerlink" title="5.2 按秩归并（优化Union）"></a>5.2 按秩归并（优化Union）</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182809719.png" srcset="/img/loading.gif" lazyload alt="QQ_1727073444387" style="zoom: 25%;" />



<blockquote>
<p>另一种做法：比规模，即把小树贴到大树上。S[Root]&#x3D; -元素个数；</p>
</blockquote>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType S, SetName Root1, SetName Root2)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S[Root2] &lt; S[Root1])&#123;<br>        S[Root2] += S[Root1];<br>        S[Root1] = Root2;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        S[Root1] += S[Root2];<br>        S[Root2] = Root1; <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h3 id="5-3-路径压缩（优化Find）"><a href="#5-3-路径压缩（优化Find）" class="headerlink" title="5.3 路径压缩（优化Find）"></a>5.3 路径压缩（优化Find）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">SetName <span class="hljs-title function_">Find</span><span class="hljs-params">( SetType S, ElementType X)</span>&#123;<br>    <span class="hljs-comment">/*找到集合的根 */</span><br>    <span class="hljs-keyword">if</span> ( S[X]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-comment">/*先找到根；把根变成x的父结点；再返回根*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> S[X]=Find(S，S[X]);<br>&#125;<br></code></pre></td></tr></table></figure>





<h1 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h1><h2 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-1-抽象数据类型"><a href="#1-1-抽象数据类型" class="headerlink" title="1.1 抽象数据类型"></a>1.1 抽象数据类型</h3><p>类型名称：图（Graph）</p>
<p>数据对象集：G(V, E)由一个非空的有限顶点集合V和一个有限边集合E组成。</p>
<p>特点：</p>
<blockquote>
<ul>
<li>表示“多对多”的关系</li>
<li>包含<ul>
<li>一组顶点：通常用V(Vertex)表示顶点集合</li>
<li>一组边：通常用E(Edge)表示边的集合<ul>
<li>边是顶点对：(v,w)∈E，其中v,w∈V  <img src="E:\Markdown\img\QQ_1727076050087.png" srcset="/img/loading.gif" lazyload alt="QQ_1727076050087" style="zoom:25%;" /></li>
<li>有向边&lt; v, w &gt;表示从v指向w的边（单行线）<img src="E:\Markdown\img\QQ_1727076062498.png" srcset="/img/loading.gif" lazyload alt="QQ_1727076062498" style="zoom:25%;" /></li>
<li>不考虑重边和自回路</li>
</ul>
</li>
</ul>
</li>
</ul>
</blockquote>
<h3 id="1-2-邻接矩阵"><a href="#1-2-邻接矩阵" class="headerlink" title="1.2 邻接矩阵"></a><font color="red">1.2 邻接矩阵</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">优点<br>- 直观、简单、好理解<br>- 方便检查任意一对顶点间是否存在边<br>- 方便找任一顶点的所有<span class="hljs-string">&quot;邻接点&quot;</span>(有边直接相连的顶点)<br>- 方便计算任一顶点的<span class="hljs-string">&quot;度&quot;</span>(从该点发出的边数为<span class="hljs-string">&quot;出度&quot;</span>指向该点的边数为“入度”)<br>	无向图:对应行(或列)非<span class="hljs-number">0</span>元素的个数<br>	有向图:对应行非<span class="hljs-number">0</span>元素的个数是“出度”;对应列非<span class="hljs-number">0</span>元素的个数是<span class="hljs-string">&quot;入度&quot;</span><br><br>缺点：<br>- 浪费空间、浪费时间<br></code></pre></td></tr></table></figure>



<h3 id="1-3-邻接表"><a href="#1-3-邻接表" class="headerlink" title="1.3 邻接表"></a><font color='red'>1.3 邻接表</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">- 方便找任一顶点的所有“邻接点”<br>- 节约稀疏图的空间：需要N个头指针+<span class="hljs-number">2</span>E个结点(每个结点至少<span class="hljs-number">2</span>个域)<br>- 方便计算任一顶点的“度”？<br>	对无向图:是的<br>	对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己的边)来方便计算“入度”<br>- 不方便检查任意一对顶点间是否存在边<br></code></pre></td></tr></table></figure>



<h2 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2 图的遍历"></a>2 图的遍历</h2><h3 id="2-1-深度优先搜索"><a href="#2-1-深度优先搜索" class="headerlink" title="2.1 深度优先搜索"></a>2.1 深度优先搜索</h3><p>DFS:Depth First Search</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Vertexy)</span>&#123;<br>    visited[V]= <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>( V的每个邻接点W )<br>        <span class="hljs-keyword">if</span>( !visited[w] )<br>            DES( W ); <br>&#125;<br></code></pre></td></tr></table></figure>



<p>若有N个顶点、E条边，时间复杂度是</p>
<ul>
<li><p>用邻接表存储图，有O(N+E);</p>
</li>
<li><p>用邻接矩阵存储图，有O(N²);</p>
</li>
</ul>
<hr>
<h3 id="2-2-广度优先搜索"><a href="#2-2-广度优先搜索" class="headerlink" title="2.2 广度优先搜索"></a>2.2 广度优先搜索</h3><p>BFS: Breadth First Search</p>
<p>伪码描述</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BFs</span><span class="hljs-params">(VertexV)</span>&#123;<br>    visited[V]= <span class="hljs-literal">true</span>;<br>    Enqueue(V, Q);<br>    <span class="hljs-keyword">while</span>(!IsEmpty(Q))&#123;<br>        V = Dequeue(Q);<br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)<br>            <span class="hljs-keyword">if</span>(!visited[w])&#123;<br>                visited[w]= <span class="hljs-literal">true</span>;<br>                Enqueue(W，Q);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>若有N个顶点、E条边，时间复杂度是</p>
<ul>
<li><p>用邻接表存储图，有O(N+E);</p>
</li>
<li><p>用邻接矩阵存储图，有O(N²);</p>
</li>
</ul>
<hr>
<h2 id="3-图的表示"><a href="#3-图的表示" class="headerlink" title="3 图的表示"></a>3 图的表示</h2><h3 id="3-1-邻接矩阵表示"><a href="#3-1-邻接矩阵表示" class="headerlink" title="3.1 邻接矩阵表示"></a>3.1 邻接矩阵表示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-type">int</span> Nv;<span class="hljs-comment">/*顶点数*/</span><br>    <span class="hljs-type">int</span> Ne;<span class="hljs-comment">/*边数 */</span><br>    WeightType G[MaxVertexNum][MaxVertexNum];<br>    DataType Data[MaxVertexNum];<span class="hljs-comment">/*存顶点的数据*/</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToGNode MGraph;<span class="hljs-comment">/*以邻接矩阵存储的图类型*/</span><br></code></pre></td></tr></table></figure>



<p>初始化一个有VertexNum个顶点但没有边图</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;<span class="hljs-comment">/*用顶点下标表示顶点,为整型*/</span><br>MGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> VertexNum)</span>&#123;<br>    Vertex V, W;<br>    MGraph Graph;<br>    <br>    Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/*注意:这里默认顶点编号从0开始，到(Graph-&gt;Nv-1)*/</span><br>    <span class="hljs-keyword">for</span>(V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)<br>        <span class="hljs-keyword">for</span>(W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++)<br>            Graph-&gt;G[V][W] = <span class="hljs-number">0</span>;<span class="hljs-comment">/*或INFINITY */</span><br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>向MGraph中插入边</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span><br>    Vertex V1，V2;       <span class="hljs-comment">/*有向边&lt;V1，V2&gt; */</span><br>    WeightType Weight;   <span class="hljs-comment">/*权重*/</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToENode Edge;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">(MGraph Graph, Edge E)</span>&#123;<br>    <span class="hljs-comment">/*插入边 &lt;V1，V2&gt;*/</span><br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;<br>    <span class="hljs-comment">/*若是无向图，还要插入边&lt;V2，V1&gt;*/</span><br>    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>完整建立MGraph</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">MGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span>&#123;<br>    MGraph Graph;<br>    Edge E;<br>    Vertex V;<br>    <span class="hljs-type">int</span> Nv, i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;d&quot;</span>, &amp;Nv);<br>    Graph = CreateGraph(Nv);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;d&quot;</span>, &amp;(Graph-&gt;Ne));<br>    <span class="hljs-keyword">if</span>( Graph-&gt;Ne != <span class="hljs-number">0</span>)&#123;<br>        E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode));<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, <br>                  &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);<br>            InsertEdge(Graph，E);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*如果顶点有数据的话，读入数据*/</span><br>    <span class="hljs-keyword">for</span>(V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;c&quot;</span>，&amp;(Graph-&gt;Data[V]));<br>    <br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="3-2-邻接表表示"><a href="#3-2-邻接表表示" class="headerlink" title="3.2 邻接表表示"></a>3.2 邻接表表示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-type">int</span> Nv;   <span class="hljs-comment">/*顶点数*/</span><br>    <span class="hljs-type">int</span> Ne;   <span class="hljs-comment">/*边数 */</span><br>    ADjList G; <span class="hljs-comment">/*邻接表*/</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToGNode LGraph;<span class="hljs-comment">/*以邻接矩阵存储的图类型*/</span><br><br><span class="hljs-keyword">typedef</span> struat Vnode &#123;<br>    PtrToAdjVNode FirstEdge;<br>    DataType Data;<span class="hljs-comment">/*存顶点的数据*/</span><br>&#125;AdjList[MaxVertexNum];<span class="hljs-comment">/*AdjList是邻接表类型 */</span><br>    <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span> *<span class="hljs-title">PtrToAdjVNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span>&#123;</span><br>    Vertex AdjV;<span class="hljs-comment">/*邻接点下标*/</span><br>    WeightType Weight;<span class="hljs-comment">/*边权重*/</span><br>    PtrToAdjVNode Next;<br>&#125;;<br></code></pre></td></tr></table></figure>



<p>LGraph初始化：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;<span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span><br>LGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> VertexNum)</span>&#123;<br>    Vertex V，W;<br>    LGraph Graph;<br>    <br>    Graph = (Graph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(structGNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/*注意:这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1)*/</span><br>    <span class="hljs-keyword">for</span>(V=<span class="hljs-number">0</span>:V&lt;Graph-&gt;Nv;V++)<br>        Graph-&gt;G[V].FirstEdge =<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>LGraph插入边：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">(LGraph Graph，EdgeE)</span>&#123;<br>    PtrToAdjVNode NewNode;<br>    <br>    <span class="hljs-comment">/*************&lt;V1,V2&gt; ***************/</span><br>    <span class="hljs-comment">/*为V2建立新的邻接点 */</span><br>    NewNode =(PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V2;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">/*将v2插入V1的表头*/</span><br>    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;<br>    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;<br>    <br>    <span class="hljs-comment">/********** 若是无向图，还要插入边 &lt;V2,V1&gt; **********/</span><br>    <span class="hljs-comment">/*为V1建立新的邻接点*/</span><br>    NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V1;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">/*将V1插入V2的表头*/</span><br>    NewNode-&gt;Next= Graph-&gt;G[E-&gt;V2].FirstEdge;<br>    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="4-图的最短路径"><a href="#4-图的最短路径" class="headerlink" title="4 图的最短路径"></a>4 图的最短路径</h2><h3 id="4-1-单源最短路径"><a href="#4-1-单源最短路径" class="headerlink" title="4.1 单源最短路径"></a>4.1 单源最短路径</h3><p> 无权单源最短</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Unweighted</span><span class="hljs-params">(Vertex S)</span><br>&#123;<br>    Enqueue(S, Q);<br>    <span class="hljs-keyword">while</span>( !IsEmpty(Q) )&#123;<br>        V = Dequeue(Q);<br>        <span class="hljs-keyword">for</span>( V的每个邻接点W )<br>            <span class="hljs-keyword">if</span>( dist[w]==<span class="hljs-number">-1</span> )&#123;<br>                dist[w] = dist[V]+<span class="hljs-number">1</span>;<br>                path[w] = V;<br>                Enqueue(W, Q);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<p>有无权单源最短</p>
<h4 id="4-1-1-Dijkstra算法"><a href="#4-1-1-Dijkstra算法" class="headerlink" title="4.1.1 Dijkstra算法"></a>4.1.1 Dijkstra算法</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182820828.png" srcset="/img/loading.gif" lazyload alt="QQ_1728121505274" style="zoom: 33%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182822636.png" srcset="/img/loading.gif" lazyload alt="QQ_1728121555895" style="zoom:33%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182825015.png" srcset="/img/loading.gif" lazyload alt="QQ_1728121581571" style="zoom:33%;" />

<p>其他类似问题</p>
<ul>
<li><p>要求数最短路径有多少条</p>
<ul>
<li>count[s]&#x3D;1;</li>
<li>如果找到更短路：count[w] &#x3D; count[V];</li>
<li>如果找到等长路：count[w] +&#x3D; count[V];</li>
</ul>
</li>
<li><p>要求边数最少的最短路</p>
<ul>
<li>count[s]&#x3D;0</li>
<li>如果找到更短路：count[w] &#x3D; count[V] + 1;</li>
<li>如果找到等长路：count[w] &#x3D; count[V] + 1;</li>
</ul>
</li>
</ul>
<h4 id="练习-旅游问题"><a href="#练习-旅游问题" class="headerlink" title="练习 旅游问题"></a>练习 旅游问题</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182828346.png" srcset="/img/loading.gif" lazyload alt="QQ_1728223116469" style="zoom:33%;" />

<p>核心算法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">(Vertex s)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        V = 未收录顶点中dist最小者;<br>        <span class="hljs-keyword">if</span>(这样的V不存在)<br>            <span class="hljs-keyword">break</span>;<br>        collected[V] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(V 的每个邻接点 W)<br>            <span class="hljs-keyword">if</span>(collected[W] == <span class="hljs-literal">false</span> )<br>                <span class="hljs-keyword">if</span>(dist[V] + E&lt;v,w&gt; &lt; dist[W])&#123;<br>                    dist[W] = dist[V] + E&lt;v,w&gt;;<br>                    path[W] = V;<br>                    cost[W] = cost[V] + C&lt;v,w&gt;;<br>                &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((dist[V] + E&lt;v,w&gt; == dist[W])&amp;&amp;(cost[V] + C&lt;v,w&gt; &lt;cost[W]))&#123;<br>            cost[W] = cost[V] + C&lt;v,w&gt;;<br>            path[W] = V;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>





<h3 id="4-2-多源最短路径"><a href="#4-2-多源最短路径" class="headerlink" title="4.2 多源最短路径"></a>4.2 多源最短路径</h3><p>Floyd算法(时间复杂度V³)：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182831733.png" srcset="/img/loading.gif" lazyload alt="QQ_1728121877358" style="zoom:33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Floyd</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)&#123;<br>            D[i][j] = G[i][j];<br>        &#125;<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; N; k++)<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>                <span class="hljs-keyword">if</span>(D[i][k] + D[k][j] &lt; D[i][j])&#123;<br>                    D[i][j] = D[i][k]+ D[k][j];<br>                    path[i][j] = k;<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="4-3-练习"><a href="#4-3-练习" class="headerlink" title="4.3 练习"></a>4.3 练习</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182835323.png" srcset="/img/loading.gif" lazyload alt="QQ_1728126972840" style="zoom:33%;" />



<p>程序设计：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FindAnimal</span><span class="hljs-params">(MGraph Graph)</span>&#123;<br>    WeightType D[MaxVertexNum][MaxVertexNum], MaxDist, MinDist;<br>    Vertex Animal, i;<br>    Floyd( Graph, D);<br>    MinDist = INFINITY;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt; Graph-&gt;Nv; i++)&#123;<br>        MaxDist = FindMaxDist(D, i, Graph-&gt;Nv);<br>        <span class="hljs-comment">/*说明有从i无法变出的动物 */</span><br>        <span class="hljs-keyword">if</span>(MaxDist == INFINITY)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/*找到最长距离更小的动物 */</span><br>        <span class="hljs-keyword">if</span>(MinDist &gt; MaxDist)&#123;<br>            <span class="hljs-comment">/*更新距离，记录编号 */</span><br>            MinDist = MaxDist;<br>            Animal=i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, Animal, MinDist);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    MGraph G = BuildGraph();<br>    FindAnimal(G);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>WeightType <span class="hljs-title function_">FindMaxDist</span><span class="hljs-params">( WeightType D[][MaxVertexNum], Vertex i, <span class="hljs-type">int</span> N)</span>&#123;<br>    WeightType MaxDist;<br>    Vertex j;<br>    <br>    MaxDist = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*找出i到其他动物j的最长距离 */</span><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>        <span class="hljs-keyword">if</span>(i != j &amp;&amp; D[i][j] &gt; MaxDist )<br>            MaxDist = D[i][j];<br>    <span class="hljs-keyword">return</span> MaxDist<br>&#125;<br><br>MGraph CreateGraph(<span class="hljs-type">int</span> VertexNum)&#123;<br>    <span class="hljs-comment">/*初始化一个有vertexNu个顶点但没有边的图 */</span><br>    Vertex V, W;<br>    MGraph Graph;<br>    Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode));<span class="hljs-comment">/*建立图*/</span><br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*初始化邻接矩阵 */</span><br>    <span class="hljs-comment">/*注意:这里默认顶点编号从0开始，到(Graph-&gt;Nv-1)*/</span><br>    <span class="hljs-keyword">for</span>(V = <span class="hljs-number">0</span>; V &lt; Graph-&gt;Nv; V++)<br>        <span class="hljs-keyword">for</span>(W = <span class="hljs-number">0</span>; W &lt; Graph-&gt;Nv; W++)<br>            Graph-&gt;G[V][W] = INFINITY;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( MGraph Graph, Edge E)</span>&#123;<br>    <span class="hljs-comment">/*插入边 &lt;v1，y2&gt;*/</span><br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;<br>    <span class="hljs-comment">/*若是无向图，还要插入边&lt;V2，Vl&gt; */</span><br>    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;<br>&#125;<br><br>MGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span>&#123;<br>    MGraph Graph;<br>    Edge E;<br>    Vertex V;<br>    <span class="hljs-type">int</span> Nv, i;<br>    <span class="hljs-comment">/*读入顶点个数 */</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);<br>    <span class="hljs-comment">/*初始化有v个顶点但没有边的图*/</span><br>    Graph=createGraph(Nv);<br>    <br>    <span class="hljs-comment">/*读入边数 */</span><br>    scan£(<span class="hljs-string">&quot;名d&quot;</span>, &amp;(Graph-&gt;Ne));<br>    <span class="hljs-keyword">if</span>(Graph-&gt;Ne != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">/*如果有边 */</span><br>        E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode)):<span class="hljs-comment">/*建立边结点*</span><br><span class="hljs-comment">        /*读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; Graph-&gt;Ne; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);<br>            <span class="hljs-comment">/*注意:如果权重不是整型，weight的读入格式要改*/</span><br>            InsertEdge(Graph,E);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*如果顶点有数据的话，读入数据*/</span><br>    <span class="hljs-keyword">for</span>(V = <span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;(Graph-&gt;Data[V]));<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Floyd</span><span class="hljs-params">(MGraph Graph, WeightTypr D[][MaxVertexNum])</span>&#123;<br>    Vertex i, j, k;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)&#123;<br>            D[i][j] = G[i][j];<br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; N; k++)<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>                <span class="hljs-keyword">if</span>(D[i][k] + D[k][j] &lt; D[i][j])&#123;<br>                    D[i][j] = D[i][k]+ D[k][j];<br>                    <span class="hljs-keyword">if</span>( i == j &amp;&amp; D[i][j] &lt; <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="五-相应算法"><a href="#五-相应算法" class="headerlink" title="五 相应算法"></a>五 相应算法</h1><h2 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1 贪心算法"></a>1 贪心算法</h2><p>概念：每一步都要权重最小的边</p>
<p>约束：</p>
<ul>
<li>只能用图里面有的边</li>
<li>只能正好用掉n-1条边</li>
<li>不能有回路</li>
</ul>
<h3 id="1-1-Prim算法（稠密图）"><a href="#1-1-Prim算法（稠密图）" class="headerlink" title="1.1 Prim算法（稠密图）"></a>1.1 Prim算法（稠密图）</h3><p>最小生成树——让一棵小树长大：</p>
<ul>
<li>一棵树<ul>
<li>无回路</li>
<li>n个顶点一定要有n-1条边</li>
</ul>
</li>
<li>是生成树<ul>
<li>包含全部顶点</li>
<li>n-1条边都在图里</li>
</ul>
</li>
<li>边的权重和最小</li>
</ul>
<p><font color='red'>向生成树中加一条边都一定构成回路，最小生成树存在&lt;-&gt;图连通</font></p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182840204.png" srcset="/img/loading.gif" lazyload alt="QQ_1728218590969" style="zoom:33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Prim</span><span class="hljs-params">()</span>&#123;<br>    MST = &#123;s&#125;;<br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )&#123;<br>        V = 未收录顶点中dist最小者;<span class="hljs-comment">/* 稠密图时间复杂度——|V|² */</span><br>        <span class="hljs-keyword">if</span>(这样的V不存在)<br>            <span class="hljs-keyword">break</span>;<br>        将V收录进MST: dist[V] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>( V 的每个邻接点 W )<br>            <span class="hljs-keyword">if</span>(dist[W] != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span>(E(v,w) &lt; dist[W])&#123;<br>                    dist[W] = E(v,w);<br>                    parent[W] = V;<br>                &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(MST中收的顶点不到|V|个)<br>        Error(“生成树不存在”);<br>&#125;<br></code></pre></td></tr></table></figure>



<h3 id="1-2-Kruskal算法"><a href="#1-2-Kruskal算法" class="headerlink" title="1.2 Kruskal算法"></a>1.2 Kruskal算法</h3><p>稀疏图——时间复杂度：|E|log|E|</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Kruskal</span><span class="hljs-params">( Graph G )</span>&#123;<br>    MST=&#123; &#125;;<br>    <span class="hljs-keyword">while</span>( MST中不到|V|<span class="hljs-number">-1</span>条边 &amp;&amp; E中还有边)&#123;<br>        从中取一条权重最小的边E(v,w);   <span class="hljs-comment">/*最小堆 */</span><br>        将 E(v,w)从 E 中删除;<br>        <span class="hljs-keyword">if</span>(E(v,w)不在 MST 中构成回路)<br>            将 E(v,w)加入 MST;       <span class="hljs-comment">/*并査集 */</span><br>        <span class="hljs-keyword">else</span><br>            彻底无视E(v,w);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (MST中不到IV!<span class="hljs-number">-1</span>条边)<br>        Error(“生成树不存在”);<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2 拓扑排序"></a>2 拓扑排序</h2><ul>
<li>拓扑序：如果图中从v到w有一条有向路径则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序</li>
<li>获得一个拓扑序的过程就是拓扑排序</li>
<li>AOV(Activity On Vertex)如果有合理的拓扑序，则必定是有向无环图(Directed Acyclic Graph，DAG)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Topsort</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>( 图中每个顶点V )<br>        <span class="hljs-keyword">if</span>(Indegree[V] == <span class="hljs-number">0</span>)<br>            Enqueue(V, Q);<br>    <span class="hljs-keyword">while</span>( !IsEmpty(Q) )&#123;<br>        V=Dequeue(Q);<br>        输出V, 或者记录V的输出序号;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>( V的每个邻接点W )<br>            <span class="hljs-keyword">if</span>(--Indegree[w] == <span class="hljs-number">0</span>)<br>                Enqueue(W, Q);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt != |V|)<br>        Error(“图中有回路”);<br>&#125;<br><br></code></pre></td></tr></table></figure>





<h2 id="3-关键路径问题"><a href="#3-关键路径问题" class="headerlink" title="3 关键路径问题"></a>3 关键路径问题</h2><p>AOE(Activity On Edge)网络：一般用于安排项目的工序</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182845869.png" srcset="/img/loading.gif" lazyload alt="QQ_1728222801310" style="zoom:33%;" />



<h2 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4 KMP算法"></a>4 KMP算法</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182848201.png" srcset="/img/loading.gif" lazyload alt="QQ_1728480304490" style="zoom:33%;" />

<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NotFound -1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[] = <span class="hljs-string">&quot;This is a simple example.&quot;</span>;<br>    <span class="hljs-type">char</span> pattern[] = <span class="hljs-string">&quot;simple&quot;</span>;<br>    Position p = KMP(<span class="hljs-built_in">string</span>, pattern);<br>    <span class="hljs-keyword">if</span>( p == NotFound ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Found.\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-built_in">string</span> + p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>Position <span class="hljs-title function_">KMP</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> *pattern)</span>&#123;  <br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>);<br>    <span class="hljs-type">int</span> m = <span class="hljs-built_in">strlen</span>(pattern);<br>    <span class="hljs-type">int</span> s, p, *match;<br>    <br>    <span class="hljs-keyword">if</span>(n &lt; m) <span class="hljs-keyword">return</span> NotFound;<br>    match = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) *m);<br>    BuildMatch(pattern,match);<br>    s = p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>( s &lt; n &amp;&amp; p &lt; m)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">string</span>[s] == pattern[p])&#123;<br>            s++;<br>            p++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p &gt; <span class="hljs-number">0</span>) p = match[p<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> s++;<br>    &#125;<br>    <span class="hljs-keyword">return</span>( p = m) ? (s - m) : NotFound;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildMatch</span><span class="hljs-params">(<span class="hljs-type">char</span> *pattern, <span class="hljs-type">int</span> *match)</span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">int</span> m = <span class="hljs-built_in">strlen</span>(pattern);<br>    match[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>        i = match[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">while</span>((i &gt;= <span class="hljs-number">0</span>) &amp;&amp; (pattern[i+<span class="hljs-number">1</span>] != pattern[j]))<br>            i = match[i];<br>        <span class="hljs-keyword">if</span> (pattern[i+<span class="hljs-number">1</span>] == pattern[j])<br>            match[j] = i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> match[j] = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h1 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h1><p>没有一种排序是任何情况下都表现最好的</p>
<h2 id="6-1-冒泡排序"><a href="#6-1-冒泡排序" class="headerlink" title="6.1 冒泡排序"></a>6.1 冒泡排序</h2><p>优点：</p>
<ul>
<li>在链表中排序性能比较好</li>
<li>在两个元素相等时候不做交换，一定程度上保证了稳定性</li>
</ul>
<p>时间复杂度：</p>
<ul>
<li>最好情况：顺序T&#x3D;O(N)</li>
<li>最坏情况：逆序T&#x3D;O(N²)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Bubble_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">for</span>(P=N<span class="hljs-number">-1</span>;P&gt;=<span class="hljs-number">0</span>;P--)&#123;<br>        flag =<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/*一趟冒泡*/</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; P; i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i] &gt; A[i+<span class="hljs-number">1</span>])&#123;<br>                Swap(A[i], A[i+<span class="hljs-number">1</span>]);<br>                <span class="hljs-comment">/*标识发生了交换*/</span><br>                flag =<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*全程无交换*/</span><br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-2-插入排序"><a href="#6-2-插入排序" class="headerlink" title="6.2 插入排序"></a>6.2 插入排序</h2><p>时间复杂度：</p>
<ul>
<li>最好情况：顺序T&#x3D;O(N)</li>
<li>最坏情况：逆序T&#x3D;O(N²)</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insertion_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">for</span>(P = <span class="hljs-number">1</span>; P &lt; N; P++)&#123;<br>        <span class="hljs-comment">/* 摸下一张牌 */</span><br>        Tmp = A[P];<br>        <span class="hljs-keyword">for</span>(i = P; i &gt; <span class="hljs-number">0</span> &amp;&amp; A[i<span class="hljs-number">-1</span>] &gt; Tmp; i--)<br>            A[i] = A[i<span class="hljs-number">-1</span>];<span class="hljs-comment">/* 移出空位 */</span><br>        A[i]= Tmp;<span class="hljs-comment">/* 新牌落位 */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-3-希尔排序"><a href="#6-3-希尔排序" class="headerlink" title="6.3 希尔排序"></a>6.3 希尔排序</h2><p>最坏：T&#x3D;O(N²)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-comment">/*希尔增量序列*/</span><br>    <span class="hljs-keyword">for</span>(D = N / <span class="hljs-number">2</span>; D &gt; <span class="hljs-number">0</span>; D /= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">/*插入排序*/</span><br>        <span class="hljs-keyword">for</span>(P = D; P &lt; N; P++)&#123;<br>            Tmp = A[P];<br>            <span class="hljs-keyword">for</span>(i = P; i &gt;= D &amp;&amp; A[i-D] &gt; Tmp;i-=D)<br>                A[i] = A[i-D];<br>            A[i] = Tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-4-堆排序"><a href="#6-4-堆排序" class="headerlink" title="6.4 堆排序"></a>6.4 堆排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Heap_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">for</span>(i = N/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<span class="hljs-comment">/*BuildHeap */</span><br>        PercDown(A, i, N);<br>    <span class="hljs-keyword">for</span>(i = N<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        Swap(&amp;A[<span class="hljs-number">0</span>], &amp;A[i]);<span class="hljs-comment">/*DeleteMax*/</span><br>        PercDown(A, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>



<h2 id="6-5-快速排序"><a href="#6-5-快速排序" class="headerlink" title="6.5 快速排序"></a>6.5 快速排序</h2><p>分而治之</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182856620.png" srcset="/img/loading.gif" lazyload alt="QQ_1728305453057" style="zoom:33%;" />

<p>伪码描述：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Quicksort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>; <br>    pivot = 从A[]中选一个主元;<br>    将s=&#123; A[] \pivot &#125;分成<span class="hljs-number">2</span>个独立子集:<br>    	A1 = &#123;a∈s | a ≤ pivot &#125;和<br>        A2 = &#123;a∈s | a ≥ pivot &#125;;<br>    A[] = Quicksort( A1, N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2, N2);<br>&#125;<br></code></pre></td></tr></table></figure>



<p><font color='red'>当递归的数据规模充分小，则停止递归，直接调用简单排序（例如插入排序）</font></p>
<p>代码实现：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Quicksort</span><span class="hljs-params">( ElementType A[], <span class="hljs-type">int</span> Left, <span class="hljs-type">int</span> Right )</span>&#123;<br>    <span class="hljs-keyword">if</span>(Cutoff &lt;= Right - Left)&#123;<br>        Pivot = Median3(A, Left, Right);<br>        i = Left; j= Right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>( ; ; )&#123;<br>            <span class="hljs-keyword">while</span>(A[++i] &lt; Pivot)&#123;&#125;<br>            <span class="hljs-keyword">while</span>(A[--j] &gt; Pivot)&#123;&#125;<br>            <span class="hljs-keyword">if</span>(i&lt;j)<br>                Swap(&amp;A[i], &amp;A[j]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        Swap( &amp;A[i], &amp;A[ Right<span class="hljs-number">-1</span> ]);<br>        Quicksort(A, Left, i<span class="hljs-number">-1</span>);<br>        Quicksort(A, i+<span class="hljs-number">1</span>, Right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        Insertion_Sort( A + Left, Right - Left + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Quick_sort</span><span class="hljs-params">(ElementType A[],<span class="hljs-type">int</span> N)</span>&#123;<br>    Quicksort(A, <span class="hljs-number">0</span>, N<span class="hljs-number">-1</span>);<br>&#125;<br><br>ElementType <span class="hljs-title function_">Median3</span><span class="hljs-params">( ElementType A[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> Right )</span>&#123;<br>    <span class="hljs-type">int</span> Center = (Left + Right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(A[ Left ] &gt; A[ Center ])<br>        Swap( &amp;A[ Left ], &amp;A[ Center ]);<br>    <span class="hljs-keyword">if</span>(A[ Left ] &gt; A[ Right ])<br>        Swap( &amp;A[ Left ], &amp;A[ Right ]);<br>    <span class="hljs-keyword">if</span>( A[Center] &gt; A[ Right] )<br>        Swap( &amp;A[ Center ]，&amp;A[ Right ]);<br>    <span class="hljs-comment">/*A[ Left ] &lt;= A[ Center ] &lt;= A[ Right ]*/</span><br>    <span class="hljs-comment">/*将pivot藏到右边 */</span><br>    Swap(&amp;A[ Center ], &amp;A[ Right<span class="hljs-number">-1</span> ]);<br>    <span class="hljs-comment">/*只需要考虑 A[ Left+1 ]...A[ Right-2 ]*/</span><br>    <span class="hljs-comment">/*返回 pivot */</span><br>    <span class="hljs-keyword">return</span> A[ Right<span class="hljs-number">-1</span> ];<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-6-表排序"><a href="#6-6-表排序" class="headerlink" title="6.6 表排序"></a>6.6 表排序</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182859444.png" srcset="/img/loading.gif" lazyload alt="QQ_1728354510647" style="zoom:33%;" />

<p>最好情况：初始即有序<br>最坏情况：</p>
<ul>
<li>有⌊N&#x2F;2⌋个环，每个环包含2个元素</li>
<li>需要⌊3N&#x2F;2⌋次元素移动</li>
</ul>
<p>T&#x3D;O(m*N)，m是每个A元素的复制时间。</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182905524.png" srcset="/img/loading.gif" lazyload alt="QQ_1728454658628" style="zoom:33%;" />





<h2 id="6-7-桶排序"><a href="#6-7-桶排序" class="headerlink" title="6.7 桶排序"></a>6.7 桶排序</h2><p>假设我们有N个学生，他们的成绩是0到100之间的整数(于是有M&#x3D;101个不同的成绩值)。如何在线性时间内将学生按成绩排序?</p>
<p>思想：将成绩分成101个桶，然后不停的插入学生成绩，并将其放入不同的桶中，用链表连接起来。</p>
<p>时间复杂度：T(N,M) &#x3D; O(M+N)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Bucket_Sort</span><span class="hljs-params">(ElementType A[],<span class="hljs-type">int</span> N)</span>&#123;<br>        count[]初始化;<br>    <span class="hljs-keyword">while</span>(读入<span class="hljs-number">1</span>个学生成绩grade)<br>        将该生插入count[grade]链表;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; M; i++)&#123;<br>        <span class="hljs-keyword">if</span>( count[i])<br>            输出整个count[i]链表;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>



<h2 id="6-8-基数排序"><a href="#6-8-基数排序" class="headerlink" title="6.8 基数排序"></a>6.8 基数排序</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182908617.png" srcset="/img/loading.gif" lazyload alt="QQ_1728356135762" style="zoom:33%;" />



<h2 id="6-9-多关键字排序"><a href="#6-9-多关键字排序" class="headerlink" title="6.9 多关键字排序"></a>6.9 多关键字排序</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182911138.png" srcset="/img/loading.gif" lazyload alt="QQ_1728357158788" style="zoom:33%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182913409.png" srcset="/img/loading.gif" lazyload alt="QQ_1728357195960" style="zoom:33%;" />



<p>问题：LSD任何时候都比MSD快吗？</p>
<p>不一定。极端情况下，当主位可以一次性把元素都直接分开、而次位办不到的时候，显然MSD更好。一般情况下，如果主位的基数比次位大（例如扑克牌如果先按面值、同一面值内部按花色排序的话），则主位更有可能把元素分开，这时候用MSD就可能比LSD快。</p>
<h2 id="6-10-排序算法的比较"><a href="#6-10-排序算法的比较" class="headerlink" title="6.10 排序算法的比较"></a>6.10 排序算法的比较</h2><table>
<thead>
<tr>
<th align="center">排序方法</th>
<th align="center">平均时间复杂度</th>
<th align="center">最坏情况下时间复杂度</th>
<th align="center">额外空间复杂度</th>
<th align="center">稳定性</th>
</tr>
</thead>
<tbody><tr>
<td align="center">简单选择排序</td>
<td align="center">O(N²)</td>
<td align="center">O(N²)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">冒泡排序</td>
<td align="center">O(N²)</td>
<td align="center">O(N²)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">直接插入排序</td>
<td align="center">O(N²)</td>
<td align="center">O(N²)</td>
<td align="center">O(1)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">希尔排序</td>
<td align="center">O(Nᵈ)</td>
<td align="center">O(N²)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">堆排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(1)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">快速排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(N²)</td>
<td align="center">O(logN)</td>
<td align="center">不稳定</td>
</tr>
<tr>
<td align="center">归并排序</td>
<td align="center">O(NlogN)</td>
<td align="center">O(NlogN)</td>
<td align="center">O(N)</td>
<td align="center">稳定</td>
</tr>
<tr>
<td align="center">基数排序</td>
<td align="center">O(P(N+B))</td>
<td align="center">O(P(N+B))</td>
<td align="center">O(N+B)</td>
<td align="center">稳定</td>
</tr>
</tbody></table>
<h1 id="七、散列表"><a href="#七、散列表" class="headerlink" title="七、散列表"></a>七、散列表</h1><p>【问题】如何快速搜索到需要的关键词？如果关键词不方便比较怎么办？</p>
<p>查找的本质：已知对象找位置</p>
<ul>
<li>有序安排对象:全序、半序</li>
<li>直接“算出”对象位置：散列</li>
</ul>
<p>散列查找法的两项基本工作：</p>
<ul>
<li>计算位置：构造散列函数确定关键词存储位置；</li>
<li>解决冲突：应用某种策略解决多个关键词位置相同的问题</li>
</ul>
<p><font color="red">时间复杂度几乎是常量：O(1)，</font>即查找时间与间题规模无关！</p>
<h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182918157.png" srcset="/img/loading.gif" lazyload alt="QQ_1728455929633" style="zoom:33%;" />

<p><font color='red'>“散列函数”的基本思想：</font></p>
<p>(1)以关键字key为自变量，通过一个确定的函数h(散列函数)计算出对应的函数值h(key)，作为数据对象的存储地址。</p>
<p>(2)可能不同的关键字会映射到同一个散列地址上，即h(keyi)&#x3D; h(keyj)(当key¡≠keyj)，称为“冲突(Collision)”</p>
<p>—需要某种冲突解决策略</p>
<p><font color='red'><strong>好的散列函数需要考虑两个因素</strong></font></p>
<ol>
<li>计算简单，以便提高转换速度；</li>
<li>关键词对应的地址空间分布均匀，以尽量减少冲突。</li>
</ol>
<figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">选择合适的<span class="hljs-built_in">h</span>(key)，散列法的查找效率期望是常数<span class="hljs-number">0</span>(<span class="hljs-number">1</span>)，它几乎与关键字的空间的大小n无关！也适合于关键字直接比较计算量大的问题。<br><br>它是以较小的<span class="hljs-selector-tag">a</span>为前提。因此，散列方法是一个以空间换时间<br><br>散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找。<br></code></pre></td></tr></table></figure>





<h2 id="7-2-数字关键词的散列函数构造"><a href="#7-2-数字关键词的散列函数构造" class="headerlink" title="7.2 数字关键词的散列函数构造"></a>7.2 数字关键词的散列函数构造</h2><ol>
<li><p>直接地址法</p>
<p>取关键词的某个线性函数值为散列地址，即：<font color='purple'>h(key) &#x3D; a * key + b </font></p>
</li>
<li><p>除留余数法</p>
<p>散列函数为：h(key) &#x3D; key mod p</p>
</li>
<li><p>数字分析法<br>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址</p>
<p>比如:取11位手机号码key的后4位作为地址：<br>散列函数为：h(key)&#x3D; atoi(key + 7)(char * key)</p>
</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182921146.png" srcset="/img/loading.gif" lazyload alt="QQ_1728465472650" style="zoom:33%;" />

<ol start="4">
<li>折叠法<br>把关键词分割成位数相同的几个部分，然后叠加</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182923141.png" srcset="/img/loading.gif" lazyload alt="QQ_1728465814502" style="zoom:33%;" />

<ol start="5">
<li>平方取中法</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182925212.png" srcset="/img/loading.gif" lazyload alt="QQ_1728465873003" style="zoom:33%;" />



<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">总结：<br></code></pre></td></tr></table></figure>

<ol>
<li><p>一个简单的散列函数——ASCII码加和法</p>
<p>对字符型关键词key定义散列函数如下<br>h(key)&#x3D; (Σkey[i]) mod TableSize</p>
</li>
<li><p>简单的改进——前3个字符移位法<br>h(key)&#x3D;(key[0]x27² + key[1]x27 + key[2]) mod TableSize</p>
</li>
<li><p>好的散列函数——移位法</p>
<p>涉及关键词所有n个字符，并且分布得很好:</p>
</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182927959.png" srcset="/img/loading.gif" lazyload alt="QQ_1728466320250" style="zoom:33%;" />

<h2 id="7-3-冲突处理方法"><a href="#7-3-冲突处理方法" class="headerlink" title="7.3 冲突处理方法"></a>7.3 冲突处理方法</h2><p>常用处理冲突的思路：</p>
<ul>
<li>换个位置:开放地址法</li>
<li>同一位置的冲突对象组织在一起：链地址法</li>
</ul>
<h3 id="7-3-1-开放定址法-OpenAddressing"><a href="#7-3-1-开放定址法-OpenAddressing" class="headerlink" title="7.3.1 开放定址法(OpenAddressing)"></a>7.3.1 开放定址法(OpenAddressing)</h3><p>一旦产生了冲突（该地址已有其它元素），就按某种规则去寻找另一空地址</p>
<ul>
<li><p>若发生了第i次冲突，试探的下一个地址将增加d，基本公式是：</p>
<p>hᵢ(key) &#x3D; (h(key)+dᵢ)  mod TableSize (1&lt; i &lt; TableSize)</p>
</li>
<li><p>dᵢ决定了不同的解决冲突方案：<font color='red'>线性探测、平方探测、双散列</font></p>
</li>
</ul>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-code">	散列表是一个数组，存储效率高，随机查找</span><br><span class="hljs-code"></span><br>缺点：<br><span class="hljs-code">	散列表有“聚集”现象</span><br></code></pre></td></tr></table></figure>



<h3 id="7-3-2-分离链接法-Separate-Chaining"><a href="#7-3-2-分离链接法-Separate-Chaining" class="headerlink" title="7.3.2 分离链接法(Separate Chaining)"></a>7.3.2 分离链接法(Separate Chaining)</h3><p>将相应位置上冲突的所有关键词储存在同一个单链表中，将其相应的都串起来</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低。<br><br>关键字删除不需要“懒惰删除”法，从而没有存储“垃圾”<br><br>太小的<span class="hljs-selector-tag">a</span>可能导致空间浪费，大的<span class="hljs-selector-tag">a</span>又将付出更多的时间代价。不均匀的链表长度导致时间效率的严重下降。<br></code></pre></td></tr></table></figure>






































                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="category-chain-item">数据结构</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" class="print-no-link">#数据结构</a>
      
        <a href="/tags/java/" class="print-no-link">#java</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Java数据结构</div>
      <div>http://example.com/2024/06/25/Java数据结构/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alaskaboo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2024年6月25日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年6月25日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2024/06/25/python%E5%AD%A6%E4%B9%A0/" title="python语法">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">python语法</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/01/24/hello-world/" title="Hello World">
                        <span class="hidden-mobile">Hello World</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://www.cnblogs.com/Alaskaboo" target="_blank" rel="nofollow noopener"><span>Alaskaboo</span></a> <i class="iconfont icon-love"></i> <a href="" target="_blank" rel="nofollow noopener"><span>以玖</span></a>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    

  

</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      渝ICP备2022011653号-1
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=2022011653号-1"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>渝ICP备2022011653号-1</span>
        </a>
      </span>
    
  
</div>

  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
