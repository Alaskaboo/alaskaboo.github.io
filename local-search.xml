<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>YOLOv9论文</title>
    <link href="/2025/07/17/YOLOv9%E8%AE%BA%E6%96%87/"/>
    <url>/2025/07/17/YOLOv9%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<h1 id="一、论文地位"><a href="#一、论文地位" class="headerlink" title="一、论文地位"></a>一、论文地位</h1><p>阅读论文时我通常先查看摘要和结论，以快速把握其核心内容与研究方向。</p><h2 id="1-1-核心技术创新：突破深度网络的信息瓶颈"><a href="#1-1-核心技术创新：突破深度网络的信息瓶颈" class="headerlink" title="1.1 核心技术创新：突破深度网络的信息瓶颈"></a>1.1 核心技术创新：突破深度网络的信息瓶颈</h2><ol><li><p><strong>可编程梯度信息（PGI）</strong></p><p>为解决轻量级模型中从 I(X, X) 准确提取 I(Y, X) 的难题，作者提出了新的辅助监督框架：可编程梯度信息（PGI, Programmable Gradient Information）。</p><ul><li><strong>问题背景</strong>：传统深度网络在逐层特征提取中易丢失关键信息，导致梯度更新偏差，模型预测错误。</li><li><strong>解决方案</strong>：PGI通过引入辅助可逆分支，在训练时生成可靠梯度，确保深层特征保留目标任务所需的关键信息。</li><li><strong>优势</strong>：<ul><li><strong>无额外推理成本</strong>：辅助分支仅在训练阶段使用，推理时仅保留主分支。</li><li><strong>灵活性</strong>：支持自定义损失函数，适配不同任务需求。</li><li><strong>普适性</strong>：适用于从轻量级到大型模型的训练，尤其对小模型效果显著。</li></ul></li></ul></li><li><p><strong>通用高效层聚合网络（GELAN）</strong></p><ul><li><strong>架构设计</strong>：结合CSPNet的跨级部分连接与ELAN的高效层聚合，通过梯度路径规划优化特征传播。</li><li>核心优势：<ul><li><strong>轻量化与高效性</strong>：仅使用传统卷积算子，参数利用率超越依赖深度可分卷积的SOTA模型（如YOLOv8）。</li><li><strong>灵活性</strong>：支持用户根据硬件平台（如CPU、GPU、边缘设备）选择计算模块，平衡速度与精度。</li></ul></li><li><strong>性能验证</strong>：在MS-COCO数据集上，GELAN架构的模型在参数效率上显著优于现有技术，<font color='blue'><strong>相较YOLOv8，YOLOv9参数数量减少了<font color='red'>49%</font>，计算量减少了<font color='red'>43%</font>，同时准确率提升了<font color='red'>0.6%</font>。</strong></font></li></ul><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250719144434760.png" alt="GELAN"></p></li></ol><h2 id="2-2-行业地位：推动目标检测技术边界"><a href="#2-2-行业地位：推动目标检测技术边界" class="headerlink" title="2.2 行业地位：推动目标检测技术边界"></a>2.2 行业地位：推动目标检测技术边界</h2><ol><li>技术革新标杆<ul><li><strong>理论突破</strong>：从可逆函数角度分析深度网络信息丢失问题，提出PGI与GELAN架构，为模型设计提供新范式。</li><li><strong>开源生态</strong>：代码与论文公开，推动学术界与工业界研究，加速技术迭代。</li></ul></li><li>未来趋势影响<ul><li><strong>轻量化与高效化</strong>：YOLOv9的GELAN架构为实时检测模型设计提供新思路，推动行业向更高效的方向发展。</li><li><strong>多模态融合</strong>：其技术可扩展至视频理解、3D目标检测等领域，支持更复杂的智能系统构建。</li></ul></li></ol><h1 id="二、提出背景"><a href="#二、提出背景" class="headerlink" title="二、提出背景"></a>二、提出背景</h1><p>YOLOv9的提出主要基于解决<strong>深度神经网络中的信息丢失问题</strong>，并提升目标检测模型在速度与精度之间的平衡：</p><ol><li><p><strong>信息瓶颈现象</strong>：深度神经网络在逐层提取和变换过程中会丢失关键信息，形成信息瓶颈，进而导致梯度偏差，影响模型对目标特征的准确学习。</p></li><li><p><strong>现有方法的局限性</strong>：</p><ul><li><p>可逆架构：需要附加层来组合重复输入的数据，显著增加推理成本。</p></li><li><p>掩模建模：重建损失有时与目标损失相冲突。</p></li><li><p>深度监督机制：会产生误差积累，浅层监督丢失信息后，后续层无法检索所需信息</p></li></ul></li></ol><h1 id="三、模型架构"><a href="#三、模型架构" class="headerlink" title="三、模型架构"></a>三、模型架构</h1><p>这张架构图清晰呈现了YOLOv9的创新网络设计，<font color='red'><strong>其核心聚焦于解决深度神经网络训练中的信息丢失问题</strong></font>，以此提升目标检测的精度与效率。架构中主、辅分支协同作业，PGI架构更凭借二者的紧密配合、辅助可逆分支的可逆设计以及对辅助信息的有效利用，成功化解信息丢失难题。</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250719143031979.png" alt="YOLOv9架构图"></p><p><strong>主分支（Main Branch，浅蓝色方块）</strong></p><blockquote><ul><li><strong>功能定位</strong>：承担从输入图像中提取关键特征并进行最终预测的任务。</li><li><strong>处理流程</strong>：<ul><li>输入图像经过一系列卷积层、激活函数层等操作，逐步提取特征，从低级边缘、纹理信息到高级语义信息。</li><li>特征图尺寸可能减小，通道数增加，以捕捉更复杂特征。</li></ul></li><li><strong>预测输出</strong>：通过预测头输出目标检测结果，包括类别概率、边界框坐标等信息。</li></ul></blockquote><p><strong>辅助分支（Auxiliary Branch，灰色方块）</strong></p><blockquote><ul><li><strong>核心作用</strong>：在训练过程中为主分支提供额外的梯度信息，帮助主分支更好地学习和调整参数。</li><li><strong>结构设计</strong>：<ul><li>采用类似U-Net的跳跃连接结构，在不同层次上与主分支进行信息交互。</li><li>从主分支不同阶段获取特征图，通过池化操作下采样，提取更抽象特征，再通过上采样恢复尺寸，便于融合。</li></ul></li></ul></blockquote><blockquote><ul><li><strong>信息融合</strong>：将处理后的特征信息与主分支的特征信息进行融合，方式可以是拼接或加权求和等，使主分支获取更全面的信息，生成更准确的梯度用于反向传播。</li></ul></blockquote><p><strong>辅助可逆分支（Auxiliary Reversible Branch，蓝色虚线框内）</strong></p><blockquote><ul><li><strong>可逆设计原理</strong>：关键特性是可逆性，确保训练过程中输入信息可通过运算过程完整恢复，通过精心设计的运算和存储机制实现。</li><li><strong>操作过程</strong>：进行池化和上采样等操作，池化降低分辨率、提取主要特征，上采样恢复分辨率，与其他层次特征融合，为主分支提供高质量梯度信息。</li></ul></blockquote><p><strong>多级辅助信息（Multi-level Auxiliary Information，粉红色虚线框）</strong></p><blockquote><ul><li><strong>信息来源与作用</strong>：辅助分支处理过程中产生的额外信息，包括不同层次的特征表示、中间计算结果等，为训练过程提供更多上下文信息，帮助主分支更好地理解输入图像的复杂特征。</li></ul></blockquote><p><strong>信息流动细节</strong></p><blockquote><ol><li><strong>输入阶段</strong>：输入图像位于图的左下角，它包含了需要检测的目标（如图中的狗和汽车）。</li><li><strong>主分支初始处理</strong>：输入图像进入主分支后，首先经过一些基础的卷积层，这些层会对图像进行初步的特征提取，例如检测图像中的边缘和纹理信息。</li><li><strong>辅助分支介入与信息交互</strong>：在主分支处理的过程中，辅助分支开始工作。辅助分支从主分支的不同层次获取特征图，并进行池化操作，将特征图的尺寸缩小，同时提取更抽象的特征。然后，辅助分支通过上采样操作将特征图的尺寸恢复到与主分支相应层次相同的尺寸，并与主分支的特征图进行融合。这种融合操作使得主分支能够获取到辅助分支提供的额外信息。</li><li><strong>梯度生成与反向传播</strong>：融合后，辅助分支生成高质量梯度，通过反向传播更新主分支参数。通过这种方式，主分支能够根据辅助分支提供的梯度信息，更好地调整自身的参数，以提高目标检测的准确性。</li><li><strong>预测输出阶段</strong>：经过多层处理和特征融合后，主分支通过预测头输出最终的目标检测结果。预测头会根据学习到的特征信息，对图像中的目标进行分类和定位，输出目标的类别、边界框的坐标等信息。</li></ol></blockquote><h1 id="四、训练"><a href="#四、训练" class="headerlink" title="四、训练"></a>四、训练</h1><ol><li><strong>训练设置</strong><ul><li>实验采用MS COCO 2017数据集，遵循YOLOv7 AF设置，模型从头开始训练500个epoch。</li><li>学习率设置：前3个epoch采用线性预热；后续epoch依据模型规模设定相应衰减方式；最后15个epoch关闭mosaic。</li></ul></li><li><strong>模型构建与架构设计</strong><ul><li>基于YOLOv7和Dynamic YOLOv7 构建YOLOv9的通用版本和扩展版本。</li><li>网络架构设计：使用带有计划RepConv的CSPNet模块，以GELAN替代ELAN，简化下采样模块，并优化无锚框预测头。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Transformer论文</title>
    <link href="/2025/07/16/transformer%E8%AE%BA%E6%96%87/"/>
    <url>/2025/07/16/transformer%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>Transformer 原始论文 <strong>《Attention is All You Need》</strong>，由 Vaswani 等人于 <strong>2017 年 6 月</strong>发布，是近年来最具革命性的深度学习论文之一，它不仅在自然语言处理领域带来了根本性变革，也为图像处理、音频处理、分子建模、强化学习等领域开辟了新的研究方向。</p><h1 id="一、论文地位"><a href="#一、论文地位" class="headerlink" title="一、论文地位"></a>一、论文地位</h1><p>因为首先看论文的摘要和结果（结论）能让读者把握整篇论文的大致方向，因此我在读论文的时候基本也是采用这种方式进行，</p><h2 id="1-1-论文成果"><a href="#1-1-论文成果" class="headerlink" title="1.1 论文成果"></a>1.1 论文成果</h2><p>如下是在论文中展示的成果，但深远的成果我会娓娓道来：</p><ol><li><p><strong>彻底摒弃循环神经网络（RNN）结构</strong></p><ul><li><p>在当时，NLP 的主流模型是 LSTM、GRU 等循环神经网络，处理长文本效率低，训练过程难以并行。</p></li><li><p>Transformer 完全抛弃循环结构，用 <strong>注意力机制（Attention）</strong> 实现了更快、更并行、更准确的建模。</p></li></ul></li><li><p><strong>提出自注意力机制（Self-Attention）</strong></p><ul><li><font color='blue'><strong>第一个完全基于注意力机制的序列转导模型</strong></font>，它用<strong>多头自注意力</strong>机制取代了编码器-解码器架构中最常用的循环层</li><li>模型中每个词都可以看到整个句子的所有词，解决了长距离依赖问题，成为后续大模型的基础模块。</li></ul></li><li><p><strong>统一的模型框架</strong></p><ul><li>不再区分语言建模、翻译、摘要等任务模型结构，Transformer 提供了一个统一的、可扩展的架构。</li></ul></li></ol><p>在翻译任务中，都取得了当时的最佳性能，并且超过了之前报道的所有的集成模型（PS：集成模型就是多个模型进行合作，也就是transformer单个模型可以一穿几，丝毫不惧）</p><h2 id="1-2-后续影响"><a href="#1-2-后续影响" class="headerlink" title="1.2 后续影响"></a>1.2 后续影响</h2><p>✅ 引发预训练语言模型浪潮</p><p>Transformer 成为 GPT、BERT、T5、XLNet、RoBERTa 等一系列模型的基础：</p><table><thead><tr><th>模型</th><th>基础结构</th><th>发布年份</th><th>特点</th></tr></thead><tbody><tr><td>BERT</td><td>双向 Transformer Encoder</td><td>2018</td><td>掀起 NLP 预训练革命</td></tr><tr><td>GPT</td><td>单向 Transformer Decoder</td><td>2018+</td><td>引领大模型时代</td></tr><tr><td>T5</td><td>Encoder-Decoder Transformer</td><td>2020</td><td>所有任务统一为文本生成</td></tr></tbody></table><p>✅ 催生通用 AI 模型</p><p>Transformer 被拓展至：</p><ul><li>图像领域（Vision Transformer, ViT）</li><li>多模态（CLIP, Flamingo）</li><li>音频建模（AudioLM, Whisper）</li><li>分子建模（AlphaFold 使用 attention）</li><li>编码任务（Codex, CodeT5）</li></ul><p>✅ 成为大模型（LLM）的核心结构</p><p>所有大语言模型（如 GPT-4、Claude、Gemini、通义千问、文心一言）都基于 Transformer 结构。</p><p><strong>总结一句话：</strong></p><blockquote><p><font color='red'><strong>Transformer 是现代深度学习架构中最具颠覆性的成果之一，彻底改变了人类设计、训练与部署 AI 模型的方式。</strong></font></p></blockquote><h1 id="二、提出背景"><a href="#二、提出背景" class="headerlink" title="二、提出背景"></a>二、提出背景</h1><p>✅ 传统的网络模型有很大的缺点，在2017年之前的模型主要是依赖于序列转导模型，这样的方式是基于上一个层的输出作为下一层的输入进行预测，假如在<strong>转折点预测的好</strong>那就是跟输出结果一样完全拟合。</p><center>    <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716145553621.png" alt="预测的好的样子" style="zoom: 67%;" /></center><p>但是如果在<strong>转折点预测的不好</strong>的话</p><center><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716145651405.png" alt="预测不好的样子1" style="zoom:67%;" /></center><center>    <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716145723820.png" alt="预测不好的样子2" style="zoom:67%;" /></center><p>当时只有极少数的情况下不搭配RNN使用，其他任务均与RNN搭配使用。基于此，提出了Transformer架构，摒弃了循环机制，完全依赖于注意力机制来提取输入和输出之间的全局依赖关系。</p><h1 id="三、模型架构"><a href="#三、模型架构" class="headerlink" title="三、模型架构"></a>三、模型架构</h1><h2 id="3-1-整体架构图"><a href="#3-1-整体架构图" class="headerlink" title="3.1 整体架构图"></a>3.1 整体架构图</h2><p>模型框架有Encoder-Decoder组成：</p><p>​✅ 左边是编码器，负责将输入序列映射为连续表示。6个相同的层堆叠——每个层包括<strong>多头注意力层和前馈网络</strong>，使用的关键技术主要有残差链接、LayerNorm(这个归一化不需要补齐，不像batchLayer)、维度dim_mode&#x3D;512。</p><p>​✅ 右边是解码器，负责自回归生成输出序列。除了编码器相同的6层内容之外还在每层中新增编码器-解码器注意力机制，同时进行一系列处理：防止当前位置关注后续位置的掩码自注意力和确保位置i仅依赖一直输出的输出嵌入偏移。</p><blockquote><p><font color='red'>两者最核心的组件是：<strong>多头注意力层和前馈网络</strong></font>，在网络模型中所有的输入都是经过一个统一的位置编码成数字进行输入运算。</p></blockquote><center>    <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716151225852.png" alt="模型架构" style="zoom:50%;" /></center><p>另外论文中提到一个端到端网络，这种网络无需人工设计复杂模块，实现整个模块可以通过一个统一的损失函数用反向传播进行整体训练。即可以从整体直接从训练数据中学习输入到输出的完整映射。</p><h2 id="3-2-注意力机制"><a href="#3-2-注意力机制" class="headerlink" title="3.2 注意力机制"></a>3.2 注意力机制</h2><p>这个注意力机制可谓是论文的核心卖点：</p><blockquote><p>注意力机制可以描述为将一个查询和一组键值对映射到一个输出，其中查询、键、值和输出都是向量。输出计算为值的加权和，其中分配给每个值的权重由查询与相应键的兼容函数计算。</p></blockquote><p>这里面主要包含一下两个核心模块：</p><h3 id="3-2-1-缩放点积注意力"><a href="#3-2-1-缩放点积注意力" class="headerlink" title="3.2.1 缩放点积注意力"></a>3.2.1 缩放点积注意力</h3><p>论文中提到的是加性注意力和点积注意力，加性注意力使用具有单个隐藏层的前馈网络来计算兼容性函数。虽然两者在理论复杂度上相似，<font color='red'><strong>但点积注意力在实践中更快，空间效率更高</strong></font>，因为它可以使用高度优化的矩阵乘法代码来实现。</p><p>如下是缩放点积注意力机制图：</p><center>    <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716161317359.png" alt="Scaled Dot-Product Attention" style="zoom: 33%;" /></center><p>✅可以把注意力机制想象成 <font color='red'><strong>图书馆查资料</strong></font>的过程：</p><ul><li>你是读者，你带着一个”问题”去找答案；</li><li>图书馆里有很多本书（信息），你要找出最相关的书并阅读它；</li></ul><table><thead><tr><th>角色</th><th>在注意力中的名字</th><th>含义</th></tr></thead><tbody><tr><td>你的问题</td><td><strong>Query (Q)</strong></td><td>你在当前这个位置想知道什么内容</td></tr><tr><td>每本书的标题</td><td><strong>Key (K)</strong></td><td>每条信息的索引，决定它是否与你的问题相关</td></tr><tr><td>每本书的正文</td><td><strong>Value (V)</strong></td><td>实际的信息内容，如果你决定看这本书，就读它的正文</td></tr></tbody></table><p>✅在 Self-Attention 中，<font color='blue'><strong>Q&#x2F;K&#x2F;V 都是从同一组输入向量生成的，只是通过不同的线性变换得来</strong>。</font></p><p>假设一个句子有三个词（如 “I love NLP”），嵌入后是：</p><figure class="highlight gml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs gml">输入序列 X = [<span class="hljs-variable language_">x</span>₁, <span class="hljs-variable language_">x</span>₂, <span class="hljs-variable language_">x</span>₃]   ← 每个 <span class="hljs-variable language_">x</span>ᵢ 是 d_model 维度向量<br></code></pre></td></tr></table></figure><p>然后我们用 3 个不同的权重矩阵生成 Q&#x2F;K&#x2F;V：</p><figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">Q</span> <span class="hljs-operator">=</span> X × W_Q      ← 查询向量<br><span class="hljs-attribute">K</span> <span class="hljs-operator">=</span> X × W_K      ← 键向量<br><span class="hljs-attribute">V</span> <span class="hljs-operator">=</span> X × W_V      ← 值向量<br></code></pre></td></tr></table></figure><p>其中 $W_Q, W_K, W_V$是可训练参数矩阵。</p><p>✅数学层面理解Attention 的公式如下：</p><p><font color='red'><strong>$Attention(Q,K,V)&#x3D;\text{Softmax}\left(\frac{QK^T}{\sqrt{d_k}}\right) V$</strong></font></p><ul><li>$QK^T$：计算 Query 和所有 Key 的相似度（打分）</li><li>Softmax：将打分转换为概率（注意力权重）</li><li>乘以 V：将 Value 按照注意力权重加权，得到输出</li></ul><h3 id="3-2-2-多头注意力"><a href="#3-2-2-多头注意力" class="headerlink" title="3.2.2 多头注意力"></a>3.2.2 多头注意力</h3><p>使用不同的学习线性投影将查询、键和值线性投影h次到$d_k、d_k$和$d_v$维分别是有益的。然后，我们在这些投影后的查询、键和值版本上并行执行注意力函数，产生$d_v$-dimensional输出值。这些值被连接起来，并再次被投影，最终得到最终值。</p><center>    <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716181701191.png" alt="Multi-Head Attention" style="zoom:30%;"/></center><p>你可以想象：</p><blockquote><p>一段话由多个专家同时理解，每个“头”是一个专家，从不同角度理解这句话（比如语法、情感、实体）；最后把所有专家的意见整合后，给出最终的理解结果。</p></blockquote><p><strong>✅数学层面理解Attention 的公式如下：</strong></p><p><font color='red'> $MultiHead(Q,K,V) &#x3D; Concat(head_1,…,head_h)W^O  $</font></p><p> where  $head_i &#x3D; Attention(QW^Q_i,KW^K_i,VW^V_i)$</p><ul><li>W各自的注意力特征提取矩阵</li></ul><p><strong>Multi-Head Attention 的优点</strong></p><ul><li>每个头能学习不同类型的语义关系（如“主谓”、“时间”、“位置”）</li><li>并行计算提高训练效率</li><li>增强模型表达能力和泛化能力</li></ul><h3 id="3-3-3-Why-Self-Attention"><a href="#3-3-3-Why-Self-Attention" class="headerlink" title="3.3.3 Why Self-Attention"></a>3.3.3 Why Self-Attention</h3><p>使用self-attention主要考虑了如上图的三个因素：</p><ul><li><p>一是每层的总计算复杂度</p><blockquote><p>主要衡量每层计算的时间复杂度了，其中n是输入的序列长度，d是向量维数。可以发现当序列长度n小于表示维度d时，自注意层比RNN和CNN快，如果是较长序列的任务时，考虑将自注意限制大小，即相当于选择长序列的一部分进行处理。</p></blockquote></li><li><p>二是网络中远程依赖关系之间的路径长度</p><blockquote><p>表示的是当前元素向前或向后必须穿越的路径长度，简单来理解，只有RNN因为每一个位置的输出都需要前一个位置的输出作为输入，所以第n个位置需要等前n-1个位置全部算出，故为O(n)。</p></blockquote></li><li><p>三是任意两个输入和输出位置之间的最大路径长度</p><blockquote><p>简单理解就是一个信息从一个数据点走到另一个数据点要多远</p></blockquote></li></ul><h2 id="3-3-关键技术细节"><a href="#3-3-关键技术细节" class="headerlink" title="3.3 关键技术细节"></a>3.3 关键技术细节</h2><h3 id="3-3-1-位置感知前馈网络"><a href="#3-3-1-位置感知前馈网络" class="headerlink" title="3.3.1 位置感知前馈网络"></a>3.3.1 位置感知前馈网络</h3><p>Position-wise Feed-Forward Networks：该网络分别且相同地应用于每个位置。这由两个线性变换组成，它们之间有一个ReLU激活函数。</p><p>✅数学层面理解FFN的公式如下：</p><ul><li>$FFN(x) &#x3D; max(0,xW_1 +b_1)W_2 +b_2$</li></ul><p>🧠 一句话解释：</p><blockquote><p><font color='red'><strong>Position-wise Feed-Forward Networks（FFN）是对每个位置的向量单独做非线性变换，增强模型的表示能力。</strong></font></p></blockquote><p>它本质上是一个小型的多层感知机（MLP），对每个位置的 token 表示进行<strong>独立且一致</strong>的前馈计算。</p><table><thead><tr><th>特点</th><th>说明</th></tr></thead><tbody><tr><td><strong>逐位置</strong></td><td>FFN 对每个 token 的表示<strong>单独处理</strong>，不与其他位置交互</td></tr><tr><td><strong>全连接 + 非线性</strong></td><td>增强模型非线性表达能力</td></tr><tr><td><strong>参数共享</strong></td><td>所有位置用相同的 FFN（即 W₁、W₂ 是共享的）</td></tr><tr><td><strong>不引入序列依赖</strong></td><td>不像注意力有位置间交互，FFN 是“点对点”处理</td></tr></tbody></table><h3 id="3-3-2-位置编码"><a href="#3-3-2-位置编码" class="headerlink" title="3.3.2 位置编码"></a>3.3.2 位置编码</h3><p>由于模型不包含循环和卷积，为了使模型能够利用序列的顺序，必须注入一些关于序列中标记的相对或绝对位置的信息。为此，在编码器和解码器堆栈的底部向输入嵌入添加“位置编码”。</p><p>（🧠PS:为什么要位置编码？其实说白了给每个token一个编制，相对于工号一样的东西，方便看到工号就能知道这是那个人）</p><p>在对比之下选择的是正弦函数生成的位置嵌入，替代递归&#x2F;卷积的位置信息。</p><p>✅数学层面理解Positional Encoding公式：</p><p><font color='red'>$PE_{(pos,2i)}&#x3D; sin(pos&#x2F;10000^{2i&#x2F;dmodel}) $</font>，我们选择的这个</p><p>$PE_{(pos,2i+1)} &#x3D; cos(pos&#x2F;10000^{2i&#x2F;dmodel})$</p><h2 id="🎯-架构理解总结"><a href="#🎯-架构理解总结" class="headerlink" title="🎯 架构理解总结"></a>🎯 架构理解总结</h2><table><thead><tr><th>步骤</th><th>模块</th><th>作用</th></tr></thead><tbody><tr><td>Q×Kᵀ</td><td>相似度计算</td><td>衡量注意力权重</td></tr><tr><td>÷√dₖ</td><td>缩放</td><td>避免梯度过小</td></tr><tr><td>Mask</td><td>屏蔽未来</td><td>自回归建模</td></tr><tr><td>Softmax</td><td>归一化</td><td>得到注意力分布</td></tr><tr><td>×V</td><td>加权求和</td><td>得到输出表示</td></tr><tr><td>多头线性投影</td><td>Multi-head</td><td>捕捉多种关系</td></tr><tr><td>拼接+线性</td><td>输出整合</td><td>保持原始维度</td></tr></tbody></table><p>类比理解Attention和FFN：</p><ul><li>Attention 是你“看别人”（你关注哪些词）；</li><li>FFN 是你“想自己”（你如何加工你自己的信息）；</li><li>两者结合：你先看外界（Attention），再内化处理（FFN）。</li></ul><h1 id="四、训练"><a href="#四、训练" class="headerlink" title="四、训练"></a>四、训练</h1><h2 id="4-1-设备和数据集"><a href="#4-1-设备和数据集" class="headerlink" title="4.1 设备和数据集"></a>4.1 设备和数据集</h2><blockquote><p>在<font color='red'><strong>8 个 NVIDIA P100 GPU</strong></font>设备上对标准的 WMT 2014 英语-德语数据集进行了训练了<font color='red'><strong>3.5天</strong></font>，该数据集包含约 <strong>450</strong> 万个句子对。使用字节对编码对句子进行编码，该编码具有约 <strong>37000</strong> 个词元的共享源目标词汇表。对于英语-法语，使用了更大的 WMT 2014 英语-法语数据集，该数据集包含 <strong>3600</strong> 万个句子，并将词元分成一个包含 <strong>32000</strong> 个词片的词汇表。句子对按近似序列长度分组。每个训练批次包含一组句子对，包含大约 <strong>25000</strong> 个源词元和 <strong>25000</strong> 个目标词元。</p></blockquote><h2 id="4-2-优化"><a href="#4-2-优化" class="headerlink" title="4.2 优化"></a>4.2 优化</h2><ul><li>使用 <strong>Adam 优化器</strong>，其中 $β_1$ &#x3D; 0.9，$β_2$ &#x3D; 0.98，ε &#x3D; $10^{−9}$。我们在训练过程中根据以下公式调整学习率</li></ul><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716192754071.png" alt="优化器公式"></p><ul><li><p><strong>层归一化</strong>：加速训练收敛</p></li><li><p><strong>残差连接</strong>：缓解深层网络梯度消失问题</p></li><li><p><strong>正则：</strong></p><ul><li>Dropout：在每个子层的输出被加到子层输入并归一化之前，对每个子层的输出应用丢弃。此外，还在编码器和解码器堆栈中对嵌入和位置编码的总和应用丢弃</li><li>标签平滑</li><li>BLEU</li></ul></li></ul><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716193312901.png" alt="正则后的结果"></p><h2 id="4-3-结果"><a href="#4-3-结果" class="headerlink" title="4.3 结果"></a>4.3 结果</h2><p>在 WMT 2014 英语-法语翻译任务中，我们的大型模型取得了 41.0 的 BLEU 分数，<font color='red'><strong>超过了所有先前发布的单一模型，而训练成本不到先前最先进模型的四分之一</strong></font>。</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250716193437641.png" alt="transformer 架构的变体"></p><h1 id="五、阅读笔记地址"><a href="#五、阅读笔记地址" class="headerlink" title="五、阅读笔记地址"></a>五、阅读笔记地址</h1><p><strong>我的笔记论文地址：<a href="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/Attention%20Is%20All%20You%20Need.pdf">《Attention is All You Need》</a></strong></p><div class="row">    <embed src="/pdf/transformer.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>自然语言处理</title>
    <link href="/2025/07/09/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/"/>
    <url>/2025/07/09/%E8%87%AA%E7%84%B6%E8%AF%AD%E8%A8%80%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h1 id="一、Transformer"><a href="#一、Transformer" class="headerlink" title="一、Transformer"></a>一、Transformer</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>Transformer是一种深度学习架构，它的核心思想是：</p><blockquote><p>通过注意力机制(Attention)捕捉序列中不同部分之间的关系，而不是像以前的模型(如 RNN)那样一步步按顺序处理。</p></blockquote><p>Transformer 的特点</p><blockquote><ul><li>并行计算：不像 RNN 需要一步步计算，Transformer 可以同时处理所有输入。</li><li>捕捉长距离依赖：通过注意力机制，Transformer 可以轻松捕捉序列中相隔很远的部分之间的关系。</li><li>扩展性强：Transformer 可以堆看很多层，形成超大的模型。</li></ul></blockquote><h2 id="2-架构"><a href="#2-架构" class="headerlink" title="2 架构"></a>2 架构</h2><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250708194608046.png" alt="image-20250708194607829"></p><h3 id="正则化"><a href="#正则化" class="headerlink" title="正则化"></a>正则化</h3><p><strong>在 Transformer 中使用的是 Layer Normalization</strong>，而非 Batch Normalization。</p><blockquote><p>相同点：</p></blockquote><p>两者都属于归一化方法，目的是提升模型训练的稳定性与效率。</p><blockquote><p>区别：</p></blockquote><p>BatchNorm 通常用于计算机视觉领域，对每个通道在 batch 维度上进行归一化，适合定长输入；而 LayerNorm 是对每个样本的特征维度进行归一化，适应性强，不依赖 batch 大小，特别适合 NLP 中的变长输入和 Transformer 架构。</p><h3 id="缩放点积注意力机制"><a href="#缩放点积注意力机制" class="headerlink" title="缩放点积注意力机制"></a>缩放点积注意力机制</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250708201514730.png" alt="image-20250708201514628" style="zoom: 33%;" /><h3 id="多头注意力机制"><a href="#多头注意力机制" class="headerlink" title="多头注意力机制"></a>多头注意力机制</h3><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250708204939021.png"></p><h3 id="Decoder"><a href="#Decoder" class="headerlink" title="Decoder"></a>Decoder</h3><ul><li><p>train的时候并行化</p></li><li><p>Inference的时候仍要序列式完成</p></li><li><p>Self-attention时前词不能见后词</p><ul><li>Mask来实现</li></ul></li></ul><h2 id="2-技术"><a href="#2-技术" class="headerlink" title="2 技术"></a>2 技术</h2><h3 id="word2vec"><a href="#word2vec" class="headerlink" title="word2vec"></a>word2vec</h3><p>优点：快，计算量小，cpu上就能跑<br>缺点：全局信息不足，多义词问题未解决</p>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>关于batch_normlization问题</title>
    <link href="/2025/07/07/%E5%85%B3%E4%BA%8Ebatch-normlization%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <url>/2025/07/07/%E5%85%B3%E4%BA%8Ebatch-normlization%E7%9A%84%E9%97%AE%E9%A2%98/</url>
    
    <content type="html"><![CDATA[<h1 id="一、问题“ValueError-Expected-more-than-1-value-per-channel-when-training-got-input-size-torch-Size-1-1024-”"><a href="#一、问题“ValueError-Expected-more-than-1-value-per-channel-when-training-got-input-size-torch-Size-1-1024-”" class="headerlink" title="一、问题“ValueError: Expected more than 1 value per channel when training, got input size torch.Size([1, 1024])”"></a>一、问题“ValueError: Expected more than 1 value per channel when training, got input size torch.Size([1, 1024])”</h1><p>今天记录一下关于添加batch_normlization的小问题：</p><blockquote><p>ValueError: Expected more than 1 value per channel when training, got input size torch.Size([1, 1024])</p></blockquote><p>首先我是正常的导入包、数据准备、图片增强等等一系列的操作，但是添加到如下代码的时候，在定义train函数的时候就会报错</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250707183159854.png" alt="image-20250707183152768" style="zoom:67%;" /><p>我的训练函数代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">epoches, model, train_loader, test_loader</span>):<br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    running_loss = <span class="hljs-number">0</span><br><br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_loader:<br>        x, y = x.to(device), y.to(device)<br>        <span class="hljs-comment"># 前向传播</span><br>        y_pred = model(x)<br>        <span class="hljs-comment"># 计算损失</span><br>        loss = loss_func(y_pred, y)<br>        <span class="hljs-comment"># 反向传播</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-comment"># argmax() 返回最大值的索引，代表真实预测的类别</span><br>            y_pred = torch.argmax(y_pred, dim=<span class="hljs-number">1</span>)<br>            correct += (y_pred == y).<span class="hljs-built_in">sum</span>().item()<br>            total += y.size(<span class="hljs-number">0</span>)<br>            running_loss += loss.item()<br><br>    lr_scheduler.step()<br>    epoch_loss = running_loss / total<br>    epoch_acc = correct / total<br><br>    <span class="hljs-comment"># 测试过程</span><br>    test_correct = <span class="hljs-number">0</span><br>    test_total = <span class="hljs-number">0</span><br>    test_running_loss = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> test_loader:<br>            x, y = x.to(device), y.to(device)<br>            y_pred = model(x)<br>            loss = loss_func(y_pred, y)<br>            y_pred = torch.argmax(y_pred, dim=<span class="hljs-number">1</span>)<br>            test_correct += (y_pred == y).<span class="hljs-built_in">sum</span>().item()<br>            test_total += y.size(<span class="hljs-number">0</span>)<br>            test_running_loss += loss.item()<br><br>    test_epoch_loss = test_running_loss / test_total<br>    test_epoch_acc = test_correct / test_total<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch: &#123;&#125;, Loss: &#123;:.4f&#125;, Acc: &#123;:.4f&#125;, test_Loss: &#123;:.4f&#125;, test_Acc: &#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(epoches + <span class="hljs-number">1</span>, epoch_loss,<br>                                                                                             epoch_acc,<br>                                                                                             test_epoch_loss,<br>                                                                                             test_epoch_acc))<br>    <span class="hljs-keyword">return</span> epoch_loss, epoch_acc, test_epoch_loss, test_epoch_acc<br><br></code></pre></td></tr></table></figure><p>找了好长时间的错误，发现了如下两种方法：</p><h1 id="二、解决办法"><a href="#二、解决办法" class="headerlink" title="二、解决办法"></a>二、解决办法</h1><h2 id="方法一：drop-last-True"><a href="#方法一：drop-last-True" class="headerlink" title="方法一：drop_last&#x3D;True"></a>方法一：drop_last&#x3D;True</h2><p>有的人说在dataloader中添加drop_last&#x3D;True这个代码</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250707183615283.png" alt="image-20250707183615257"></p><p>这个代码虽然能够解决运行报错的问题，但是在数据量较少的情况下不建议这么使用。因为数据量本身少，然后还要丢弃，那么这个方法训练出来的train_accuracy相当高，而test_accuracy会弱爆了！我就是train_accuracy接近1的程度，而test_accuracy的精度就只有28%、29%那个样子</p><h2 id="方法二：eval"><a href="#方法二：eval" class="headerlink" title="方法二：eval()"></a>方法二：eval()</h2><p>最后实在没辙在chatGPT进行检索回答：</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250707184407586.png" alt="image-20250707184407561"></p><p>然后进行如下代码的改动</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250707184501431.png" alt="image-20250707184501385" style="zoom:67%;" /><p>这个屎山代码就跑起来了：</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250707184540778.png" alt="image-20250707184540746"></p><h1 id="三、反思"><a href="#三、反思" class="headerlink" title="三、反思"></a>三、反思</h1><p>在 PyTorch 中，<code>BatchNorm</code> 层（如 <code>BatchNorm1d</code> 和 <code>BatchNorm2d</code>）有两种工作模式：</p><table><thead><tr><th>模式</th><th>均值 &#x2F; 方差来源</th><th>行为说明</th></tr></thead><tbody><tr><td><code>train()</code></td><td>当前 batch 的统计量</td><td><strong>必须 batch size ≥ 2</strong>，否则无法计算方差（除以 n-1）</td></tr><tr><td><code>eval()</code></td><td>训练期间积累的均值和方差（moving average）</td><td>不再依赖 batch，<strong>即使 batch size &#x3D; 1 也能用</strong></td></tr></tbody></table><h3 id="⚠️-错误原因详解："><a href="#⚠️-错误原因详解：" class="headerlink" title="⚠️ 错误原因详解："></a>⚠️ 错误原因详解：</h3><p>遇到的错误：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">ValueError</span>: Expected more than <span class="hljs-number">1</span> value per channel when training, got input size torch.Size([<span class="hljs-number">1</span>, <span class="hljs-number">1024</span>])<br></code></pre></td></tr></table></figure><p>意味着在 <strong>训练模式（model.train()）</strong> 下运行，并输入了 <strong>batch size &#x3D; 1</strong> 的数据。</p><p>这时 BatchNorm 会尝试用该单一样本的值来计算方差，但方差的计算公式为：</p><p>$Var(x) &#x3D; \frac{1}{N - 1} \sum_{i&#x3D;1}^{N}(x_i - \bar{x})^2$</p><p>当 <code>N=1</code>（也就是只有一个样本时），公式除以 <code>N - 1 = 0</code>，因此引发错误。</p><h3 id="✅-为什么-eval-就没问题了？"><a href="#✅-为什么-eval-就没问题了？" class="headerlink" title="✅ 为什么 eval() 就没问题了？"></a>✅ 为什么 <code>eval()</code> 就没问题了？</h3><p>当使用：</p><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autoit">model.<span class="hljs-built_in">eval</span>()<br></code></pre></td></tr></table></figure><p>此时 <code>BatchNorm</code> 不再试图用当前 batch 计算均值和方差，而是使用训练阶段累计的 <strong>滑动平均均值与方差</strong>（moving mean &amp; var），所以不管你输入 1 张图还是 100 张图，它都能运行。</p>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>BUG</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大模型应用开发</title>
    <link href="/2025/06/28/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/"/>
    <url>/2025/06/28/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E5%BA%94%E7%94%A8%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h1 id="一、相关概念"><a href="#一、相关概念" class="headerlink" title="一、相关概念"></a>一、相关概念</h1><h2 id="1-历史背景"><a href="#1-历史背景" class="headerlink" title="1 历史背景"></a>1 历史背景</h2><blockquote><p><strong>传统AI</strong>：机器学习、深度学习、强化学习</p></blockquote><p><font color='red'><strong>2017年提出的Transformer架构，奠定了大模型领域主流算法架构的基石</strong></font></p><blockquote><p><strong>大模型时代</strong>：神经网络、自注意力机制、Transformer</p></blockquote><p>两者之间的区别：</p><ul><li>模型结构和算法</li><li><strong>灵活性和可扩展性</strong></li><li>数据规模和多样性</li><li><strong>任务范围和性能方面</strong></li><li>计算资源和成本</li></ul><h2 id="2-什么是AI大模型"><a href="#2-什么是AI大模型" class="headerlink" title="2 什么是AI大模型"></a>2 什么是AI大模型</h2><blockquote><p><strong>大语言模型（英文:Large Language Model，缩写LLM）</strong></p></blockquote><p>概念：大型语言模型（LLM）之所以大，是指具有大规模参数和复杂计算结构（超过 10 亿个参数），LLM通常基于 Transformer 模型架构，由深度神经网络构建，对海量数据进行预训练处理。</p><blockquote><p> LLM的特点：</p></blockquote><ul><li>LLM的特点是规模庞大，包含数十亿的参数，（GPT-3有1750亿个参数）</li><li>LLM是在大量文本数据集(如书籍、网站或用户生成内容)上进行训练的。</li></ul><blockquote><p>模型组成</p></blockquote><ul><li><p><font color='red'><strong>数据</strong></font>（最重要！）</p></li><li><p>模型设计（Transform架构、传统架构——RNN、LSTM）</p></li><li><p>模型训练（微调、强化学习、Deepseed）</p></li><li><p>BenchMark：评测</p></li><li><p>Memory（知识图谱、向量数据库）</p></li><li><p>搜索技术</p></li><li><p>RAG</p></li></ul><h2 id="3-大模型分类"><a href="#3-大模型分类" class="headerlink" title="3 大模型分类"></a>3 大模型分类</h2><p>按照<strong>输入数据类型</strong>的不同，大模型主要可以分为以下三大类：</p><ul><li>语言大模型：是指在自然语言处理(Natural Language Processing，NLP)领域中的一类大模型，通常用于处理文本数据和理解自然语言。</li><li>视觉大模型：是指在计算机视觉(Computer Vision，CV)领域中使用的大模型通常用于图像处理和分析。资源代找 网课代下+V备用:</li><li>多模态大模型：是指能够处理多种不同类型数据的大模型，例如文本、图像、音频等多模态数据。这类模型结合了NLP和CV的能力。</li></ul><h2 id="4-现有模型"><a href="#4-现有模型" class="headerlink" title="4 现有模型"></a>4 现有模型</h2><p>当前比较好的、令人瞩目的AI产品：</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">LLaMA3</span>(✳)：开源<br><br><span class="hljs-attribute">controlNet</span>：他的成果奠定了AI能局部修改<br><br><span class="hljs-attribute">Alpaca</span>：开源，在LLaMA的基础上进行微调，奠定了微调的基石<br><br><span class="hljs-attribute">Vicuna</span> <span class="hljs-number">13</span>B：开源，非常值得看源码<br><br><span class="hljs-attribute">Mistral</span> <span class="hljs-number">7</span>B：开源<br><br><span class="hljs-attribute">Yi_34B</span>：开源<br><br><span class="hljs-attribute">Qwen</span><br><br><span class="hljs-attribute">deepseek</span> <br><br><span class="hljs-attribute">GLM</span>-<span class="hljs-number">4</span>（新一代基座大模型）<br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250703164816821.png" alt="image-20250703155633419"></p><h1 id="二、专有名词"><a href="#二、专有名词" class="headerlink" title="二、专有名词"></a>二、专有名词</h1><h2 id="1-普通名词"><a href="#1-普通名词" class="headerlink" title="1 普通名词"></a>1 普通名词</h2><p><strong>RAG（Retrieval-Augmented Generation，检索增强生成）</strong> ：是一种 AI 框架，它将传统信息检索系统（例如数据库）的优势与生成式大语言模型 (LLM) 的功能结合在一起。</p><p><strong>TopN</strong>：相似度最高的前N个</p><p>**AIGC（AI Generated Content，AI生成内容）：**利用AI技术生成内容，例如文本、图像、音频、视频等</p><p><strong>AGI（Artificial General Intelligence，通用人工智能）</strong>：像人类一样思考、学习、执行多种任务的系统</p><h2 id="2-开发名词"><a href="#2-开发名词" class="headerlink" title="2 开发名词"></a>2 开发名词</h2><p><strong>Prompt：</strong></p><blockquote><p>要让ChatGPT干活,你得把要干什么活(Prompt)告诉ChatGPT</p></blockquote><p><strong>Prompt Engieering：</strong></p><blockquote><p>通过开发和优化提示词(Prompt)，帮助大语言模型应用于各个场景，并且工作的专业，准确。</p></blockquote><p><strong>temperature：</strong></p><blockquote><p>可以增加模型输出的随机性，增加 temperature 可以增加模型输出的随机性，从而提高了回复的多样性，但降低了质量。</p></blockquote><p>**Top P **：</p><blockquote><p>控制多样性，<strong>值越小</strong>，生成结果越保守；越大，结果越多样。</p></blockquote><p><strong>Frequency_penalty：</strong></p><blockquote><p>控制生成文本中单词或短语的整体频率。<strong>值越高</strong>，模型更倾向于生成包含低频词汇和短语的文本，以增加文本的多样性。<strong>较低</strong>，模型可能更倾向于生成包含高频词汇和短语的女小</p></blockquote><p><strong>presence_penalty：</strong></p><blockquote><p>控制生成文本中特定单词或短语的存在频率。<strong>较高</strong>，会模型更倾向于在生成的文本中包含多样性更大的单词和短语，减少重复性。<strong>较低的presence_penalty</strong>模型可能更倾向于生成包含和输入相近的文本重复性</p></blockquote><p>**零样本思维链：**lets think step by step</p><p><strong>自治性(Self-consistency)：</strong></p><blockquote><p>是对 CoT|CoT prompting的一个补充，它不仅仅生成一个思路链，而是生成多个思路链，然后取多数答案作为最终答案。例如给出三种推理过程，将结果少数服从多数。</p></blockquote><p><strong>思维树(ToT:Tree-of-Thought)：</strong></p><blockquote><p>是一种新的语言模型推理方法允许对连贯文本单元“思想”进行探索，这些单元作为解决问题的中间步骤。T<strong>oT将任何问题框定为在树上搜索，其中每个节点都是一个状态，由文本输入和语言模型生成的一系列思想组成</strong>。ToT允许语言模型通过考虑**多个不同的推理路径和自我评估选择来进行有意识的决策，**并在必要时向前或后跟踪以做出全局选择</p></blockquote><h1 id="三、HuggingFace"><a href="#三、HuggingFace" class="headerlink" title="三、HuggingFace"></a>三、HuggingFace</h1><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><blockquote><p>pip install transformers</p><p>pip install datasets</p></blockquote><h2 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2 基本使用"></a>2 基本使用</h2><h3 id="2-1-编码器"><a href="#2-1-编码器" class="headerlink" title="2.1 编码器"></a>2.1 编码器</h3><p>1 自定义编码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">sentence = <span class="hljs-string">&#x27;hello everyone , today is a good day .&#x27;</span><br><br>vocab = &#123;<br>    <span class="hljs-string">&#x27;&lt;SOS&gt;&#x27;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&#x27;&lt;EOS&gt;&#x27;</span>: <span class="hljs-number">1</span>,<br>    <span class="hljs-string">&#x27;hello&#x27;</span>: <span class="hljs-number">2</span>,<br>    <span class="hljs-string">&#x27;everyone&#x27;</span>: <span class="hljs-number">3</span>,<br>    <span class="hljs-string">&#x27;today&#x27;</span>: <span class="hljs-number">4</span>,<br>    <span class="hljs-string">&#x27;is&#x27;</span>: <span class="hljs-number">5</span>,<br>    <span class="hljs-string">&#x27;a&#x27;</span>: <span class="hljs-number">6</span>,<br>    <span class="hljs-string">&#x27;good&#x27;</span>: <span class="hljs-number">7</span>,<br>    <span class="hljs-string">&#x27;day&#x27;</span>: <span class="hljs-number">8</span>,<br>    <span class="hljs-string">&#x27;,&#x27;</span>: <span class="hljs-number">9</span>,<br>    <span class="hljs-string">&#x27;.&#x27;</span>: <span class="hljs-number">10</span><br>&#125;<br><br>new_sentence = <span class="hljs-string">&#x27;&lt;SOS&gt; &#x27;</span> + sentence + <span class="hljs-string">&#x27; &lt;EOS&gt;&#x27;</span><br><span class="hljs-built_in">print</span>(new_sentence)<br><span class="hljs-comment"># 英文分词比较简单，直接按照空格区分即可</span><br><span class="hljs-comment"># 中文分次使用分词工具，比如jieba分词</span><br>words = new_sentence.split()<br>words<br><br>[vocab[i] <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> words]<br></code></pre></td></tr></table></figure><p>2 使用编码器工具</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型和他的编码器是成对使用的，使用什么模型，就用它提供的编码器</span><br><span class="hljs-comment"># 编码器的名字和一般和模型的名字一致</span><br><span class="hljs-comment"># 比如，使用GPT2模型，就用GPT2Tokenizer</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer<br><br>tokenizer = BertTokenizer.from_pretrained(<br>    pretrained_model_name_or_path=<span class="hljs-string">&#x27;bert-base-chinese&#x27;</span>,<br>    cache_dir=<span class="hljs-string">&#x27;../runs/cache&#x27;</span>,<br>    force_download=<span class="hljs-literal">False</span><br>)<br><br>sents = [<br>    <span class="hljs-string">&#x27;你站在桥上看风景&#x27;</span>,<br>    <span class="hljs-string">&#x27;看风景的人在楼上看你&#x27;</span>,<br>    <span class="hljs-string">&#x27;明月装饰了你的窗子&#x27;</span>,<br>    <span class="hljs-string">&#x27;你装饰了别人的梦&#x27;</span><br>]<br><br><span class="hljs-comment"># 基本的编码函数</span><br>out = tokenizer.encode(<br>    text=sents[<span class="hljs-number">0</span>],<br>    text_pair=sents[<span class="hljs-number">1</span>],<br>    truncation=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 句子太长是否截断</span><br>    padding=<span class="hljs-string">&#x27;max_length&#x27;</span>,<br>    add_special_tokens=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否添加特殊符号，知道句子的起始</span><br>    max_length=<span class="hljs-number">25</span>,<br>    return_tensors=<span class="hljs-literal">None</span><br>)<br><span class="hljs-built_in">print</span>(out)<br><br>tokenizer.decode(out)<br></code></pre></td></tr></table></figure><p>进阶版：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 进阶版函数</span><br>out = tokenizer.encode_plus(<br>    text=sents[<span class="hljs-number">0</span>],<br>    text_pair=sents[<span class="hljs-number">1</span>],<br>    <span class="hljs-comment"># 如果要对单句子编码，batch_text_or_text_pairs=[sents[0], sents[1], sents[2], sents[3]]</span><br>    <span class="hljs-comment"># batch_text_or_text_pairs=[(sents[0], sents[1]), (sents[2], sents[3])],  # 一次编码多个句子对</span><br>    <span class="hljs-comment"># 句子太长是否截断</span><br>    truncation=<span class="hljs-literal">True</span>,<br>    padding=<span class="hljs-string">&#x27;max_length&#x27;</span>,<br>    <span class="hljs-comment"># 是否添加特殊符号，知道句子的起始</span><br>    add_special_tokens=<span class="hljs-literal">True</span>,<br>    max_length=<span class="hljs-number">25</span>,<br>    <span class="hljs-comment"># 返回的数据类型，默认返回列表，可以返回Tensorflow，pytorch的tensor</span><br>    return_tensors=<span class="hljs-literal">None</span>,<br>    <span class="hljs-comment"># 0，1 表示是哪个句子的数据</span><br>    return_token_type_ids=<span class="hljs-literal">True</span>,<br>    <span class="hljs-comment"># 有用的部分标1，pad部分标0</span><br>    return_attention_mask=<span class="hljs-literal">True</span>,<br>    <span class="hljs-comment"># 特殊字符标1，其他位置标0</span><br>    return_special_tokens_mask=<span class="hljs-literal">True</span>,<br>    <span class="hljs-comment"># 返回编码后的句子长度</span><br>    return_length=<span class="hljs-literal">True</span><br>)<br><span class="hljs-comment">#%%</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> out.items():<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&#x27;:&#x27;</span>, v)<br></code></pre></td></tr></table></figure><p>自定义新词：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 自定义新的词语</span><br>tokenizer.add_tokens(new_tokens=[<span class="hljs-string">&#x27;明月&#x27;</span>, <span class="hljs-string">&#x27;装饰&#x27;</span>, <span class="hljs-string">&#x27;你的&#x27;</span>, <span class="hljs-string">&#x27;窗子&#x27;</span>])<br><br><span class="hljs-comment"># 自定义新的字符</span><br>tokenizer.add_special_tokens(&#123;<span class="hljs-string">&#x27;eos_token&#x27;</span>: <span class="hljs-string">&#x27;[EOS]&#x27;</span>&#125;)<br><br><span class="hljs-keyword">for</span> word <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;明月&#x27;</span>, <span class="hljs-string">&#x27;装饰&#x27;</span>, <span class="hljs-string">&#x27;你的&#x27;</span>, <span class="hljs-string">&#x27;窗子&#x27;</span>, <span class="hljs-string">&#x27;[EOS]&#x27;</span>]:<br>    <span class="hljs-built_in">print</span>(tokenizer.get_vocab()[word])<br>    <br>out = tokenizer.encode(<br>    text=<span class="hljs-string">&#x27;明月装饰了你的窗子[EOS]&#x27;</span>,<br>    text_pair=<span class="hljs-literal">None</span>,<br>    truncation=<span class="hljs-literal">True</span>,<br>    padding=<span class="hljs-string">&#x27;max_length&#x27;</span>,<br>    add_special_tokens=<span class="hljs-literal">True</span>,<br>    max_length=<span class="hljs-number">10</span>,<br>    return_tensors=<span class="hljs-literal">None</span><br>)<br><span class="hljs-built_in">print</span>(out)<br><br>tokenizer.decode(out)<br></code></pre></td></tr></table></figure><h3 id="2-2-数据集操作"><a href="#2-2-数据集操作" class="headerlink" title="2.2 数据集操作"></a>2.2 数据集操作</h3><p>一般数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset<br><br>dataset = load_dataset(<br>    path=<span class="hljs-string">&#x27;lansinuote/ChnSentiCorp&#x27;</span>,<br>    cache_dir=<span class="hljs-string">&#x27;../runs/cache&#x27;</span>,<br>)<br>dataset<br></code></pre></td></tr></table></figure><p>大的数据集下加载小的数据集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 加载大的数据集中的数据子集</span><br>sst2 = load_dataset(<br>    path=<span class="hljs-string">&#x27;glue&#x27;</span>,<br>    name=<span class="hljs-string">&#x27;sst2&#x27;</span>,<br>    split=<span class="hljs-string">&#x27;train&#x27;</span>,<br>    cache_dir=<span class="hljs-string">&#x27;../runs/cache&#x27;</span><br>)<br>sst2<br></code></pre></td></tr></table></figure><p>基本操作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python">dataset = dataset[<span class="hljs-string">&#x27;train&#x27;</span>]<br><span class="hljs-built_in">print</span>(train)<br><br><span class="hljs-comment"># 排序</span><br>sort_dataset = dataset.sort(<span class="hljs-string">&#x27;label&#x27;</span>)<br><br><span class="hljs-comment"># 随机打乱</span><br>shuffle_dataset = sort_dataset.shuffle(seed=<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 数据的抽样，间隔10个数据提取一次</span><br>select_dataset = dataset.select([i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">0</span>, <span class="hljs-number">51</span>, <span class="hljs-number">10</span>)])<br><span class="hljs-built_in">print</span>(select_dataset)<br><br><br><span class="hljs-comment"># 数据过滤</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">data</span>):<br>    <span class="hljs-keyword">return</span> data[<span class="hljs-string">&#x27;text&#x27;</span>].startswith(<span class="hljs-string">&#x27;非常不错&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(dataset.<span class="hljs-built_in">filter</span>(func))<br><br><span class="hljs-comment"># 数据拆分</span><br><span class="hljs-built_in">print</span>(dataset.train_test_split(test_size=<span class="hljs-number">0.1</span>))<br><br><span class="hljs-comment"># 数据分桶</span><br><span class="hljs-built_in">print</span>(dataset.shard(num_shards=<span class="hljs-number">10</span>, index=<span class="hljs-number">0</span>))<br><br><span class="hljs-comment"># 重命名字段</span><br><span class="hljs-built_in">print</span>(dataset.rename_column(<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-string">&#x27;text_name&#x27;</span>))<br><span class="hljs-built_in">print</span>(train)<br><br><span class="hljs-comment"># 删除字段</span><br>remove_dataset = dataset.remove_columns([<span class="hljs-string">&#x27;label&#x27;</span>])<br><span class="hljs-built_in">print</span>(remove_dataset)<br><br><span class="hljs-comment"># 映射函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">add_prefix</span>(<span class="hljs-params">data</span>):<br>    data[<span class="hljs-string">&#x27;text&#x27;</span>] = <span class="hljs-string">&#x27;sentences: &#x27;</span> + data[<span class="hljs-string">&#x27;text&#x27;</span>]<br>    <span class="hljs-keyword">return</span> data<br><br>map_dataset = dataset.<span class="hljs-built_in">map</span>(function=add_prefix)<br><span class="hljs-built_in">print</span>(map_dataset[<span class="hljs-string">&#x27;text&#x27;</span>][:<span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 批处理加速</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">batch_speed</span>(<span class="hljs-params">data</span>):<br>    text = data[<span class="hljs-string">&#x27;text&#x27;</span>]<br>    text = [<span class="hljs-string">&#x27;sentences:&#x27;</span> + i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> text]<br>    data[<span class="hljs-string">&#x27;text&#x27;</span>] = text<br>    <span class="hljs-keyword">return</span> data<br><br>batch_map = dataset.<span class="hljs-built_in">map</span>(<br>    function=batch_speed,<br>    batched=<span class="hljs-literal">True</span>,<br>    batch_size=<span class="hljs-number">1000</span>,<br>    num_proc=<span class="hljs-number">4</span><br>)<br><br><span class="hljs-built_in">print</span>(batch_map[<span class="hljs-string">&#x27;text&#x27;</span>][<span class="hljs-number">0</span>])<br><span class="hljs-built_in">print</span>(dataset[<span class="hljs-string">&#x27;text&#x27;</span>][<span class="hljs-number">0</span>])<br><br><span class="hljs-comment"># 设置数据格式，默认是numpy，会修改原始数据</span><br>dataset.set_format(<span class="hljs-built_in">type</span>=<span class="hljs-string">&#x27;torch&#x27;</span>, columns=[<span class="hljs-string">&#x27;label&#x27;</span>], output_all_columns=<span class="hljs-literal">True</span>)<br><br>dataset[<span class="hljs-number">20</span>]<br></code></pre></td></tr></table></figure><p>文件保存：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 保存为csv，并加载</span><br>dataset.to_csv(path_or_buf=<span class="hljs-string">&#x27;./ChnSentiCorp.csv&#x27;</span>)<br><br>csv_dataset = load_dataset(path=<span class="hljs-string">&#x27;csv&#x27;</span>, data_files=<span class="hljs-string">&#x27;./ChnSentiCorp.csv&#x27;</span>, split=<span class="hljs-string">&#x27;train&#x27;</span>)<br>csv_dataset<br><br><span class="hljs-comment"># 保存为json，并加载</span><br><span class="hljs-comment"># 保存为json</span><br>dataset.to_json(path_or_buf=<span class="hljs-string">&#x27;./ChnSentiCorp.json&#x27;</span>)<br><span class="hljs-comment">#%%</span><br>json_dataset = load_dataset(path=<span class="hljs-string">&#x27;json&#x27;</span>, data_files=<span class="hljs-string">&#x27;./ChnSentiCorp.json&#x27;</span>, split=<span class="hljs-string">&#x27;train&#x27;</span>)<br>json_dataset<br></code></pre></td></tr></table></figure><h3 id="2-3-模型评估"><a href="#2-3-模型评估" class="headerlink" title="2.3 模型评估"></a>2.3 模型评估</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span>  evaluate <span class="hljs-keyword">import</span> *<br>acc = load(<span class="hljs-string">&quot;accuracy&quot;</span>)<br><br>metric = load(path=<span class="hljs-string">&#x27;glue&#x27;</span>, config_name=<span class="hljs-string">&#x27;mrpc&#x27;</span>, cache_dir=<span class="hljs-string">&#x27;../runs/cache&#x27;</span>)<br><br>metric<br></code></pre></td></tr></table></figure><h1 id="四、Langchain框架"><a href="#四、Langchain框架" class="headerlink" title="四、Langchain框架"></a>四、Langchain框架</h1><h2 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h2><p>LangChain是一个用于开发由大型语言模型(LLMS) 驱动的应用程序的框架。</p><p>LangChain 简化了 LLM 应用程序生命周期的每个阶段：</p><ul><li>开发：使用 LangChàin 的开源<font color='red'><strong>构建模块、组件</strong></font>和<font color='red'><strong>第三方集成</strong></font>构建您的应用程序。使用LangGraph构建具有一流流式处理和人机协作支持的有状态代理。</li><li>生产化：使用<font color='red'><strong>LangSmith</strong></font>检查、监控和评估您的链，以便您可以持续优化并自信地部署</li><li>部署：将您的<font color='red'><strong>LangGraph</strong></font>应用程序转变为生产就绪的 API 和助手，使用<font color='red'><strong>LangGraph Cloud</strong></font>。</li></ul><h2 id="2-组成"><a href="#2-组成" class="headerlink" title="2 组成"></a>2 组成</h2><p>Langchain框架由以下开源库组成：</p><ul><li><font color='red'><strong>langchain-core：</strong></font>基础抽象和LangChain表达式(LCEL，LangChain Expression Language)。</li><li>**langchain-community：**第三方集成。</li><li>合作伙伴库(例如 langchain-openai、langchain-anthropic 等)：一些集成已进一步拆分为自己的轻量级库，仅依赖于langchain-core。</li><li>langchain：组成应用程序认知架构的链、代理和检索策略。</li><li><font color='red'><strong>LangGraph：</strong></font> 通过将步骤建模为图中的边和节点，构建强大且有状态的多参与者应用程序。与LangChain无缝集成，但也可以单独使用。</li><li>LangServe：将LangChain链部署为REST API。</li><li>LangSmith：一个开发者平台，让您调试、测试、评估和监控LLM应用程序。</li></ul><h2 id="3-demo"><a href="#3-demo" class="headerlink" title="3 demo"></a>3 demo</h2><h3 id="3-1-demo1记忆"><a href="#3-1-demo1记忆" class="headerlink" title="3.1 demo1记忆"></a>3.1 demo1记忆</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_community.chat_message_histories <span class="hljs-keyword">import</span> SQLChatMessageHistory<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate, MessagesPlaceholder<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnableWithMessageHistory<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> SecretStr<br><br>llm_openai = ChatOpenAI(<br>    <span class="hljs-comment"># 你的key</span><br>    base_url=<span class="hljs-string">&#x27;https://api.openai.com/v1&#x27;</span>,<br>    model=<span class="hljs-string">&#x27;gpt-4o-mini&#x27;</span>,<br>    temperature=<span class="hljs-number">1.0</span><br>)<br><br><span class="hljs-comment"># 解析器，帮我们把返回的响应对象，解析成一个字符串</span><br>parser = StrOutputParser()<br><br><span class="hljs-comment"># prompt</span><br>prompt = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&#x27;system&#x27;</span>, <span class="hljs-string">&#x27;你是一个幽默的聊天机器人。&#x27;</span>),<br>    <span class="hljs-comment"># 上下文记忆</span><br>    MessagesPlaceholder(variable_name=<span class="hljs-string">&#x27;history&#x27;</span>),<br>    (<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;&#123;input&#125;&#x27;</span>)<br>])<br><br><span class="hljs-comment"># LCEL表达式</span><br>chain = prompt | llm_openai | parser<br><br><br><span class="hljs-comment"># 上下文交互：保存历史记录(存在哪里？内存不能保存，需要持久化)</span><br><span class="hljs-comment"># 把聊天记录保存到本地数据库中</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_session_history</span>(<span class="hljs-params">sid</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    根据会话的ID，读取和保存历史记录，必须返回BaseChatMessageHistory</span><br><span class="hljs-string">    :param sid:</span><br><span class="hljs-string">    :return:</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-keyword">return</span> SQLChatMessageHistory(sid, connection=<span class="hljs-string">&#x27;sqlite:///history.db&#x27;</span>)<br><br><br>runnable = RunnableWithMessageHistory(<br>    chain,<br>    get_session_history,<br>    input_messages_key=<span class="hljs-string">&#x27;input&#x27;</span>,<br>    history_messages_key=<span class="hljs-string">&#x27;history&#x27;</span><br>)<br><br>resp1 =runnable.invoke(<br>    &#123;<span class="hljs-string">&#x27;input&#x27;</span>: <span class="hljs-string">&#x27;中国一共有哪些直辖市&#x27;</span>&#125;,<br>    config=&#123;<span class="hljs-string">&#x27;configurable&#x27;</span>: &#123;<span class="hljs-string">&#x27;session_id&#x27;</span>: <span class="hljs-string">&#x27;no.1&#x27;</span>&#125;&#125;)<br><span class="hljs-built_in">print</span>(resp1)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--&#x27;</span> * <span class="hljs-number">30</span>)<br><br>resp2 =runnable.invoke(<br>    &#123;<span class="hljs-string">&#x27;input&#x27;</span>: <span class="hljs-string">&#x27;这些城市中哪个最大？&#x27;</span>&#125;,<br>    config=&#123;<span class="hljs-string">&#x27;configurable&#x27;</span>: &#123;<span class="hljs-string">&#x27;session_id&#x27;</span>: <span class="hljs-string">&#x27;no.1&#x27;</span>&#125;&#125;)<br><span class="hljs-built_in">print</span>(resp2)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;--&#x27;</span> * <span class="hljs-number">30</span>)<br></code></pre></td></tr></table></figure><h3 id="3-2-链式调用"><a href="#3-2-链式调用" class="headerlink" title="3.2 链式调用"></a>3.2 链式调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnableLambda<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> SecretStr<br><br>llm = ChatOpenAI(<br>    temperature=<span class="hljs-number">0.5</span>,<br>    <span class="hljs-comment"># 你的key</span><br>    base_url=<span class="hljs-string">&#x27;https://open.bigmodel.cn/api/paas/v4/&#x27;</span>,<br>    model=<span class="hljs-string">&#x27;glm-4&#x27;</span><br>)<br><br>prompt_template1 = PromptTemplate.from_template(<span class="hljs-string">&#x27;给我写一篇关于&#123;key_word&#125;的&#123;type&#125;，字数不得超过&#123;count&#125;字。&#x27;</span>)<br>prompt_template2 = PromptTemplate.from_template(<span class="hljs-string">&#x27;如果满分是10分，请评价一下这篇文章并给短文打分：&#123;text_content&#125;。&#x27;</span>)<br><br><span class="hljs-comment"># 第一个需求</span><br>chain1 = prompt_template1 | llm | StrOutputParser()<br><br><br><span class="hljs-comment"># chain2 = &#123;&#x27;text_content&#x27;: chain1&#125; | prompt_template2 | llm | StrOutputParser()</span><br><br><br><span class="hljs-comment"># 如果想看到chain1中写出来的文章，以下进行改造</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">print_chain1</span>(<span class="hljs-params">text_content</span>):<br>    <span class="hljs-built_in">print</span>(text_content)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;---&#x27;</span> * <span class="hljs-number">30</span>)<br>    <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&#x27;text_content&#x27;</span>: text_content&#125;<br><br><br>chain2 = chain1 | RunnableLambda(print_chain1) | prompt_template2 | llm | StrOutputParser()<br><br><span class="hljs-built_in">print</span>(chain2.invoke(&#123;<br>    <span class="hljs-string">&#x27;key_word&#x27;</span>: <span class="hljs-string">&#x27;青春&#x27;</span>,<br>    <span class="hljs-string">&#x27;type&#x27;</span>: <span class="hljs-string">&#x27;散文&#x27;</span>,<br>    <span class="hljs-string">&#x27;count&#x27;</span>: <span class="hljs-number">400</span><br>&#125;))<br></code></pre></td></tr></table></figure><h3 id="3-3-订餐demo"><a href="#3-3-订餐demo" class="headerlink" title="3.3 订餐demo"></a>3.3 订餐demo</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnableLambda<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> SecretStr<br><br>llm = ChatOpenAI(<br>    temperature=<span class="hljs-number">0.5</span>,<br>    <span class="hljs-comment"># 你的key</span><br>    base_url=<span class="hljs-string">&#x27;https://api.deepseek.com&#x27;</span>,<br>    model=<span class="hljs-string">&#x27;deepseek-chat&#x27;</span><br>)<br><br><span class="hljs-comment"># 用户输入需求</span><br>gather_preferences_prompt = PromptTemplate.from_template(<span class="hljs-string">&#x27;用户输入了一些餐厅偏好：&#123;input_text1&#125;\n&#x27;</span><br>                                                         <span class="hljs-string">&#x27;请将用户的偏好总结为清晰的需求：&#x27;</span>)<br><br><span class="hljs-comment"># 根据需求推荐餐厅</span><br>recommend_restaurant_prompt = PromptTemplate.from_template(<span class="hljs-string">&#x27;请根据用户的需求:&#123;input_text2&#125;\n，&#x27;</span><br>                                                           <span class="hljs-string">&#x27;请推荐3家合适的餐厅，并说明推荐理由：&#x27;</span>)<br><br><span class="hljs-comment"># 总结推荐内容供用户快速参考</span><br>summarize_preferences_prompt = PromptTemplate.from_template(<span class="hljs-string">&#x27;以下是餐厅推荐和推荐理由：\n&#123;input_text3&#125;\n&#x27;</span><br>                                                            <span class="hljs-string">&#x27;请总结成 2-3 句话，供用户快速参考：&#x27;</span>)<br><br>chain = (gather_preferences_prompt | llm |<br>         recommend_restaurant_prompt | llm |<br>         summarize_preferences_prompt | llm |<br>         StrOutputParser())<br><br><span class="hljs-built_in">print</span>(chain.invoke(&#123;<br>    <span class="hljs-string">&#x27;input_text1&#x27;</span>: <span class="hljs-string">&#x27;我喜欢安静的地方，不喜欢人多的地方，价格不贵，环境好，有包间，有停车位&#x27;</span>&#125;))<br><br></code></pre></td></tr></table></figure><h3 id="3-4-动态路由调用"><a href="#3-4-动态路由调用" class="headerlink" title="3.4 动态路由调用"></a>3.4 动态路由调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser, JsonOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate, ChatPromptTemplate<br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnableLambda, RouterRunnable, RunnableSequence<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> pydantic <span class="hljs-keyword">import</span> SecretStr<br><br><span class="hljs-comment"># 需求：用户会问到各种领域（物理、化学、计算机等等）的问题，根据不同领域，定义不同的提示词模板。动态的选择合适的任务模板去开发。</span><br>llm = ChatOpenAI(<br>    temperature=<span class="hljs-number">0</span>,<br>    <span class="hljs-comment"># 你的key</span><br>    base_url=<span class="hljs-string">&#x27;https://api.deepseek.com&#x27;</span>,<br>    model=<span class="hljs-string">&#x27;deepseek-chat&#x27;</span><br>)<br><br><span class="hljs-comment"># 定义物理任务模板</span><br>physics_template = ChatPromptTemplate.from_template(<br>    <span class="hljs-string">&#x27;你是一位物理学教授，稍长用简洁易懂的方式回答物理问题。以下是问题内容：&#123;input&#125;&#x27;</span><br>)<br><br><span class="hljs-comment"># 定义数学任务模板</span><br>math_template = ChatPromptTemplate.from_template(<br>    <span class="hljs-string">&#x27;你是一位数学教授，擅长分步骤解决数学问题，并提供详细的解决过程。以下是问题的内容：&#123;input&#125;&#x27;</span><br>)<br><br><span class="hljs-comment"># 定义历史任务模板</span><br>history_template = ChatPromptTemplate.from_template(<br>    <span class="hljs-string">&#x27;你是一位历史教授，对历史事件和背景有深入研究。以下是问题的内容：&#123;input&#125;&#x27;</span><br>)<br><br><span class="hljs-comment"># 定义计算机科学模板</span><br>computer_science_template = ChatPromptTemplate.from_template(<br>    <span class="hljs-string">&#x27;你是一位计算机科学专家，擅长算法、数据结构和编程问题。以下是问题的内容：&#123;input&#125;&#x27;</span><br>)<br><br><span class="hljs-comment"># 默认模板</span><br>default_template = ChatPromptTemplate.from_template(<br>    <span class="hljs-string">&quot;你是一位专家，请你用简洁易懂的方式回答问题。以下是问题的内容：&#123;input&#125;&quot;</span><br>)<br><br><span class="hljs-comment"># 定义输出解析器</span><br>default_chain = default_template | llm<br>physics_chain = physics_template | llm<br>math_chain = math_template | llm<br>history_chain = history_template | llm<br>computer_science_chain = computer_science_template | llm<br><br><br><span class="hljs-comment"># 动态路由的chain</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">route</span>(<span class="hljs-params"><span class="hljs-built_in">input</span></span>):<br>    <span class="hljs-keyword">if</span> <span class="hljs-string">&quot;物理&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;type&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;物理mode&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;physics&quot;</span>, <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;input&quot;</span>]&#125;<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;数学&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;type&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数学mode&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;math&quot;</span>, <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;input&quot;</span>]&#125;<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;历史&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;type&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;历史mode&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;history&quot;</span>, <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;input&quot;</span>]&#125;<br>    <span class="hljs-keyword">elif</span> <span class="hljs-string">&quot;计算机&quot;</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;type&quot;</span>]:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;计算机mode&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;computer_science&quot;</span>, <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;input&quot;</span>]&#125;<br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;default mode&quot;</span>)<br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;key&quot;</span>: <span class="hljs-string">&quot;default&quot;</span>, <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-built_in">input</span>[<span class="hljs-string">&quot;input&quot;</span>]&#125;<br><br><br><span class="hljs-comment"># 创建一个路由节点</span><br>route_runnable = RunnableLambda(route)<br><br><span class="hljs-comment"># 路由调度器</span><br>router = RouterRunnable(runnables=&#123;<br>    <span class="hljs-string">&quot;physics&quot;</span>: physics_chain,<br>    <span class="hljs-string">&quot;math&quot;</span>: math_chain,<br>    <span class="hljs-string">&quot;history&quot;</span>: history_chain,<br>    <span class="hljs-string">&quot;computer_science&quot;</span>: computer_science_chain,<br>    <span class="hljs-string">&quot;default&quot;</span>: default_chain<br>&#125;)<br><br>first_prompt = PromptTemplate.from_template(<br>    <span class="hljs-string">&quot;不要回答下面用户的问题，只要根据用户的输入来判断分类，一共有[物理、历史、计算机、数学、其他]5种类别。\n\n \</span><br><span class="hljs-string">    用户输入：&#123;input&#125;\n\n \</span><br><span class="hljs-string">    最后的输出包含分类的类别和用户输入的内容，输出格式为json。其中，类别的key为type，用户输入内容的key为input。&quot;</span><br>)<br><br>chain1 = first_prompt | llm | JsonOutputParser()<br><br>chain2 = RunnableSequence(chain1, route_runnable, router,<br>                          StrOutputParser())  <span class="hljs-comment"># chain2 =  chain1 | route_runnable | router |SrtOutputParser()</span><br><br>inputs = [<br>    &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;什么是黑体辐射?&quot;</span>&#125;,  <span class="hljs-comment"># 物壁问题</span><br>    &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;计算 2+2 的结果。&quot;</span>&#125;,  <span class="hljs-comment"># 数学问题</span><br>    &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;介绍一次世界大战的背景。&quot;</span>&#125;,  <span class="hljs-comment"># 历史问题</span><br>    &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;如何实现快速排序算法?&quot;</span>&#125;  <span class="hljs-comment"># 计算机科学问题</span><br>]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> inputs:<br>    res = chain2.invoke(i)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;问题：<span class="hljs-subst">&#123;i&#125;</span> \n 结果：<span class="hljs-subst">&#123;res&#125;</span> \n&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="4-语法"><a href="#4-语法" class="headerlink" title="4 语法"></a>4 语法</h2><h3 id="4-1-节点"><a href="#4-1-节点" class="headerlink" title="4.1 节点"></a>4.1 节点</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">from</span> langchain_core.runnables <span class="hljs-keyword">import</span> RunnableLambda, RunnableParallel, RunnablePassthrough<br><span class="hljs-keyword">from</span> langchain_core.tracers <span class="hljs-keyword">import</span> Run<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> x + <span class="hljs-number">10</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test2</span>(<span class="hljs-params">prompt: <span class="hljs-built_in">str</span></span>):<br>    <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> prompt.split(<span class="hljs-string">&#x27; &#x27;</span>):<br>        <span class="hljs-keyword">yield</span> item<br><br><span class="hljs-comment"># 1、节点：标准均需实现Runnable接口</span><br>r1 = RunnableLambda(test)<br>r2 = RunnableLambda(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">2</span>)<br></code></pre></td></tr></table></figure><h3 id="4-2-批量、流式调用"><a href="#4-2-批量、流式调用" class="headerlink" title="4.2 批量、流式调用"></a>4.2 批量、流式调用</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 2、批量调用</span><br>res = r1.batch([<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>])<br><br><span class="hljs-comment"># 3、流式调用</span><br>r1 = RunnableLambda(test2) <span class="hljs-comment"># 把行数封装成一个组件</span><br>res = r1.stream(<span class="hljs-string">&#x27;How are you?&#x27;</span>) <span class="hljs-comment"># 返回的试一个生成器</span><br><br><span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> res:<br>    <span class="hljs-built_in">print</span>(chunk)<br><br><span class="hljs-comment"># 4、组合链</span><br>chain1 = r1 | r2<br><span class="hljs-built_in">print</span>(chain.invoke(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="4-3-并行运行并打印流程"><a href="#4-3-并行运行并打印流程" class="headerlink" title="4.3 并行运行并打印流程"></a>4.3 并行运行并打印流程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 5、并行运行</span><br>chain2 = RunnableParallel(r1=r1, r2=r2) <span class="hljs-comment"># 前面r1是key，后面是value，键值对的形式</span><br><br><span class="hljs-comment"># max_concurrency最大并发数</span><br><span class="hljs-built_in">print</span>(chain2.invoke(<span class="hljs-number">2</span>, config=&#123;<span class="hljs-string">&#x27;max_concurrency&#x27;</span>: <span class="hljs-number">1</span>&#125;))<br><br>chain3 = chain1 | chain2<br><br><span class="hljs-comment"># 打印链的图形</span><br>chain3.get_graph().print_ascii()<br><span class="hljs-built_in">print</span>(chain3.invoke(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="4-4-合并处理中间数据"><a href="#4-4-合并处理中间数据" class="headerlink" title="4.4 合并处理中间数据"></a>4.4 合并处理中间数据</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 6、合并输入，并处理中间数据</span><br><span class="hljs-comment"># RunnablePassthrough：运输传递输入数据，可以保持不变或添加额外的链路，必须传入字典数据，还可以过滤</span><br>dict1 = RunnableLambda(<span class="hljs-keyword">lambda</span> x: &#123;<span class="hljs-string">&#x27;key1&#x27;</span>: x&#125;)<br>dict2 = RunnableLambda(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;key1&#x27;</span>]+ <span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># chain_dict =  dict1 | RunnablePassthrough.assign(new_key=dict2)</span><br><span class="hljs-comment"># chain_dict =  dict1 | RunnableParallel(dict1=RunnablePassthrough(), dict2=RunnablePassthrough.assign(dict2=dict2))</span><br><span class="hljs-comment"># dict2只留下选中的key</span><br>chain_dict =  dict1 | RunnableParallel(dict1=RunnablePassthrough(), dict2=RunnablePassthrough.assign(dict2=dict2)).pick([<span class="hljs-string">&#x27;dict2&#x27;</span>])<br><span class="hljs-built_in">print</span>(chain_dict.invoke(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="4-5-异常处理"><a href="#4-5-异常处理" class="headerlink" title="4.5 异常处理"></a>4.5 异常处理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 7、后备选项： 紧急情况下使用的替代方案</span><br><span class="hljs-comment"># 如果前面的组件出现异常，则使用后备组件</span><br>r3 = RunnableLambda(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">int</span>(x) + <span class="hljs-number">20</span>)<br>chain = r1.with_fallbacks([r3]) <span class="hljs-comment"># 如果r1出现异常，则使用r3</span><br><span class="hljs-built_in">print</span>(chain.invoke(<span class="hljs-string">&#x27;2&#x27;</span>))<br></code></pre></td></tr></table></figure><h3 id="4-6-重复执行"><a href="#4-6-重复执行" class="headerlink" title="4.6 重复执行"></a>4.6 重复执行</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 8、重复多次执行某个节点</span><br>counter = <span class="hljs-number">0</span><br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test3</span>(<span class="hljs-params">x</span>):<br>    <span class="hljs-keyword">global</span> counter<br>    counter += <span class="hljs-number">1</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;执行了<span class="hljs-subst">&#123;counter&#125;</span>次&#x27;</span>)<br>    <span class="hljs-keyword">return</span> x / <span class="hljs-number">0</span><br><br>r4 = RunnableLambda(test3).with_retry(stop_after_attempt=<span class="hljs-number">3</span>)<br><br><span class="hljs-built_in">print</span>(r4.invoke(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h3 id="4-7-动态链"><a href="#4-7-动态链" class="headerlink" title="4.7 动态链"></a>4.7 动态链</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 8、根据条件，动态的构建链</span><br>r5 = RunnableLambda(<span class="hljs-keyword">lambda</span> x: [x] * <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 根据r1的输出结果，判断是否要执行r5</span><br>chain = r1 | RunnableLambda(<span class="hljs-keyword">lambda</span> x: r5 <span class="hljs-keyword">if</span> x &gt; <span class="hljs-number">10</span> <span class="hljs-keyword">else</span> RunnablePassthrough().assign(res=x))<br><span class="hljs-built_in">print</span>(chain.invoke(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><p>4.8 生命周期管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 9、生命周期管理</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test4</span>(<span class="hljs-params">x: <span class="hljs-built_in">int</span></span>):<br>    time.sleep(x)<br>    <span class="hljs-keyword">return</span> x * <span class="hljs-number">2</span><br><br><br>r6 = RunnableLambda(test4)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_start</span>(<span class="hljs-params">run_obj: Run</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;r6开始执行的时间：&#x27;</span>, run_obj.start_time)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">on_end</span>(<span class="hljs-params">run_obj: Run</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;r6结束执行的时间：&#x27;</span>, run_obj.end_time)<br><br><br>chain = r6.with_listeners(on_start=on_start, on_end=on_end)<br><span class="hljs-built_in">print</span>(chain.invoke(<span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h1 id="五、模型开发"><a href="#五、模型开发" class="headerlink" title="五、模型开发"></a>五、模型开发</h1><h2 id="1-学习路线"><a href="#1-学习路线" class="headerlink" title="1 学习路线"></a>1 学习路线</h2><p>首先安装Openai库：pip install openai </p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250701193044653.png" alt="image-20250701193044559"></p><h2 id="2-模型参数"><a href="#2-模型参数" class="headerlink" title="2 模型参数"></a>2 模型参数</h2><p><strong>model：</strong> 必选参数，大模型的名称；</p><p><strong>messages：</strong> 必选参数，提示词；</p><p><strong>max_tokens：</strong> 可选参数，代表返回结果的token数量；</p><p><strong>temperature</strong>：可选参数，取值范围为0-2，默认值为1。参数代表采样温度，数值越小，则模型会倾向于选择概率较高的词汇，生成的文本会更加保守;而当temperature值较高时，模型会更多地选择概率较低的词汇，生成的文本会更加多样；</p><p><strong>top_p</strong>：可选参数，取值范围为0-1，默认值为1，和temperature作用类似，用于控制输出文本的随机性，数值越趋近与1，输出文本随机性越强，越趋近于0文本随机性越弱；</p><blockquote><p>top_p和temperature两个参数选择一个进行调整即可；这里更推荐使用temperature参数进行文本随机性调整;</p></blockquote><p><strong>n</strong>：可选参数，默认值为1，表示一个提示返回几个Completion；</p><p><strong>stream</strong>：可选参数，默认值为False，表示回复响应的方式，当为False时，模型会等待返回结果全部生成后一次性返回全部结果，而为True时，则会逐个字进行返回；</p><p><strong>stop</strong>：可选参数，默认为null，该参数接受一个或多个字符串，用于指定生成文本的停止信号。当模型生成的文本遇到这些字符串中的任何一个时，会立即停止生成。这可以用来控制模型的输出长度或格式；</p><blockquote><p>分别用于控制生成文本中新单词的出现频率和单词的重复频率，可以避免生成的文本过于重复或单调</p></blockquote><p><strong>presence penalty</strong>：可选参数，默认为0，取值范围为[-2, 2]，该参数用于调整模型生成新内容(例如新的概念或主题)的倾向性。较高的值会使模型更倾向于生成新内容，而较低的值则会使模型更倾向于坚持已有的内容，当返回结果篇幅较大并且存在前后主题重复时，可以提高该参数的取值；</p><p><strong>frequency penalty</strong>：可选参数，默认为0，取值范围为[-2, 2]，该参数用于调整模型重复自身的倾向性。较高的值会使模型更倾向于避免重复，而较低的值则会使模型更可能重复自身;当返回结果篇幅较大并且存在前后语言重复时，可以提高该参数的取值；</p><p><strong>tools</strong>：可以调用的函数；</p><p><strong>tool choice</strong>：调用函数的策略；</p><h2 id="3-Embeddings模型"><a href="#3-Embeddings模型" class="headerlink" title="3 Embeddings模型"></a>3 Embeddings模型</h2><p>概念：Embeddings（嵌入）在自然语言处理（NLP）中起着至关重要的作用，它们的主要目的是将高维、离散的文本数据（如单词或短语）转换为低维、连续的向量表示。这些向量不仅编码了词本身的含义，还捕捉到了词语之间的语义和句法关系。通过embeddings，原本难以直接处理的文本数据可以被机器学习模型理解和操作。</p><p>计算模型相似度：</p><blockquote><p>余弦相似度是一个衡量两个非零向量之间夹角的度量，它给出的是这两个向量在多大程度上指向相同的方向。余弦相似度的值域是[-1，1]，其中1表示两个向量完全相同方向，-1表示完全相反方向，而0则表示两个向量正交(即不相关)。</p><p>$cosine&#x3D;\frac{a·b}{||a|| · ||b||}$</p></blockquote><h2 id="4-训练私有模型"><a href="#4-训练私有模型" class="headerlink" title="4 训练私有模型"></a>4 训练私有模型</h2><ul><li><strong>确认应用场景</strong>：确定模型能力、并进行模型选择</li><li><strong>数据处理</strong>：数据采集、数据清洗、<strong>数据配比（垂直和通用、每个数据源的配比）</strong></li><li><strong>预训练</strong>：模型设计（size、结构、专有领域的tokenizer）</li><li>Fine-Tuning</li><li>benchmark：对训练模型进行评测</li></ul>]]></content>
    
    
    <categories>
      
      <category>深度学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>深度学习</tag>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>仿斗鱼项目</title>
    <link href="/2025/06/27/%E4%BB%BF%E6%96%97%E9%B1%BC%E9%A1%B9%E7%9B%AE/"/>
    <url>/2025/06/27/%E4%BB%BF%E6%96%97%E9%B1%BC%E9%A1%B9%E7%9B%AE/</url>
    
    <content type="html"><![CDATA[<h1 id="一、项目技术点"><a href="#一、项目技术点" class="headerlink" title="一、项目技术点"></a>一、项目技术点</h1><p>语言：java jdk17</p><p>数据库：MySQL</p><p>容器：Docker</p><p>SpringCloudAlibaba基础框架：Netty()、SpringBoot（生态好）、Dubbo（良好的高并发）、MyBatis-Plus（CRUD精简）、ShardingJdbc、</p><p>缓存：Redis+Caffeine（本地缓存组件）</p><p>网关：Gateway</p><p>消息队列：RocketMQ</p><p>注册配置中心：Nacos</p><p>项目架构图：<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627111909528.png" alt="image-20250627111902441"></p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627124818378.png" alt="image-20250627124818345"></p><p>各个章节核心技术梳理</p><p>用户中心：</p><ul><li>亿级数据的分库分表</li><li>分布式缓存的数据一致性</li><li>高并发场景下的分布式id生成器</li><li>高并发下的用户标签系统实现</li><li>容器化下的JVM调优</li></ul><p>即时通信：</p><ul><li>从0到1落地直播应用下的IM架构</li><li>对Netty，RocketMQ的二次开发</li><li>基于MQ实现与业务下游的通讯</li><li>TCP长连接+WS模型的接入层</li><li>容器化下的JVM调优</li></ul><p>钱包礼物系统：</p><ul><li>钱包账户体系的搭建</li><li>支付回调中台的设计</li><li>高并发下送礼功能的实现</li><li>海量数据的分库分表设计</li><li>容器化下的JVM调优</li></ul><p>直播应用综合篇：</p><ul><li>直播平台PK案例</li><li>直播应用中的红包雨案例分析</li><li>直播带货中的商品秒杀分析</li></ul><h1 id="二、细节实现"><a href="#二、细节实现" class="headerlink" title="二、细节实现"></a>二、细节实现</h1><h2 id="1、微服务模式"><a href="#1、微服务模式" class="headerlink" title="1、微服务模式"></a>1、微服务模式</h2><ul><li><p><strong>代理微服务</strong>，客户端需要对返回的数据进行拼装组合处理</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627114721882.png" alt="image-20250627114721840" style="zoom: 50%;" /></li><li><p><strong>聚合器模式</strong>，将返回的数据进行后端处理，然后将结果通过API返回给客户端</p></li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627114841673.png" alt="image-20250627114841631" style="zoom: 50%;" /><ul><li><strong>分支微服务模式</strong></li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627115121183.png" alt="image-20250627115121151" style="zoom: 67%;" /><p><font color='red'><strong>PS：聚合器和分支微服务模式图虽然看似相同，但是是有区别的。聚合器模式更加关注组合多个独立服务的响应结果，分支模式关注条件或业务逻辑动态选择执行路径（调用不同的服务链）</strong></font></p><ul><li><p><strong>链式微服务</strong>（强烈避免，网络开销过大）</p></li><li><p><strong>数据共享模式</strong>，单个数据库能承载的情况下，可以进行数据共享</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627115829288.png" alt="image-20250627115829254" style="zoom: 80%;" /></li><li><p><strong>异步消息传递模式</strong>：解除服务之间的强应答关系，吞吐量高、异步、解耦</p></li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627120748156.png" alt="image-20250627120748112" style="zoom:67%;" /><h2 id="2、框架选择"><a href="#2、框架选择" class="headerlink" title="2、框架选择"></a>2、框架选择</h2><h3 id="2-1、Dubbo"><a href="#2-1、Dubbo" class="headerlink" title="2.1、Dubbo"></a>2.1、Dubbo</h3><p>核心特点：</p><ul><li>高性能RPC调用</li><li>弹性价格</li><li>服务治理：流量分配转发、可视化监控平台、生态完善、支持服务网络技术（接入到Istio）</li></ul><h3 id="2-2、SpringCloud"><a href="#2-2、SpringCloud" class="headerlink" title="2.2、SpringCloud"></a>2.2、SpringCloud</h3><p>核心特点：提供一套通用的分布式系统基础组件，支持服务治理服务注册与发现,配置中心，负载均衡，监控跟踪等</p><p>技术栈：Eureka、Ribbon、Feign、Hystrix、Zuul、Archaius等</p><h3 id="2-3、SpringCloudAlibaba"><a href="#2-3、SpringCloudAlibaba" class="headerlink" title="2.3、SpringCloudAlibaba"></a>2.3、SpringCloudAlibaba</h3><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套集成框架。Spring Cloud Alibaba 致力于提供微服务开发的一站式解决方案<br>技术栈：Spring Cloud Gateway，Nacos，Dubbo，RocketMQ，Sentinel，Seata等</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250627123707742.png" alt="image-20250627123707711"></p>]]></content>
    
    
    <categories>
      
      <category>java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>项目</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>AlexNet论文</title>
    <link href="/2025/06/26/AlexNet%E8%AE%BA%E6%96%87/"/>
    <url>/2025/06/26/AlexNet%E8%AE%BA%E6%96%87/</url>
    
    <content type="html"><![CDATA[<p>在2012年时候，由Alex Krizhevsky、Ilya Sutskever和Geoffrey Hinton在ImageNet LSVRC-2010图像分类竞赛中提出的一种经典的卷积神经网络，由于他的出现和在 ImageNet 大规模视觉识别竞赛中取得了优异的成绩，把深度学习模型在比赛中的正确率提升到一个前所未有的高度，他的结果在测试集上取得 <strong>top-1错误率37.5%</strong>、<strong>top-5错误率17.0%</strong>，显著优于此前最优结果。ILSVRC-2012版本模型进一步提升至 <strong>top-5错误率15.3%</strong>（对比第二名26.2%）。比第二名整整高了近11个百分点。论文我将从<strong>结构剖析、创新点分析</strong>以及根据pytorch进行<strong>代码复现</strong>。</p><h1 id="一、架构剖析"><a href="#一、架构剖析" class="headerlink" title="一、架构剖析"></a>一、架构剖析</h1><p>首先，输入的图片是RGB三通道，我们可以先不管输入图像的大小规格是怎样的，因为输入之后会对图像进行裁剪，给定一个矩形图像，我们首先将图像缩放，使得较短的边长为256，然后从结果图像中裁剪出中心的256×256区域将图像下采样（PS：高斯金字塔，下采样方向向下，关注的数据量减少，<strong>特征提取压缩</strong>，<strong>降噪</strong>）到固定的256 × 256 × 3。下图就是截取的AlexNet的一个架构图。</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250626155452177.png" alt="AlexNet架构"></p><h2 id="1、前五层"><a href="#1、前五层" class="headerlink" title="1、前五层"></a>1、前五层</h2><p>AlexNet共有五个卷积层，每个卷积层都包含卷积核、偏置项、ReLU激活函数和局部响应归一化（LRN）模块。</p><ul><li>卷积层C1：使用96个尺寸为11 × 11 × 3的卷积核对224 × 224 × 3的输入图像进行滤波，步长为4个像素（这是卷积核图中相邻神经元感受野中心之间的距离）</li><li>卷积层C2：以第一个卷积层的（响应归一化和池化）输出作为输入，并使用256个尺寸为5 × 5 × 48的卷积核对其进行滤波</li><li>卷积层C3：有384个核，核大小为3 × 3 × 256，与卷积层C2的输出（归一化的，池化的）相连。</li><li>卷积层C4：有384个核，核大小为3 × 3 × 192。</li><li>卷积层C5：有256个核，核大小为3 × 3 × 192。卷积层C5与C3、C4层相比多了个池化，池化核size同样为3×3，stride为2。</li></ul><p>第三、第四和第五个卷积层彼此连接，没有任何中间的池化或归一化层。</p><p><font color='red'>我们可看到C2到C3层、C5d到F6和F6到F7之间他们是交叉的。具体原因创新点的时候细说~</font></p><h2 id="2、全连接层"><a href="#2、全连接层" class="headerlink" title="2、全连接层"></a>2、全连接层</h2><p>全连接层F6、F7将所有的特征向量拉成一排生成4096个卷积核，加上最后一个1000-way softmax 进行分类，产生1000个类别预测的值。</p><h1 id="二、创新点"><a href="#二、创新点" class="headerlink" title="二、创新点"></a>二、创新点</h1><h2 id="1、双GPU训练"><a href="#1、双GPU训练" class="headerlink" title="1、双GPU训练"></a>1、双GPU训练</h2><p>作者分成了两块 GTX 580 3GB GPU进行训练，值得注意的是，卷积层中只有C2到C3进行了交叉通讯信息共享，其他的卷积层都是独立的GPU在各自训练。但是到后期的时候，作者发现两个GPU所表现出的专业化分工。<font color='red'><strong>GPU 1上的卷积核在很大程度上与颜色无关，而GPU 2上的卷积核在很大程度上是颜色特定的</strong></font>。这种专业化分工在每次运行中都会发生，并且独立于任何特定的随机权重初始化（模GPU的重新编号）。</p><h2 id="2、Dropout和数据增强"><a href="#2、Dropout和数据增强" class="headerlink" title="2、Dropout和数据增强"></a>2、Dropout和数据增强</h2><p>为了防止过拟合，AlexNet 引入了数据增强和 Dropout 技术。</p><p><font color='red'><strong>数据增强</strong></font>分成了一下两种：</p><ul><li>从图像大小256上，以中心区域扣224大小的图，然后进行<strong>对图像进行旋转、翻转、裁剪等变换</strong>，增加训练数据的多样性，提高模型的泛化能力。对于AlexNet进行实现来说，<strong>数据增强是免费的，因为变换后的图片不需要存储与磁盘中，他们生成于CPU上，而此刻的GPU正在训练，这样同步进行</strong>。</li><li>第二种是PCB降维处理，改变训练图像中RGB通道的强度</li></ul><p><font color='red'><strong>Dropout</strong> </font>则是在训练过程中随机删除一定比例的神经元，强制网络学习多个互不相同的子网络，从而提高网络的泛化能力。Dropout简单来说就是在前向传播的时候，让某个神经元的激活值以一定的概率p停止工作，这样可以使模型泛化性更强，因为它不会太依赖某些局部的特征。</p><h2 id="3、ReLU激活函数的使用"><a href="#3、ReLU激活函数的使用" class="headerlink" title="3、ReLU激活函数的使用"></a>3、ReLU激活函数的使用</h2><p>AlexNet 首次使用了<strong>修正线性单元</strong>（ReLU：Rectified Linear Units）这一非线性激活函数。相比于传统的 sigmoid 和 tanh 函数，ReLU 能够在保持计算速度的同时，有效地解决了梯度消失问题，从而使得训练更加高效。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250626173635157.png" alt="ReLU" style="zoom:50%;" /><h2 id="4、重叠最大池化"><a href="#4、重叠最大池化" class="headerlink" title="4、重叠最大池化"></a>4、重叠最大池化</h2><p>在CNN中使用重叠的最大池化。此前CNN中普遍使用平均池化，AlexNet全部使用最大池化，避免平均池化的模糊化效果。并且AlexNet中提出让步长比池化核的尺寸小，这样池化层的输出之间会有重叠和覆盖，提升了特征的丰富性。</p><h2 id="5、局部响应归一化"><a href="#5、局部响应归一化" class="headerlink" title="5、局部响应归一化"></a>5、局部响应归一化</h2><p><strong>局部响应归一化（Local Respone Normalization）</strong>，对局部神经元的活动创建竞争机制，<strong>使得其中响应比较大的值变得相对更大</strong>，并<strong>抑制其他反馈较小的神经元，增强了模型的泛化能力</strong>。LRN通过在相邻卷积核生成的feature map之间引入竞争，从而有些本来在feature map中显著的特征在A中更显著，而在相邻的其他feature map中被抑制，这样让不同卷积核产生的feature map之间的相关性变小。</p><h1 id="三、代码复现"><a href="#三、代码复现" class="headerlink" title="三、代码复现"></a>三、代码复现</h1><h2 id="1、定义网络模型"><a href="#1、定义网络模型" class="headerlink" title="1、定义网络模型"></a>1、定义网络模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AlexNet</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, config</span>):<br>        <span class="hljs-built_in">super</span>(AlexNet, <span class="hljs-variable language_">self</span>).__init__()<br>        <span class="hljs-variable language_">self</span>._config = config<br>        <span class="hljs-comment"># 定义卷积层和池化层</span><br>        <span class="hljs-variable language_">self</span>.features = nn.Sequential(<br>            nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">96</span>, kernel_size=<span class="hljs-number">11</span>, stride=<span class="hljs-number">4</span>, padding=<span class="hljs-number">2</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">96</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">5</span>, padding=<span class="hljs-number">2</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br><br>            nn.Conv2d(<span class="hljs-number">256</span>, <span class="hljs-number">384</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br><br>            nn.Conv2d(<span class="hljs-number">384</span>, <span class="hljs-number">384</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br><br>            nn.Conv2d(<span class="hljs-number">384</span>, <span class="hljs-number">256</span>, kernel_size=<span class="hljs-number">3</span>, padding=<span class="hljs-number">1</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br><br>            nn.MaxPool2d(kernel_size=<span class="hljs-number">3</span>, stride=<span class="hljs-number">2</span>),<br>        )<br>        <span class="hljs-comment"># 自适应全连接，这样可以使上一层与下一层更好的连接</span><br>        <span class="hljs-variable language_">self</span>.avgpool = nn.AdaptiveAvgPool2d((<span class="hljs-number">6</span>, <span class="hljs-number">6</span>))<br>        <span class="hljs-comment"># 定义全连接层</span><br>        <span class="hljs-variable language_">self</span>.classifier = nn.Sequential(<br>            nn.Dropout(),<br>            nn.Linear(<span class="hljs-number">256</span> * <span class="hljs-number">6</span> * <span class="hljs-number">6</span>, <span class="hljs-number">4096</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Dropout(),<br>            nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-number">4096</span>),<br>            nn.ReLU(inplace=<span class="hljs-literal">True</span>),<br>            nn.Linear(<span class="hljs-number">4096</span>, <span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;num_classes&#x27;</span>]),<br>        )<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = <span class="hljs-variable language_">self</span>.features(x)<br>        x = <span class="hljs-variable language_">self</span>.avgpool(x)<br>        x = torch.flatten(x, <span class="hljs-number">1</span>)<br>        x = <span class="hljs-variable language_">self</span>.classifier(x)<br>        <span class="hljs-keyword">return</span> x<br><br>    <span class="hljs-comment"># 2、模型保存与模型加载</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save_model</span>(<span class="hljs-params">self</span>):<br>        torch.save(<span class="hljs-variable language_">self</span>.state_dict(), <span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;model_name&#x27;</span>])<br><br>    <span class="hljs-comment"># map_location 参数用于指定加载模型时使用的设备（如 CPU 或特定的 GPU）</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">load_model</span>(<span class="hljs-params">self, map_location</span>):<br>        state_dict = torch.load(<span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;model_name&#x27;</span>], map_location=map_location)<br>        <span class="hljs-variable language_">self</span>.load_state_dict(state_dict, strict=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h2 id="2、数据集预处理"><a href="#2、数据集预处理" class="headerlink" title="2、数据集预处理"></a>2、数据集预处理</h2><p>我们选择的CIFAR-10数据集</p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs routeros">import torchvision<br>import torchvision.transforms as transforms<br><span class="hljs-keyword">from</span> torch.utils.data import DataLoader<br><br><br><span class="hljs-comment"># 定义构造数据加载器的函数</span><br>def Construct_DataLoader(dataset, batch_size):<br>    return DataLoader(<span class="hljs-attribute">dataset</span>=dataset, <span class="hljs-attribute">batch_size</span>=batch_size, <span class="hljs-attribute">shuffle</span>=<span class="hljs-literal">True</span>)<br><br><br><span class="hljs-comment"># 图像预处理</span><br>transform = transforms.Compose([<br>    transforms.Resize(96),<br>    transforms.ToTensor(),<br>    transforms.Normalize((0.5, 0.5, 0.5), (0.5, 0.5, 0.5))<br>])<br><br><br><span class="hljs-comment"># 加载数据集函数</span><br>def LoadCIFAR10(<span class="hljs-attribute">download</span>=<span class="hljs-literal">False</span>):<br>    # 加载数据集<br>    train_dataset = torchvision.datasets.CIFAR10(<span class="hljs-attribute">root</span>=<span class="hljs-string">&#x27;../data&#x27;</span>, <span class="hljs-attribute">train</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">transform</span>=transform, <span class="hljs-attribute">download</span>=<span class="hljs-literal">True</span>)<br>    test_dataset = torchvision.datasets.CIFAR10(<span class="hljs-attribute">root</span>=<span class="hljs-string">&#x27;../data&#x27;</span>, <span class="hljs-attribute">train</span>=<span class="hljs-literal">False</span>, <span class="hljs-attribute">transform</span>=transform)<br>    return train_dataset, test_dataset<br></code></pre></td></tr></table></figure><h3 id="3、定义训练函数"><a href="#3、定义训练函数" class="headerlink" title="3、定义训练函数"></a>3、定义训练函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.autograd <span class="hljs-keyword">import</span> Variable<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Train</span>(<span class="hljs-title class_ inherited__">object</span>):<br>    <span class="hljs-comment"># 初始化函数、配置参数、优化器和损失函数</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, model, config</span>):<br>        <span class="hljs-variable language_">self</span>._model = model<br>        <span class="hljs-variable language_">self</span>._config = config<br>        <span class="hljs-variable language_">self</span>._optimizer = torch.optim.SGD(<span class="hljs-variable language_">self</span>._model.parameters(), lr=<span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;lr&#x27;</span>],<br>                                          momentum=<span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;momentum&#x27;</span>], weight_decay=<span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;weight_decay&#x27;</span>])<br>        <span class="hljs-comment"># 定义并初始化一个损失函数，用于在训练过程中计算模型的预测输出与真实标签之间的差异。</span><br>        <span class="hljs-variable language_">self</span>.loss_func = nn.CrossEntropyLoss()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_train_single_batch</span>(<span class="hljs-params">self, images, labels</span>):<br>        y_predict = <span class="hljs-variable language_">self</span>._model(images)<br><br>        loss = <span class="hljs-variable language_">self</span>.loss_func(y_predict, labels)<br>        <span class="hljs-comment"># 先将梯度清零,如果不清零，那么这个梯度就和上一个mini-batch有关</span><br>        <span class="hljs-variable language_">self</span>._optimizer.zero_grad()<br>        <span class="hljs-comment"># 反向传播计算梯度</span><br>        loss.backward()<br>        <span class="hljs-comment"># 梯度下降等优化器 更新参数</span><br>        <span class="hljs-variable language_">self</span>._optimizer.step()<br>        <span class="hljs-comment"># 将loss的值提取成python的float类型</span><br>        loss = loss.item()<br><br>        <span class="hljs-comment"># 计算训练精确度</span><br>        <span class="hljs-comment"># 这里的y_predict是一个多个分类输出，将dim指定为1，即返回每一个分类输出最大的值以及下标</span><br>        _, predicted = torch.<span class="hljs-built_in">max</span>(y_predict.data, dim=<span class="hljs-number">1</span>)<br>        <span class="hljs-keyword">return</span> loss, predicted<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">_train_an_epoch</span>(<span class="hljs-params">self, train_loader, epoch</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        训练一个Epoch，即将训练集中的所有样本全部都过一遍</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-comment"># 设置模型为训练模式，启用dropout以及batch normalization</span><br>        <span class="hljs-variable language_">self</span>._model.train()<br>        total = <span class="hljs-number">0</span><br>        correct = <span class="hljs-number">0</span><br><br>        <span class="hljs-comment"># 从DataLoader中获取小批量的num以及数据</span><br>        <span class="hljs-keyword">for</span> batch, (images, labels) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>            images = Variable(images)<br>            labels = Variable(labels)<br>            <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;use_cuda&#x27;</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>                images, labels = images.cuda(), labels.cuda()<br><br>            loss, predicted = <span class="hljs-variable language_">self</span>._train_single_batch(images, labels)<br><br>            <span class="hljs-comment"># 计算训练精确度</span><br>            total += labels.size(<span class="hljs-number">0</span>)<br>            correct += (predicted == labels.data).<span class="hljs-built_in">sum</span>()<br><br>            <span class="hljs-comment"># print(&#x27;[Training Epoch: &#123;&#125;] Batch: &#123;&#125;, Loss: &#123;&#125;&#x27;.format(epoch_num, batch, loss))</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Training Epoch: &#123;&#125;, accuracy rate: &#123;&#125;%%&#x27;</span>.<span class="hljs-built_in">format</span>(epoch, correct / total * <span class="hljs-number">100.0</span>))<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">self, train_dataset</span>):<br>        <span class="hljs-comment"># 是否使用GPU加速</span><br>        <span class="hljs-variable language_">self</span>.use_cuda()<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;epoch&#x27;</span>]):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">20</span> + <span class="hljs-string">&#x27; Epoch &#123;&#125; starts &#x27;</span>.<span class="hljs-built_in">format</span>(epoch) + <span class="hljs-string">&#x27;-&#x27;</span> * <span class="hljs-number">20</span>)<br>            <span class="hljs-comment"># 构造DataLoader</span><br>            data_loader = DataLoader(dataset=train_dataset, batch_size=<span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;batch_size&#x27;</span>], shuffle=<span class="hljs-literal">True</span>)<br>            <span class="hljs-comment"># 训练一个轮次</span><br>            <span class="hljs-variable language_">self</span>._train_an_epoch(data_loader, epoch=epoch)<br><br>    <span class="hljs-comment"># 用于将模型和数据迁移到GPU上进行计算，如果CUDA不可用则会抛出异常</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">use_cuda</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;use_cuda&#x27;</span>] <span class="hljs-keyword">is</span> <span class="hljs-literal">True</span>:<br>            <span class="hljs-keyword">assert</span> torch.cuda.is_available(), <span class="hljs-string">&#x27;CUDA is not available&#x27;</span><br>            torch.cuda.set_device(<span class="hljs-variable language_">self</span>._config[<span class="hljs-string">&#x27;device_id&#x27;</span>])<br>            <span class="hljs-variable language_">self</span>._model.cuda()<br><br>    <span class="hljs-comment"># 保存训练好的模型</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">save</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>._model.save_model()<br></code></pre></td></tr></table></figure><h2 id="4、模型训练"><a href="#4、模型训练" class="headerlink" title="4、模型训练"></a>4、模型训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义参数配置信息</span><br>alexnet_config = &#123;<br>    <span class="hljs-string">&#x27;epoch&#x27;</span>: <span class="hljs-number">40</span>,  <span class="hljs-comment"># 训练轮次数</span><br>    <span class="hljs-string">&#x27;batch_size&#x27;</span>: <span class="hljs-number">128</span>,  <span class="hljs-comment"># 每个小批量训练的样本数量</span><br>    <span class="hljs-string">&#x27;lr&#x27;</span>: <span class="hljs-number">1e-3</span>,  <span class="hljs-comment"># 学习率</span><br>    <span class="hljs-string">&#x27;num_classes&#x27;</span>: <span class="hljs-number">10</span>,  <span class="hljs-comment"># 分类的类别数目</span><br>    <span class="hljs-string">&#x27;device_id&#x27;</span>: <span class="hljs-number">0</span>,  <span class="hljs-comment"># 使用的GPU设备的ID号</span><br>    <span class="hljs-string">&#x27;use_cuda&#x27;</span>: <span class="hljs-literal">True</span>,  <span class="hljs-comment"># 是否使用CUDA加速</span><br>    <span class="hljs-string">&#x27;momentum&#x27;</span>: <span class="hljs-number">0.9</span>,  <span class="hljs-comment"># 动量</span><br>    <span class="hljs-string">&#x27;weight_decay&#x27;</span>: <span class="hljs-number">1e-4</span>,  <span class="hljs-comment"># 权重衰减</span><br>    <span class="hljs-string">&#x27;model_name&#x27;</span>: <span class="hljs-string">&#x27;./AlexNet.model&#x27;</span>  <span class="hljs-comment"># 保存模型的文件名</span><br>&#125;<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment">####################################################################################</span><br>    <span class="hljs-comment"># AlexNet 模型</span><br>    <span class="hljs-comment">####################################################################################</span><br>    train_dataset, test_dataset = LoadCIFAR10(<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># define AlexNet model</span><br>    alexNet = AlexNet(alexnet_config)<br><br>    <span class="hljs-comment">####################################################################################</span><br>    <span class="hljs-comment"># 模型训练阶段</span><br>    <span class="hljs-comment">####################################################################################</span><br>    <span class="hljs-comment"># # 实例化模型训练器</span><br>    trainer = Train(model=alexNet, config=alexnet_config)<br>    <span class="hljs-comment"># # 训练</span><br>    trainer.train(train_dataset)<br>    <span class="hljs-comment"># # 保存模型</span><br>    trainer.save()<br><br>    <span class="hljs-comment">####################################################################################</span><br>    <span class="hljs-comment"># 模型测试阶段</span><br>    <span class="hljs-comment">####################################################################################</span><br>    alexNet.<span class="hljs-built_in">eval</span>()<br>    alexNet.load_model(map_location=torch.device(<span class="hljs-string">&#x27;cpu&#x27;</span>))<br>    <span class="hljs-keyword">if</span> alexnet_config[<span class="hljs-string">&#x27;use_cuda&#x27;</span>]:<br>        alexNet = alexNet.cuda()<br><br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    <span class="hljs-comment"># 对测试集中的每个样本进行预测，并计算出预测的精度</span><br>    <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> Construct_DataLoader(test_dataset, alexnet_config[<span class="hljs-string">&#x27;batch_size&#x27;</span>]):<br>        images = Variable(images)<br>        labels = Variable(labels)<br>        <span class="hljs-keyword">if</span> alexnet_config[<span class="hljs-string">&#x27;use_cuda&#x27;</span>]:<br>            images = images.cuda()<br>            labels = labels.cuda()<br><br>        y_pred = alexNet(images)<br>        _, predicted = torch.<span class="hljs-built_in">max</span>(y_pred.data, <span class="hljs-number">1</span>)<br>        total += labels.size(<span class="hljs-number">0</span>)<br>        temp = (predicted == labels.data).<span class="hljs-built_in">sum</span>()<br>        correct += temp<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Accuracy of the model on the test images: %.2f%%&#x27;</span> % (<span class="hljs-number">100.0</span> * correct / total))<br></code></pre></td></tr></table></figure><p>运行结果：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250626210848261.png" alt="image-20250626210848187" style="zoom:50%;" /><h1 id="鸣谢"><a href="#鸣谢" class="headerlink" title="鸣谢"></a>鸣谢</h1><p>很多参考这位博主：<a href="https://zhuanlan.zhihu.com/p/618545757">卷积神经网络经典回顾之AlexNet - 知乎</a></p>]]></content>
    
    
    <categories>
      
      <category>论文</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>深度学习</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>kaggle关于树叶的竞赛总结</title>
    <link href="/2025/05/25/kaggle%E5%85%B3%E4%BA%8E%E6%A0%91%E5%8F%B6%E7%9A%84%E7%AB%9E%E8%B5%9B%E6%80%BB%E7%BB%93/"/>
    <url>/2025/05/25/kaggle%E5%85%B3%E4%BA%8E%E6%A0%91%E5%8F%B6%E7%9A%84%E7%AB%9E%E8%B5%9B%E6%80%BB%E7%BB%93/</url>
    
    <content type="html"><![CDATA[<h1 id="kaggle关于树叶的竞赛总结"><a href="#kaggle关于树叶的竞赛总结" class="headerlink" title="kaggle关于树叶的竞赛总结"></a>kaggle关于树叶的竞赛总结</h1><p>预测叶子图像的类别，该数据集包含 176 个类别，18353 个训练图像，8800 个测试图像。<br>每个类别至少有 50 张图像用于训练，测试集平均分为公共和私人排行榜，网址为：<a href="https://www.kaggle.com/competitions/classify-leaves/code">https://www.kaggle.com/competitions/classify-leaves/code</a><br>由于images文件夹包含测试集和训练集所有图像，因此需要手动把测试集和训练集分开，所有代码如下，运行在一个GPU上面（lr,weight_decay,epochs &#x3D; 1e-4, 1e-4, 100）：</p><h2 id="一、导入相关包和定义函数"><a href="#一、导入相关包和定义函数" class="headerlink" title="一、导入相关包和定义函数"></a>一、导入相关包和定义函数</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> collections<br><span class="hljs-keyword">import</span> math<br><span class="hljs-keyword">import</span> os.path<br><span class="hljs-keyword">import</span> shutil<br><br><span class="hljs-keyword">import</span> d2l.torch<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torchvision.transforms<br><span class="hljs-keyword">import</span> torch.utils.data<br><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">read_csv_data</span>(<span class="hljs-params">fname</span>):<br>    <span class="hljs-comment"># 打开指定的 CSV 文件，使用 &#x27;r&#x27; 模式表示只读</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(fname, <span class="hljs-string">&#x27;r&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        <span class="hljs-comment"># 读取文件的所有行，并去掉第一行（标题行）</span><br>        lines = f.readlines()[<span class="hljs-number">1</span>:]<br><br>    <span class="hljs-comment"># line.rstrip() 去掉每行末尾的换行符</span><br>    <span class="hljs-comment"># 读取文件中每一行数据，去除每行末尾的换行符，并按逗号分隔</span><br>    tokens = [line.rstrip().split(<span class="hljs-string">&#x27;,&#x27;</span>) <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> lines]<br><br>    <span class="hljs-comment"># 创建一个字典，字典的键是图片的索引号，值是对应的标签</span><br>    <span class="hljs-comment"># name.split(&#x27;.&#x27;)[0] 获取文件名部分，去掉扩展名</span><br>    <span class="hljs-comment"># name.split(&#x27;/&#x27;)[1] 获取文件名部分，去掉路径</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-built_in">dict</span>(((name.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>].split(<span class="hljs-string">&#x27;/&#x27;</span>)[<span class="hljs-number">1</span>], label) <span class="hljs-keyword">for</span> name, label <span class="hljs-keyword">in</span> tokens))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">copy_file</span>(<span class="hljs-params">fname, target_dir</span>):<br>    <span class="hljs-comment"># 创建文件夹，如果存在，就不再重复创建</span><br>    os.makedirs(name=target_dir, exist_ok=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 将源文件图片复制到指定文件夹下</span><br>    shutil.copy(fname, target_dir)<br><br><br><span class="hljs-comment"># 从训练集中拆分一部分图片用作验证集，然后复制到指定文件夹下面</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">split_copy_train_valid_test</span>(<span class="hljs-params">data_dir, labels, split_to_valid_ratio</span>):<br>    <span class="hljs-comment"># 使用collections.Counter()函数对训练集类别数目进行计数，然后从大到小排列，获取最少的一类数目</span><br>    split_num = collections.Counter(labels.values()).most_common()[-<span class="hljs-number">1</span>][<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 计算从训练集中每一类需要选出多少个样本作为验证集，确保至少有一个样本</span><br>    num_valid_per_label = <span class="hljs-built_in">max</span>(<span class="hljs-number">1</span>, math.floor(split_num * split_to_valid_ratio))<br>    valid_label_count = &#123;&#125;<br>    absolute_path = os.path.join(data_dir, <span class="hljs-string">&#x27;train_valid_test&#x27;</span>)<br>    <span class="hljs-keyword">for</span> image_file <span class="hljs-keyword">in</span> os.listdir(os.path.join(data_dir, <span class="hljs-string">&#x27;images&#x27;</span>)):<br>        <span class="hljs-comment"># 获取当前图片的标签</span><br>        key = image_file.split(<span class="hljs-string">&#x27;.&#x27;</span>)[<span class="hljs-number">0</span>]<br>        <span class="hljs-comment">#print(&quot;.....&quot;, key)</span><br>        <span class="hljs-keyword">if</span> key <span class="hljs-keyword">in</span> labels:<br>            label = labels[key]<br>            train_file_path = os.path.join(data_dir, <span class="hljs-string">&#x27;images&#x27;</span>, image_file)<br>            <span class="hljs-comment"># 复制训练集的图片到&#x27;train_valid&#x27;文件夹下</span><br>            copy_file(train_file_path, os.path.join(absolute_path, <span class="hljs-string">&#x27;train_valid&#x27;</span>, label))<br>            <span class="hljs-keyword">if</span> label <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> valid_label_count <span class="hljs-keyword">or</span> valid_label_count[label] &lt; num_valid_per_label:<br>                <span class="hljs-comment"># 复制训练集的图片到&#x27;valid&#x27;文件夹下</span><br>                copy_file(train_file_path, os.path.join(absolute_path, <span class="hljs-string">&#x27;valid&#x27;</span>, label))<br>                valid_label_count[label] = valid_label_count.get(label, <span class="hljs-number">0</span>) + <span class="hljs-number">1</span><br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 复制训练集的图片到&#x27;train&#x27;文件夹下</span><br>                copy_file(train_file_path, os.path.join(absolute_path, <span class="hljs-string">&#x27;train&#x27;</span>, label))<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 如果图片没有对应的标签，将其复制到&#x27;test&#x27;文件夹下的&#x27;unknown&#x27;子文件夹</span><br>            copy_file(os.path.join(data_dir, <span class="hljs-string">&#x27;images&#x27;</span>, image_file),<br>                      os.path.join(data_dir, <span class="hljs-string">&#x27;train_valid_test&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;unknown&#x27;</span>))<br>    <span class="hljs-keyword">return</span> num_valid_per_label<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">copy_classify_leaves_data</span>(<span class="hljs-params">data_dir, split_to_valid_ratio</span>):<br>    labels = read_csv_data(fname=os.path.join(data_dir, <span class="hljs-string">&#x27;train.csv&#x27;</span>))<br>    split_copy_train_valid_test(data_dir, labels, split_to_valid_ratio)<br></code></pre></td></tr></table></figure><h2 id="二、读-176-个类别的标签文件"><a href="#二、读-176-个类别的标签文件" class="headerlink" title="二、读 176 个类别的标签文件"></a>二、读 176 个类别的标签文件</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">data_dir = <span class="hljs-string">&#x27;./&#x27;</span><br><br><span class="hljs-comment"># 读取训练数据集的标签文件</span><br>labels = read_csv_data(os.path.join(data_dir, <span class="hljs-string">&#x27;train.csv&#x27;</span>))<br><span class="hljs-comment"># 打印样本数，即标签数据的条目数</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;样本数：&#x27;</span>, <span class="hljs-built_in">len</span>(labels))<br><span class="hljs-comment"># 打印类别数，即标签数据中不同类别的数量</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;类别数：&#x27;</span>, <span class="hljs-built_in">len</span>(<span class="hljs-built_in">set</span>(labels.values())))<br><br><span class="hljs-comment">#print(labels.keys())</span><br></code></pre></td></tr></table></figure><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs">样本数： 18353<br>类别数： 176<br></code></pre></td></tr></table></figure><h2 id="三、拆分验证集"><a href="#三、拆分验证集" class="headerlink" title="三、拆分验证集"></a>三、拆分验证集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">32</span><br>num_classes = <span class="hljs-number">176</span><br>split_to_valid_ratio = <span class="hljs-number">0.1</span><br>copy_classify_leaves_data(data_dir, split_to_valid_ratio)<br></code></pre></td></tr></table></figure><h2 id="四、数据增广"><a href="#四、数据增广" class="headerlink" title="四、数据增广"></a>四、数据增广</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python">transform_train = torchvision.transforms.Compose([<br>    torchvision.transforms.Resize(<span class="hljs-number">256</span>),<br>    torchvision.transforms.RandomResizedCrop(<span class="hljs-number">96</span>, scale=(<span class="hljs-number">0.64</span>, <span class="hljs-number">1.0</span>), ratio=(<span class="hljs-number">1.0</span>, <span class="hljs-number">1.0</span>)),<br>    torchvision.transforms.RandomHorizontalFlip(),<br>    <span class="hljs-comment"># 随机更改亮度，对比度和饱和度</span><br>    torchvision.transforms.ColorJitter(brightness=<span class="hljs-number">0.4</span>, contrast=<span class="hljs-number">0.4</span>, saturation=<span class="hljs-number">0.4</span>),<br>    <span class="hljs-comment"># 随机旋转</span><br>    torchvision.transforms.RandomRotation(<span class="hljs-number">30</span>),<br>    <span class="hljs-comment"># 随机平移</span><br>    torchvision.transforms.RandomAffine(degrees=<span class="hljs-number">0</span>, translate=(<span class="hljs-number">0.1</span>, <span class="hljs-number">0.1</span>)),<br>    torchvision.transforms.ToTensor(),<br>    torchvision.transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br><br>transform_test = torchvision.transforms.Compose([<br>    torchvision.transforms.Resize(<span class="hljs-number">96</span>),<br>    torchvision.transforms.ToTensor(),<br>    torchvision.transforms.Normalize([<span class="hljs-number">0.485</span>, <span class="hljs-number">0.456</span>, <span class="hljs-number">0.406</span>], [<span class="hljs-number">0.229</span>, <span class="hljs-number">0.224</span>, <span class="hljs-number">0.225</span>])<br>])<br></code></pre></td></tr></table></figure><h2 id="五、ImageFolder重新组织数据集"><a href="#五、ImageFolder重新组织数据集" class="headerlink" title="五、ImageFolder重新组织数据集"></a>五、ImageFolder重新组织数据集</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python">train_datasets, train_valid_datasets = [torchvision.datasets.ImageFolder(<br>    root=os.path.join(data_dir, <span class="hljs-string">&#x27;train_valid_test&#x27;</span>, folder), transform=transform_train) <span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span><br>    [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;train_valid&#x27;</span>]]<br>test_datasets, valid_datasets = [<br>    torchvision.datasets.ImageFolder(root=os.path.join(data_dir, <span class="hljs-string">&#x27;train_valid_test&#x27;</span>, folder), transform=transform_test)<br>    <span class="hljs-keyword">for</span> folder <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;test&#x27;</span>, <span class="hljs-string">&#x27;valid&#x27;</span>]]<br><span class="hljs-comment">#创建数据集迭代器</span><br>train_iter, train_valid_iter = [<br>    torch.utils.data.DataLoader(dataset=ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">True</span>) <span class="hljs-keyword">for</span> ds <span class="hljs-keyword">in</span><br>    [train_datasets, train_valid_datasets]]<br>test_iter, valid_iter = [torch.utils.data.DataLoader(dataset=ds, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>, drop_last=<span class="hljs-literal">False</span>)<br>                         <span class="hljs-keyword">for</span> ds <span class="hljs-keyword">in</span> [test_datasets, valid_datasets]]<br></code></pre></td></tr></table></figure><h2 id="六、定义损失函数为交叉熵损失，不进行损失值的平均或求和"><a href="#六、定义损失函数为交叉熵损失，不进行损失值的平均或求和" class="headerlink" title="六、定义损失函数为交叉熵损失，不进行损失值的平均或求和"></a>六、定义损失函数为交叉熵损失，不进行损失值的平均或求和</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">loss = nn.CrossEntropyLoss(reduction=<span class="hljs-string">&#x27;none&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="七、定义一个函数-get-net，用于创建并返回一个-ResNet18-50-模型"><a href="#七、定义一个函数-get-net，用于创建并返回一个-ResNet18-50-模型" class="headerlink" title="七、定义一个函数 get_net，用于创建并返回一个 ResNet18&#x2F;50 模型"></a>七、定义一个函数 get_net，用于创建并返回一个 ResNet18&#x2F;50 模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_net</span>():<br>    <span class="hljs-comment"># 使用预训练 ResNet50</span><br>    net = torchvision.models.resnet50(weights=torchvision.models.ResNet50_Weights.IMAGENET1K_V1)<br>    <br>    <span class="hljs-comment"># 修改全连接层（简化结构）</span><br>    net.fc = nn.Sequential(<br>        nn.Dropout(<span class="hljs-number">0.3</span>),<br>        nn.Linear(<span class="hljs-number">2048</span>, num_classes)<br>    )<br>    <br>    <span class="hljs-comment"># 初始化分类层权重</span><br>    nn.init.kaiming_normal_(net.fc[<span class="hljs-number">1</span>].weight, mode=<span class="hljs-string">&#x27;fan_out&#x27;</span>, nonlinearity=<span class="hljs-string">&#x27;relu&#x27;</span>)<br>    nn.init.constant_(net.fc[<span class="hljs-number">1</span>].bias, <span class="hljs-number">0</span>)<br>    <br>    <span class="hljs-keyword">return</span> net<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 修改 get_net() 全连接层，增加特征交互能力</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_net</span>():<br>    net = torchvision.models.resnet50(weights=torchvision.models.ResNet50_Weights.IMAGENET1K_V1)<br>    net.fc = nn.Sequential(<br>        nn.Linear(<span class="hljs-number">2048</span>, <span class="hljs-number">1024</span>),<br>        nn.BatchNorm1d(<span class="hljs-number">1024</span>),<br>        nn.SiLU(),                     <span class="hljs-comment"># 比 ReLU 更平滑</span><br>        nn.Dropout(<span class="hljs-number">0.3</span>),<br>        nn.Linear(<span class="hljs-number">1024</span>, num_classes)<br>    )<br>    <span class="hljs-comment"># 初始化策略</span><br>    nn.init.kaiming_normal_(net.fc[<span class="hljs-number">0</span>].weight, mode=<span class="hljs-string">&#x27;fan_out&#x27;</span>)<br>    nn.init.constant_(net.fc[<span class="hljs-number">0</span>].bias, <span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># 返回创建的模型</span><br>    <span class="hljs-keyword">return</span> net<br></code></pre></td></tr></table></figure><h2 id="八、定义一个函数-train，用于训练模型"><a href="#八、定义一个函数-train，用于训练模型" class="headerlink" title="八、定义一个函数 train，用于训练模型"></a>八、定义一个函数 train，用于训练模型</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">net, train_iter, valid_iter, num_epochs, lr, weight_decay, lr_period, lr_decay, devices</span>):<br>    <span class="hljs-comment"># 定义优化器函数，使用随机梯度下降（SGD）优化器</span><br>    optim = torch.optim.SGD(net.parameters(), lr=lr, momentum=<span class="hljs-number">0.9</span>, weight_decay=weight_decay)<br>    <span class="hljs-comment"># 定义学习率调度器，每隔 lr_period 轮，学习率衰减为 lr * lr_decay</span><br>    <br>    <span class="hljs-comment"># 替换 StepLR 为 CosineAnnealingLR</span><br>    <span class="hljs-comment"># lr_scheduler = torch.optim.lr_scheduler.StepLR(optimizer=optim, step_size=lr_period, gamma=lr_decay)</span><br>    lr_scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(<br>        optimizer=optim,<br>        T_max=num_epochs,  <span class="hljs-comment"># 总训练周期数</span><br>        eta_min=<span class="hljs-number">1e-6</span>  <span class="hljs-comment"># 最小学习率下限</span><br>    )<br><br>    <span class="hljs-comment"># 初始化计时器和训练批次数</span><br>    timer, num_batches = d2l.torch.Timer(), <span class="hljs-built_in">len</span>(train_iter)<br>    <span class="hljs-comment"># 初始化图例，用于绘制训练损失和训练准确率</span><br>    legend = [<span class="hljs-string">&#x27;train loss&#x27;</span>, <span class="hljs-string">&#x27;train acc&#x27;</span>]<br>    <span class="hljs-comment"># 如果有验证集，添加验证准确率到图例中</span><br>    <span class="hljs-keyword">if</span> valid_iter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        legend.append(<span class="hljs-string">&#x27;valid acc&#x27;</span>)<br>    <span class="hljs-comment"># 初始化动画绘制器，用于绘制训练过程中的指标</span><br>    animator = d2l.torch.Animator(xlabel=<span class="hljs-string">&#x27;epoch&#x27;</span>, xlim=[<span class="hljs-number">1</span>, num_epochs],legend=legend)<br>    <br>    <span class="hljs-comment"># 使用 DataParallel 实现多 GPU 并行计算，并将模型移动到主 GPU 上</span><br>    net = nn.DataParallel(module=net, device_ids=devices).to(devices[<span class="hljs-number">0</span>])<br>    <span class="hljs-comment"># 初始化每轮的计时器</span><br>    timer_epoch = d2l.torch.Timer()<br>    <br>    <span class="hljs-comment"># 初始化早停法的参数</span><br>    <span class="hljs-comment"># patience = 5 # 连续5轮没有提升就停止训练</span><br>    <span class="hljs-comment"># min_delta = 0.001  # 验证集精度提升的最小阈值</span><br>    <span class="hljs-comment"># no_improvement_count = 0  # 记录验证集准确率没有提升的轮数</span><br><br>    best_valid_acc = <span class="hljs-number">0.0</span><br><br>    <span class="hljs-comment"># 开始训练循环</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(num_epochs):<br>        timer_epoch.start()  <span class="hljs-comment"># 开始计时当前轮</span><br>        accumulator = d2l.torch.Accumulator(<span class="hljs-number">3</span>)  <span class="hljs-comment"># 初始化累加器，用于累加损失、准确率和样本数</span><br>        net.train()  <span class="hljs-comment"># 将模型设置为训练模式</span><br>        <span class="hljs-comment"># 遍历训练集中的每个批次</span><br>        <span class="hljs-keyword">for</span> i, (X, y) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_iter):<br>            timer.start()  <span class="hljs-comment"># 开始计时当前批次</span><br>            <span class="hljs-comment"># 计算当前批次的损失和准确率</span><br>            batch_loss, batch_acc = d2l.torch.train_batch_ch13(net, X, y, loss, optim, devices)<br>            <span class="hljs-comment"># 累加当前批次的损失、准确率和样本数</span><br>            accumulator.add(batch_loss, batch_acc, y.shape[<span class="hljs-number">0</span>])<br>            timer.stop()  <span class="hljs-comment"># 结束计时当前批次</span><br>            <span class="hljs-comment"># 每隔 (num_batches // 5) 个批次或最后一个批次，更新动画绘制器</span><br>            <span class="hljs-keyword">if</span> i % (num_batches // <span class="hljs-number">5</span>) == <span class="hljs-number">0</span> <span class="hljs-keyword">or</span> i == num_batches - <span class="hljs-number">1</span>:<br>                animator.add(epoch + (i + <span class="hljs-number">1</span>) / num_batches,<br>                             (accumulator[<span class="hljs-number">0</span>] / accumulator[<span class="hljs-number">2</span>], accumulator[<span class="hljs-number">1</span>] / accumulator[<span class="hljs-number">2</span>], <span class="hljs-literal">None</span>))<br>        timer_epoch.stop()  <span class="hljs-comment"># 结束计时当前轮</span><br>        net.<span class="hljs-built_in">eval</span>()  <span class="hljs-comment"># 将模型设置为评估模式，用于验证集</span><br>        <span class="hljs-comment"># 记录当前轮的训练损失和训练准确率</span><br>        measures = <span class="hljs-string">f&#x27;train loss <span class="hljs-subst">&#123;accumulator[<span class="hljs-number">0</span>] / accumulator[<span class="hljs-number">2</span>]&#125;</span>, train acc <span class="hljs-subst">&#123;accumulator[<span class="hljs-number">1</span>] / accumulator[<span class="hljs-number">2</span>]&#125;</span>,\n&#x27;</span><br>        <span class="hljs-comment"># 如果有验证集，计算验证集的准确率并更新动画绘制器</span><br>        <span class="hljs-keyword">if</span> valid_iter <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>            valid_acc = d2l.torch.evaluate_accuracy_gpu(net, valid_iter, devices[<span class="hljs-number">0</span>])<br>            animator.add(epoch + <span class="hljs-number">1</span>, (<span class="hljs-literal">None</span>, <span class="hljs-literal">None</span>, valid_acc))<br>            measures += <span class="hljs-string">f&#x27;valid acc <span class="hljs-subst">&#123;valid_acc&#125;</span>,&#x27;</span><br>            <span class="hljs-comment"># 早停法</span><br>            <span class="hljs-keyword">if</span> valid_acc &gt; best_valid_acc:<br>                best_valid_acc = valid_acc<br>                <span class="hljs-comment"># no_improvement_count = 0</span><br>                torch.save(net.state_dict(), <span class="hljs-string">&#x27;best_model.pth&#x27;</span>)  <span class="hljs-comment"># 保存最佳模型</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Saved the best model at epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span>, valid acc <span class="hljs-subst">&#123;valid_acc:<span class="hljs-number">.3</span>f&#125;</span>&#x27;</span>)<br>            <span class="hljs-comment"># else:</span><br>            <span class="hljs-comment">#     no_improvement_count += 1</span><br>            <span class="hljs-comment">#     if no_improvement_count &gt;= patience:</span><br>            <span class="hljs-comment">#         print(f&#x27;Early stopping at epoch &#123;epoch + 1&#125;&#x27;)</span><br>            <span class="hljs-comment">#         break</span><br>        <span class="hljs-comment"># 更新学习率调度器，判断是否需要进行学习率衰减</span><br>        lr_scheduler.step()<br>    <span class="hljs-comment"># 打印训练过程中的各项指标，包括训练损失、训练准确率、验证准确率、每秒处理的样本数和每轮的平均时间</span><br>    <span class="hljs-built_in">print</span>(<br>        measures + <span class="hljs-string">f&#x27;\n<span class="hljs-subst">&#123;num_epochs * accumulator[<span class="hljs-number">2</span>] / timer.<span class="hljs-built_in">sum</span>()&#125;</span> examples/sec and <span class="hljs-subst">&#123;timer_epoch.avg():<span class="hljs-number">.1</span>f&#125;</span>秒/轮, on <span class="hljs-subst">&#123;<span class="hljs-built_in">str</span>(devices[<span class="hljs-number">0</span>])&#125;</span>&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="九、超参数定义"><a href="#九、超参数定义" class="headerlink" title="九、超参数定义"></a>九、超参数定义</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">lr, weight_decay, epochs = <span class="hljs-number">1e-4</span>, <span class="hljs-number">1e-4</span>, <span class="hljs-number">100</span><br>lr_decay, lr_period, net = <span class="hljs-number">0.5</span>, <span class="hljs-number">10</span>, get_net()<br>devices = d2l.torch.try_all_gpus()<br></code></pre></td></tr></table></figure><h2 id="十、带valid训练"><a href="#十、带valid训练" class="headerlink" title="十、带valid训练"></a>十、带valid训练</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">net.train()<br>train(net, train_iter, valid_iter, epochs, lr, weight_decay, lr_period, lr_decay, devices)<br></code></pre></td></tr></table></figure><h2 id="十一、不带valid训练"><a href="#十一、不带valid训练" class="headerlink" title="十一、不带valid训练"></a>十一、不带valid训练</h2><p>这一部分相当于进行训练完后再使用全部训练集重新训练一遍，检测效果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">net.<span class="hljs-built_in">eval</span>()<br><span class="hljs-comment">#当训练完后，得到合适的超参数，然后重新把之前训练集和验证集合在一起重新进行训练，得到训练好的网络，用于预测</span><br>train(net, train_valid_iter, <span class="hljs-literal">None</span>, epochs, lr, weight_decay, lr_period, lr_decay, devices)<br></code></pre></td></tr></table></figure><h2 id="最后训练好的模型用于测试集"><a href="#最后训练好的模型用于测试集" class="headerlink" title="最后训练好的模型用于测试集"></a>最后训练好的模型用于测试集</h2>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>计算机视觉</tag>
      
      <tag>学生项目</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>深眸慧扫项目</title>
    <link href="/2025/04/24/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%9D%E8%B7%AF/"/>
    <url>/2025/04/24/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%9D%E8%B7%AF/</url>
    
    <content type="html"><![CDATA[<p>水下机器人思路</p><p>规格：15寸左右大小</p><p>定位：小型垃圾打捞</p><p>功能：</p><ul><li>前期主要是线缆连接控制、后期看能否进行遥控设置，分为<strong>AI打捞</strong>和<strong>人工操作打捞</strong></li><li>可视化平台设计</li></ul><p>辅助功能：后期进行初略对水质的检测、和检测地方的3D还原（适用于打捞，考古）</p>]]></content>
    
    
    <categories>
      
      <category>比赛</category>
      
    </categories>
    
    
    <tags>
      
      <tag>学生项目</tag>
      
      <tag>比赛</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Machine Learning</title>
    <link href="/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    <url>/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一 相关概念"></a>一 相关概念</h1><h2 id="1-什么是机器学习"><a href="#1-什么是机器学习" class="headerlink" title="1 什么是机器学习"></a>1 什么是机器学习</h2><p>机器学习定义：让计算机在没有明确编程的情况下学习的研究领域。（从数据中寻找规律、建立关系，根据建立的关系去解决问题的方法，即从数据中学习并实现自我优化与升级）。</p><p>机器学习又分为分类任务、和回归任务。<font color='red'>主要的区别在于分类可以理解为<strong>离散的点</strong>，而<strong>回归任务是连续的线</strong>。</font></p><p>机器学习、深度学习、人工智能的关系</p><blockquote><p>机器学习是实现人工智能的方法，深度学习是一种实现机器学习的技术</p></blockquote><h2 id="2-科学计算库"><a href="#2-科学计算库" class="headerlink" title="2 科学计算库"></a>2 科学计算库</h2><h3 id="2-1-numpy"><a href="#2-1-numpy" class="headerlink" title="2.1 numpy"></a>2.1 numpy</h3><p>概念：NumPy(Numerical Python)是Python的一种开源的数值计算扩展。提供多维数组对象，各种派生对象(如掩码数组和矩阵)，这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表(nested list structure)结构要高效的多(该结构也可以用来表示矩阵(matrix))，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库，包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数基本统计运算和随机模拟等等。</p><blockquote><p>会把其中元素转换成相同的类型。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 02 array数组</span><br>ala_list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>ala_list = np.array(ala_list)<br><span class="hljs-built_in">print</span>(ala_list)<br><br><span class="hljs-comment"># 等差数列</span><br>np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 等比数列</span><br>np.logspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,num=<span class="hljs-number">10</span>, base=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 保存，默认是.npz</span><br>np.save(<span class="hljs-string">&quot;./arr1&quot;</span>, arr1)<br><br>np.load(<span class="hljs-string">&quot;./arr1.npy&quot;</span>)<br><br><span class="hljs-comment"># 保存txt、csv</span><br>np.savetxt(fname=<span class="hljs-string">&quot;./arr1.txt&quot;</span>, X=arr1, delimiter=<span class="hljs-string">&quot;,&quot;</span>, fmt=<span class="hljs-string">&quot;%0.5f&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>array当中数值不是赋值，而是将其地址指向前一个，如果不想影响应当使用copy</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173112436.png" alt="image-20250307152448430" style="zoom: 50%;" /><h3 id="2-2-Pandas"><a href="#2-2-Pandas" class="headerlink" title="2.2 Pandas"></a>2.2 Pandas</h3><blockquote><p>其他正常操作即可，注意merge操作可以合并两个表，同时可以选择按照左边或右边为基准</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.set_option(<span class="hljs-string">&#x27;display.precision&#x27;</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h3 id="2-3-Keras"><a href="#2-3-Keras" class="headerlink" title="2.3 Keras"></a>2.3 Keras</h3><p>​Keras是一个用Python编写的用于神经网络开发的应用接调用开接口可以实现神经网络、卷积神经网络、循环神经网络等常用深度学习算法的开发。Keras为用户提供了一个易于交互的外壳，方便进行深度学习的快速开发。</p><p>特点：</p><blockquote><p>集成了深度学习中各类成熟的算法，容易安装和使用，样例丰富教程和文档也非常详细</p><p>能够以 TensorFlow，或者 Theano 作为后端运行</p></blockquote><p>Keras or Tensorflow：</p><blockquote><p>Tensorflow 是一个采用数据流图，用于数值计算的开源软件库可自动计算模型相关的微分导数：非常适合用于神经网络模型的求解。</p><p>Keras可看作为tensorflow封装后的一个接口（Keras作为前端TensorFlow作为后端）。</p></blockquote><h3 id="2-4-Scikit-learn"><a href="#2-4-Scikit-learn" class="headerlink" title="2.4 Scikit-learn"></a>2.4 Scikit-learn</h3><p>概念：Python语言中专门针对机器学习应用而发展起来的一款开源框架(算法库)，可以实现数据预处理、分类、回归、降维、模型选择等常用的机器学习算法。</p><p>特点：</p><blockquote><p>优点：集成了机器学习中各类成熟的算法，容易安装和使用，样例丰富，教程和文档也非常详细</p><p>缺点：不支持Python之外的语言，不支持深度学习和强化学习</p></blockquote><h2 id="3-专业名词"><a href="#3-专业名词" class="headerlink" title="3 专业名词"></a>3 专业名词</h2><h3 id="3-1-准确率-精度-ACC-precision"><a href="#3-1-准确率-精度-ACC-precision" class="headerlink" title="3.1 准确率(精度)ACC&#x2F;precision"></a>3.1 准确率(精度)ACC&#x2F;precision</h3><p>精度Accuracy是指模型预测正确（包括真正例TP、真反例TN）的样本数与总体样本数的占比。</p><h3 id="3-2-召回率TPR-查全率Recall"><a href="#3-2-召回率TPR-查全率Recall" class="headerlink" title="3.2 召回率TPR&#x2F;查全率Recall"></a>3.2 <strong>召回率</strong>TPR&#x2F;查全率Recall</h3><p>​正样本中，预测正确的比例。<strong><font color = 'red'>召回率高则说明漏检率低</font></strong>，它的一个应用场景便是疾病的检测，因为在在这种情况下我们是希望患病病例（正样本）被尽可能的检测出来，不然漏检的话后果很严重。</p><p>​精确率计算的是<font color='red'><strong>预测对的正样本在整个预测为正样本中的比重</strong></font>，而召回率计算的是<font color='red'><strong>预测对的正样本在整个真实正样本中的比重</strong></font>。因此一般来说，召回率越高也就意味着这个模型找寻正样本的能力越强。</p><h3 id="3-3-特异度TNR"><a href="#3-3-特异度TNR" class="headerlink" title="3.3 特异度TNR"></a>3.3 特异度<strong>TNR</strong></h3><p>负样本中，预测正确的比例。<strong><font color='red'>特异度高则说明误诊率高</font></strong>，它的一个应用场景便是诊断实验确定非患病患者的能力。</p><h3 id="3-4-精确率PPV"><a href="#3-4-精确率PPV" class="headerlink" title="3.4 精确率PPV"></a>3.4 精确率PPV</h3><p>被预测为正样本中有多少是正确的，<font color='red'><strong>精确率高则说明误检率低</strong></font>。召回率是尽可能的把正样本都查找出来，而精确率尽可能地保证预测的正确率。</p><h3 id="3-5-F1分数"><a href="#3-5-F1分数" class="headerlink" title="3.5 F1分数"></a>3.5 F1分数</h3><p>精确率和召回率的调和平均值，<font color='red'><strong>通常值越大越好</strong></font>。</p><p>比如：</p><ul><li>在涉及到严重事故如癌病检测的系统中，我们要注重召回率，越高越好，因为我们不希望有病的人被漏诊；</li><li>而对于垃圾邮箱检测系统来说，我们要注重精确度，越高越好，因为我们宁愿多看一封垃圾邮件，也不能错失一封重要的邮件；</li><li>再举个不太恰当的例子，比如对于刑事诉讼审判系统来说，我国司法机关偏向于高召回率，即天网恢恢疏而不漏绝不放过一个坏人；</li><li>而美国司法偏向于高精确率，即人权大于一切绝不冤枉一个好人；有时候很难说孰是孰非，更合理的做法便是提高F1分数。</li></ul><h3 id="3-6-P-R曲线"><a href="#3-6-P-R曲线" class="headerlink" title="3.6 P-R曲线"></a>3.6 P-R曲线</h3><p>即精确率-召回率曲线，其中横轴是召回率（TPR），纵轴是精确率（PPV）。PR曲线实质上是通过设置不同的阈值，最终将一系列的点汇聚起来连成一条线。我们知道，通过设置不同的阈值我们所划分的正样本或负样本均有所不同，一般来说将大于阈值的样本划分为正样本，而小于当前阈值的样本划分为负样本。需要注意的是，<strong><font color='red'>PR曲线对正负样本的比例异常敏感，即当正负样本的分布发生变化时，PR曲线的形状会发生巨大的变化</font></strong>。</p><h3 id="3-7-Epoch、Batch以及Batch-size"><a href="#3-7-Epoch、Batch以及Batch-size" class="headerlink" title="3.7 Epoch、Batch以及Batch size"></a>3.7 Epoch、Batch以及Batch size</h3><p><strong>Epoch（时期）：</strong></p><p>当一个完整的数据集通过了神经网络一次并且返回了一次，这个过程称为一次epoch。（也就是说，所有训练样本在神经网络中都 进行了一次正向传播 和一次反向传播 ）</p><p>再通俗一点，一个Epoch就是将所有训练样本训练一次的过程。</p><p>然而，当一个Epoch的样本（也就是所有的训练样本）数量可能太过庞大（对于计算机而言），就需要把它分成多个小块，也就是就是分成多个Batch 来进行训练。</p><ul><li><strong>Batch（批 &#x2F; 一批样本）：</strong></li></ul><p>将整个训练样本分成若干个Batch。</p><ul><li><strong>Batch_Size（批大小）：</strong></li></ul><p>每批样本的大小。</p><ul><li><strong>Iteration（一次迭代）：</strong></li></ul><p>训练一个Batch就是一次Iteration（这个概念跟程序语言中的迭代器相似）</p><ul><li><strong>dropout（随机失活）：</strong></li></ul><p>防止模型训练过拟合</p><h3 id="3-7-AP"><a href="#3-7-AP" class="headerlink" title="3.7 AP"></a>3.7 AP</h3><p>AP是PR曲线下面积的近似值，计算方式因任务和数据集标准不同而有所差异。</p><p>计算方法：</p><ul><li>全点插值法（COCO标准）</li><li>11点插值法（PASCAL VOC标准）</li></ul><h3 id="3-8-mAP"><a href="#3-8-mAP" class="headerlink" title="3.8 mAP"></a>3.8 mAP</h3><p>mAP，即平均精度均值，是目标检测任务中常用的性能评估指标。在目标检测中，我们不仅要判断图像中是否存在某个目标，还需要定位目标的位置。因此，评估指标需要综合考虑分类和定位的准确性。<font color='red'><strong>mAP结合了精确率和召回率，能够全面评估模型的性能</strong></font>。</p><h3 id="3-9-交并比IoU"><a href="#3-9-交并比IoU" class="headerlink" title="3.9 交并比IoU"></a>3.9 交并比IoU</h3><p><strong>IoU</strong>度量两个边界之间的重叠，<font color='red'><strong>越大越好</strong></font>。我们使用它来度量我们的预测边界与ground truth(实际对象边界)的重叠程度。</p><h3 id="3-10-均方误差（MSE）"><a href="#3-10-均方误差（MSE）" class="headerlink" title="3.10 均方误差（MSE）"></a>3.10 均方误差（MSE）</h3><p>y’和y的均方误差（MSE）：$MSE&#x3D;\frac{1}{m}\sum\limits_{i&#x3D;1}^{n}(y’{i}-y_{i})^2$</p><p>R方值（$R^2$）：$R^2&#x3D;1-\frac{limits_{i&#x3D;1}^{n}(y’{i}-y_{i})^2}{limits_{i&#x3D;1}^{n}(y’{i}-\overline y_{i})^2} &#x3D; 1 - \frac{MSE}{方差}$</p><blockquote><p>MSE越小越好， ${R^2}$分数越接近1越好</p><p>y’ vs y集中度越高越好（越接近直线分布）</p></blockquote><h3 id="3-11-梯度"><a href="#3-11-梯度" class="headerlink" title="3.11 梯度"></a>3.11 梯度</h3><p>这样几乎就没有梯度信号通过神经元传递到前面层的梯度更新中，因此这时前面层的权值几乎没有更新，这就叫梯度消失。</p><h3 id="3-12-正则化"><a href="#3-12-正则化" class="headerlink" title="3.12 正则化"></a>3.12 正则化</h3><p><strong>正则化（Regularization）</strong> 是一种防止模型过拟合（overfitting）的方法。它通过对模型的损失函数增加额外的约束项，使模型在训练时不会对训练数据“记得太牢”，从而提升在新数据上的泛化能力。</p><h2 id="4-过拟合与欠拟合"><a href="#4-过拟合与欠拟合" class="headerlink" title="4 过拟合与欠拟合"></a>4 过拟合与欠拟合</h2><blockquote><p>模型不合适，导致其无法对数据实现有效预测。</p><p><strong>过拟合</strong>是指模型在训练集上表现很好，但在测试集上表现很差，原因是模型太复杂，学到了训练数据中的“噪声”。</p></blockquote> <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173133619.png" alt="image-20250226163911929" style="zoom:33%;" /><p>原因：</p><blockquote><p>模型结构过于复杂（维度过高）<br>使用了过多属性，模型训练时包含了干扰项信息</p></blockquote><p>解决办法：</p><blockquote><p>简化模型结构（比如线性模型，使用低阶模型）</p><p>数据预处理，保留主成分信息（数据PCA处理）</p><p>在模型训练时，增加正则化项（regularization）</p></blockquote><h2 id="5-数据分离与混淆矩阵"><a href="#5-数据分离与混淆矩阵" class="headerlink" title="5 数据分离与混淆矩阵"></a>5 数据分离与混淆矩阵</h2><p>数据分离：</p><blockquote><p>1、把数据分成两部分：训练集、测试集<br>2、使用训练集数据进行模型训练<br>3、使用测试集数据进行预测，更有效地评估模型对于新数据的预测表现</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173136368.png" alt="image-20250226181038198" style="zoom:33%;" /><p><strong>混淆矩阵：</strong> </p><blockquote><p>概念：又称为误差矩阵、用于衡量分类算法的准确程度。</p><p>●True Positives（TP）：预测准确、实际为正样本的数量（实际为1，预测为1），<font color='red'><strong>真阳性</strong></font></p><p>●True Negatives（TN）：预测准确、实际为负样本的数量（实际为0，预测为0），<font color='red'><strong>真阴性</strong></font></p><p>●False Positives（FP）：预测错误、实际为负样本的数量（实际为0，预测为1），<font color='red'><strong>假阳性</strong></font></p><p>●False Negatives（FN）：预测错误、实际为正样本的数量（实际为1，预测为0），<font color='red'><strong>假阴性</strong></font></p><p>（预测结果正确或错误，预测结果为正样本或负样本）</p><p>指标特点:</p><blockquote><p>分类任务中，相比单一的预测准确率，混淆矩阵提供了更全面的模型评估信息（TP\TN\FP\FN)</p><p>通过混淆矩阵，我们可以计算出多样的模型表现衡量指标，从而更好地选择模型</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173138907.png" alt="image-20250227103857268" style="zoom:33%;" /></blockquote><p>例子：</p><blockquote><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173141940.png" alt="image-20250227124801561" style="zoom:29%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173143884.png" alt="image-20250227103637225" style="zoom: 33%;" /></p></blockquote><h2 id="6-模型优化"><a href="#6-模型优化" class="headerlink" title="6 模型优化"></a>6 模型优化</h2><p>数据的重要性：</p><blockquote><p>检查：</p><p>1、<strong>数据属性的意义</strong>，是否为无关数据（查看是否能做PCA的主成分分析，如果可以就可降维处理）</p><p>2、不同属性数据的<strong>数量级差异性</strong>如何</p><p>3、是否有<strong>异常数据</strong></p><p>4、采集数据的<strong>方法</strong>是否合理，采集到的数据是否有代表性</p><p>5、对于标签结果，<strong>要确保标签判定规则的一致性</strong>（统一标准）</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173147328.png" alt="image-20250227131418824" style="zoom:33%;" /><p>鲁棒性：系统或算法在面临输入错误、环境变化、噪声干扰、参数变化等不确定性和异常情况时，仍能保持其性能和稳定性的能力</p></blockquote><p>模型优化：在确定模型类别后，如何让模型表现更好（三方面：数据、模型核心参数、正则化）</p><blockquote><p>遍历核心参数组合，评估对应模型表现（比如：逻辑回归边界函数考虑多项式、KNN尝试不同的n_neighbors值）<br>扩大数据样本<br>增加或减少数据属性<br>对数据进行降维处理<br>对模型进行正则化处理，调整正则项λ的数值</p></blockquote><h2 id="7-常用激活函数"><a href="#7-常用激活函数" class="headerlink" title="7 常用激活函数"></a>7 常用激活函数</h2><p>​<em>激活函数</em>（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活， 它们将输入信号转换为输出的可微运算。 大多数激活函数都是非线性的。 由于激活函数是深度学习的基础，下面简要介绍一些常见的激活函数。</p><p>​<em>激活函数，并不是去激活什么，而是指如何把”激活的神经元的特征”通过函数把特征保留并映射出来，即*<em>负责将神经元的输入映射到输出端</em></em>。*</p><p>​<strong>为何引入非线性的激活函数？</strong>——如果不用激活函数，在这种情况下每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当，这种情况就是最原始的感知机（Perceptron）了。因此引入非线性函数作为激活函数，这样深层神经网络就有意义了（不再是输入的线性组合，可以逼近任意函数）</p><h3 id="7-1-Relu"><a href="#7-1-Relu" class="headerlink" title="7.1  Relu"></a>7.1  Relu</h3><p>​<em>修正线性单元</em>（Rectified linear unit，<em>ReLU</em>）， 因为它实现简单，同时在各种预测任务中表现良好。 ReLU提供了一种非常简单的非线性变换。</p><p>​公式：<font color='red'>$ReLU(x)&#x3D;max(x, 0)$</font>，当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。 注意，当输入值精确等于0时，ReLU函数不可导。 在此时，我们默认使用左侧的导数，即当输入为0时导数为0。 我们可以忽略这种情况，因为输入可能永远都不会是0。</p><p>​</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173149852.png" alt="image-20250526112919525"></p><p>**引入ReLu的原因？**它求导表现得特别好：要么让参数消失，要么让参数通过。</p><blockquote><p>第一，采用sigmoid等函数，算激活函数时（指数运算），<strong>计算量大</strong>，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用Relu激活函数，整个过程的计算量节省很多。</p><p>第二，对于深层网络，sigmoid函数反向传播时，很容易就会出现<strong>梯度消失</strong>的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失），从而无法完成深层网络的训练。</p><p>第三，ReLu会使一部分神经元的输出为0，这样就造成了<strong>网络的稀疏性</strong>，并且减少了参数的相互依存关系，<strong>缓解了过拟合</strong>问题的发生。</p></blockquote><h3 id="7-2-sigmoid"><a href="#7-2-sigmoid" class="headerlink" title="7.2 sigmoid"></a>7.2 sigmoid</h3><p>​对于一个定义域在R中的输入， <em>sigmoid函数</em>将输入变换为区间(0, 1)上的输出。 因此，sigmoid通常称为<strong><em>挤压函数</em>（squashing function）</strong>： 它将范围（-inf, inf）中的任意输入压缩到区间（0, 1）中的某个值：<font color='red'>$sigmoid(x)&#x3D;\frac{1}{1+e^{-x}}$</font></p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173152122.png" alt="image-20250526114203896"></p><p>​阈值单元在其输入低于某个阈值时取值0，当输入超过阈值时取值1。</p><p><strong>适用范围：</strong></p><blockquote><p>Sigmoid 函数的输出范围是 0 到 1。非常适合作为模型的输出函数用于输出一个0~1范围内的概率值，比如用于表示二分类的类别或者用于表示置信度。梯度平滑，便于求导，也防止模型训练过程中出现突变的梯度</p></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>容易造成梯度消失。我们从导函数图像中了解到sigmoid的导数都是小于0.25的，那么在进行反向传播的时候，梯度相乘结果会慢慢的趋向于0。除此之外，为了防止饱和，必须对于权重矩阵的初始化特别留意。如果初始化权重过大，可能很多神经元得到一个比较小的梯度，致使神经元不能很好的更新权重提前饱和，神经网络就几乎不学习。</li><li>函数输出不是以 0 为中心的，梯度可能就会向特定方向移动，从而降低权重更新的效率</li><li>Sigmoid 函数执行指数运算，计算机运行得较慢，比较消耗计算资源。</li></ul></blockquote><h3 id="7-3-Tanh"><a href="#7-3-Tanh" class="headerlink" title="7.3 Tanh"></a>7.3 Tanh</h3><p>​与sigmoid函数类似， tanh(双曲正切)函数也能将其输入压缩转换到区间(-1, 1)上。 tanh函数的公式如下：</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173157270.png" alt="image-20250526114404948"></p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173154945.png" alt="image-20250526114433659"></p><p><strong>适用范围</strong></p><blockquote><ul><li>tanh 的输出间隔为 1，并且整个函数以 0 为中心，比 sigmoid 函数更好；</li><li>在 tanh 图中，负输入将被强映射为负，而零输入被映射为接近零。</li></ul></blockquote><p><strong>缺点：</strong></p><blockquote><ul><li>仍然存在梯度饱和的问题</li><li>依然进行的是指数运算</li></ul></blockquote><h1 id="二-相关模型"><a href="#二-相关模型" class="headerlink" title="二 相关模型"></a>二 相关模型</h1><h2 id="1-相关技术"><a href="#1-相关技术" class="headerlink" title="1 相关技术"></a>1 相关技术</h2><h3 id="1-组成成分分析PCA"><a href="#1-组成成分分析PCA" class="headerlink" title="1 组成成分分析PCA"></a>1 组成成分分析PCA</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><p>数据降维：</p><blockquote><p>数据降维，是指在某些限定条件下，降低随机变量个数，得到一组”不相关“主变量的过程。<br>作用:</p><blockquote><p>减少模型分析数据量，提升处理效率，降低计算难度;<br>实现数据可视化。</p></blockquote></blockquote><blockquote><p>PCA(principal components analysis)：数据降维技术中，应用最最多的方法</p><p>目标：寻找k(k&lt;6)维新数据，使它们反映事物的主要特征，</p><p>核心：在信息损失尽可能少的情况下，降低数据维度</p><p>如何保留主要信息：投影后的不同特征数据尽可能分得开（即不相关）</p><p>如何实现？使投影后数据的方差最大，因为方差越大数据也越分散</p><p>计算过程:</p><blockquote><p>原始数据预处理（标准化：u&#x3D; 0，σ&#x3D;1)</p><p>计算协方差矩阵特征向量、及数据在各特征向量投影后的方差</p><p>根据需求（任务指定或方差比例）确定降维维度k</p><p>选取k维特征向量，计算数据在其形成空间的投影</p></blockquote></blockquote><p>应用范围：</p><blockquote><ol><li>根据设备上传感器1与2的数据，自动监测设备异常工作状态</li><li>自动寻找图片中异常的目标</li><li>异常消费检测(商业)</li><li>劣质产品检测(工业)</li><li>缺陷基因检测(医疗)</li></ol></blockquote><h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h4><blockquote><p>PCA实战task：<br>1、基于iris_data.csv数据，建立KNN模型实现数据分类（n_neighbors&#x3D;3）<br>2、对数据进行标准化处理，选取一个维度可视化处理后的效果<br>3、进行与原数据等维度PCA，查看各主成分的方差比例<br>4、保留合适的主成分，可视化降维后的数据<br>5、基于降维后数据建立KNN模型，与原数据表现进行对比</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load data</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.read_csv(<span class="hljs-string">&#x27;iris_data.csv&#x27;</span>)<br>data.head()<br><br><span class="hljs-comment"># define the X and y</span><br>X = data.drop([<span class="hljs-string">&#x27;target&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>y = data.loc[:, <span class="hljs-string">&#x27;label&#x27;</span>]<br>y.head()<br><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br>knn = KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>knn.fit(X, y)<br><br>y_pred = knn.predict(X)<br>accuracy_score(y, y_pred)<br><br><span class="hljs-comment"># 数据标准化处理</span><br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><br>X_norm = StandardScaler().fit_transform(X)<br><span class="hljs-built_in">print</span>(X_norm)<br><br><span class="hljs-comment"># calculate the mean and sigma</span><br>x1_mean = X.loc[:, <span class="hljs-string">&#x27;sepal length&#x27;</span>].mean()<br>x1_sigma = X.loc[:, <span class="hljs-string">&#x27;sepal length&#x27;</span>].std()<br><br>x1_norm_mean = X_norm[:, <span class="hljs-number">0</span>].mean()<br>x1_norm_sigma = X_norm[:, <span class="hljs-number">0</span>].std()<br><br><span class="hljs-built_in">print</span>(x1_mean, x1_sigma)<br><span class="hljs-built_in">print</span>(x1_norm_mean, x1_norm_sigma)<br><br><span class="hljs-comment"># 可视化处理</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>fig1 = plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.hist(X.loc[:, <span class="hljs-string">&#x27;sepal length&#x27;</span>], bins=<span class="hljs-number">100</span>)<br><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.hist(X_norm[:, <span class="hljs-number">0</span>], bins=<span class="hljs-number">100</span>)<br>plt.show()<br><br><span class="hljs-comment"># 检测维度</span><br><span class="hljs-built_in">print</span>(X.shape)<br><br><span class="hljs-comment"># PCA calculate</span><br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><br>pca_4 = PCA(n_components=<span class="hljs-number">4</span>)<br>X_PCA_4=pca_4.fit_transform(X_norm)<br><br><span class="hljs-comment"># calculate the variance ratio of each principle components</span><br>var_ratio = pca_4.explained_variance_ratio_<br><span class="hljs-built_in">print</span>(var_ratio)<br><br>fig2 = plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>))<br>plt.bar([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], var_ratio)<br>plt.xticks([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-string">&#x27;PC1&#x27;</span>, <span class="hljs-string">&#x27;PC2&#x27;</span>, <span class="hljs-string">&#x27;PC3&#x27;</span>, <span class="hljs-string">&#x27;PC4&#x27;</span>])<br>plt.xlabel(<span class="hljs-string">&#x27;Principle Components&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Variance Ratio Of each PC&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 降维后的数据可视化</span><br>pca_2 = PCA(n_components=<span class="hljs-number">2</span>)<br>X_PCA_2 = pca_2.fit_transform(X_norm)<br>var_ratio_2 = pca_2.explained_variance_ratio_<br><br><span class="hljs-comment"># 降维后的数据可视化</span><br>fig3 = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br>setosa = plt.scatter(X_norm[:, <span class="hljs-number">0</span>][y == <span class="hljs-number">0</span>], X_norm[:, <span class="hljs-number">1</span>][y == <span class="hljs-number">0</span>])<br>versicolor = plt.scatter(X_norm[:, <span class="hljs-number">0</span>][y == <span class="hljs-number">1</span>], X_norm[:, <span class="hljs-number">1</span>][y == <span class="hljs-number">1</span>])<br>virginica = plt.scatter(X_norm[:, <span class="hljs-number">0</span>][y == <span class="hljs-number">2</span>], X_norm[:, <span class="hljs-number">1</span>][y == <span class="hljs-number">2</span>])<br>plt.legend((setosa, versicolor, virginica), [<span class="hljs-string">&#x27;setosa&#x27;</span>, <span class="hljs-string">&#x27;versicolor&#x27;</span>, <span class="hljs-string">&#x27;virginica&#x27;</span>])<br>plt.show()<br><br><span class="hljs-comment"># 基于降维后数据建立KNN模型</span><br>knn_2 = KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>knn_2.fit(X_PCA_2, y)<br><br>y_pred_2 = knn_2.predict(X_PCA_2)<br><br>accuracy_score(y, y_pred_2)<br><br><br></code></pre></td></tr></table></figure><h3 id="2-Xgboost"><a href="#2-Xgboost" class="headerlink" title="2 Xgboost"></a>2 Xgboost</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>本质上Xgboost还是一种决策树的集成算法</p><h2 id="2-监督式学习"><a href="#2-监督式学习" class="headerlink" title="2 监督式学习"></a>2 监督式学习</h2><h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1 线性回归"></a>1 线性回归</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><p>回归分析：根据数据，确定两种或两种以上变量间相互依赖的定量关系。</p><p>函数表达式：$f(x_{1},x_{2}…x_{n})$</p><p>相关分类：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173200091.png" alt="image-20250220162540776" style="zoom: 25%;" /><p>求解步骤：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173201937.png" alt="image-20250220162721563" style="zoom: 25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173204102.png" alt="image-20250220162826626" style="zoom: 25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173206276.png" alt="image-20250220162927906" style="zoom: 25%;" /><h4 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h4><p><strong>1、使用：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># a、b(y=ax + b)</span><br><span class="hljs-keyword">from</span> sklearn.linear model<br><span class="hljs-keyword">import</span> LinearRegression<br>lr_model=LinearRegression()<br>lr_model.fit(X,y)<br><br><span class="hljs-comment"># 展示a，b</span><br>a = lr_model.coef_<br>b = lr_model.intercept_<br><br><span class="hljs-comment"># 对新数据做预测</span><br>predictions = lr_model.predict(x_new)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算y与y&#x27;的均方误差(MSE)、R方值(R2_score):</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error,r2_socre<br>MSE = mean_squared_error(y, y_predict)<br>R2 =r2_score(y, y_predict)<br><span class="hljs-comment"># 画图对比y 与 y&#x27;可视化模型表现:</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>plt.scatter(y,y<span class="hljs-string">&#x27;)</span><br></code></pre></td></tr></table></figure><p><strong>2、图形展示</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 散点图</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.scatter(x,y)<br><span class="hljs-comment"># 多张图同时展示</span><br><span class="hljs-comment"># 211是将图形分为2行1列，在第1个方块画图</span><br>fig1 = plt.subplot(<span class="hljs-number">211</span>)<br>plt.scatter(x1,y1)<br><span class="hljs-comment"># 212是将图形分为2行1列，在第2个方块画图</span><br>fig2 = plt.subplot(<span class="hljs-number">212</span>)<br>plt.scatter(x2,y2)<br></code></pre></td></tr></table></figure><p>步骤总结：</p><blockquote><ol><li>导入工具包：numpy（数据由1D转换为2D）、pandas（加载数据）、 pyplot（画图）</li><li>读取数据并设计关系图的分布：设计图的大小、多张图同时展示的分布</li><li>训练模型<ul><li>训练数据的赋值，即加载X和y</li><li>X数据由1D转换为2D，np.array(X).reshape(-1,1)</li><li>用X，y加载并训练模型</li></ul></li><li>模型训练好后，再用已有的数据预测，得到预测值</li><li>模型评估<ul><li>sklearn的导入（from sklearn metrics import mean_squared_error，r2_score）</li><li>使用数据</li></ul></li><li>画图呈现，plt.plot（X, y_predict, ‘r’）</li></ol></blockquote><h3 id="2-逻辑回归"><a href="#2-逻辑回归" class="headerlink" title="2 逻辑回归"></a>2 逻辑回归</h3><h4 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><p>分类：根据已知样本的某些特征，判断新的样本属于哪种已知的样本类。</p><p>基本框架：$f(x)&#x3D;\left{ \begin{aligned}y&#x3D; f(x_{1},x_{2}…x_{n}) \ 判断为类别N，如果y &#x3D; n\end{aligned} \right. $</p><p>分类方法：逻辑回归、KNN近邻模型、决策树、神经网络。</p><blockquote><p>逻辑回归：用于解决分类问题的一种模型。根据数据特征或属性，计算其归属于某一类别的概率$P(X)$根据概率数值判断其所属类别。</p><p>主要应用场景：二分类问题。</p></blockquote><blockquote><p>逻辑公式（sigmoid）：$P(x)&#x3D;\frac{1}{1+e^{-g(x)}}$， g(x) &#x3D; $\Theta_{0}+\Theta_{1}X_{1}+….$</p><p>   $y&#x3D;\left{ \begin{aligned}1, P(x)≥ 0.5 \ 1, P(x)＜ 0.5\end{aligned} \right. $，其中y为类别结果，P为概率分布函数，x为特征值</p></blockquote><blockquote><p>最小损失函数$J$：</p><p>​                                                                                      $y&#x3D;\left{ \begin{aligned}-log{P(x_{i})}, ify_{i}&#x3D;1 \ -log(1-P(x_{i})), ify_{i}&#x3D;0\end{aligned} \right. $</p><p>化简后：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173210864.png" alt="image-20250221154950824" style="zoom: 33%;" /><p>求解：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173214507.png" alt="image-20250221155835458" style="zoom:33%;" /></blockquote><blockquote><p>sigmoid函数是指一种激活函数，该函数将输入值映射到(0,1)区间，常用于分类问题，尤其是二分类问题中作为逻辑回归的分类器。<strong>它的输出范围有限，优化稳定，便于求导，但存在梯度消失问题</strong>，即在输入值远离原点时，其导数接近于0，导致反向传播时权重更新缓慢。sigmoid函数在早期的神经网络中广泛使用，但随着ReLU等激活函数的出现，其在深层网络中的应用逐渐减少</p></blockquote><h4 id="2-2-实现步骤"><a href="#2-2-实现步骤" class="headerlink" title="2.2 实现步骤"></a>2.2 实现步骤</h4><blockquote><ol><li><p>导入工具包：numpy（数据由1D转换为2D）、pandas（加载数据）、 pyplot（画图）</p></li><li><p>读取数据</p></li><li><p>分类散点图及可视化</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加标签，区分散点图</span><br>mask = data.loc[:,<span class="hljs-string">&#x27;Pass&#x27;</span>] == <span class="hljs-number">1</span><br><br>fig2 = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>passed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][mask])<br>failed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][~mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][~mask], marker=<span class="hljs-string">&#x27;^&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Exam1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Exam2&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Exam1 - Exam2&#x27;</span>)<br>plt.legend(handles=[passed, failed], labels=[<span class="hljs-string">&#x27;Passed&#x27;</span>, <span class="hljs-string">&#x27;Failed&#x27;</span>])<br>plt.show()<br></code></pre></td></tr></table></figure></li><li><p>整理数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = data.drop([<span class="hljs-string">&#x27;Pass&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>y = data.loc[:,<span class="hljs-string">&#x27;Pass&#x27;</span>]<br>X1 = X.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>].sort_values()<br>X2 = X.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>]<br>y.head()<br></code></pre></td></tr></table></figure></li><li><p>训练模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 整理数据集</span><br>X = data.drop([<span class="hljs-string">&#x27;Pass&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>y = data.loc[:,<span class="hljs-string">&#x27;Pass&#x27;</span>]<br>X1 = X.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>].sort_values()<br>X2 = X.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>]<br>y.head()<br><br><span class="hljs-comment"># 导入模型并训练</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br>LR = LogisticRegression()<br>LR.fit(X, y)<br><br></code></pre></td></tr></table></figure></li><li><p>模型训练好后，再用已有的数据预测，得到新数据集</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预测结果展示</span><br>y_predict = LR.predict(X)<br><span class="hljs-built_in">print</span>(y_predict)<br></code></pre></td></tr></table></figure></li><li><p>模型评估</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型性能准确率评估</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br>accuracy = accuracy_score(y, y_predict)<br><span class="hljs-built_in">print</span>(accuracy)<br></code></pre></td></tr></table></figure></li><li><p>拿到公式</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拿到公式</span><br>Theta0 = LR.intercept_<br>Theta1,Theta2 = LR.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], LR.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(Theta0, Theta1, Theta2)<br>                                                                                                                                                                                                                                                <br>X2_new = -(Theta0 + Theta1 * X1) / Theta2<br>X2_new.head()<br></code></pre></td></tr></table></figure></li><li><p>使用数据画图呈现，plt.plot（X, y_predict, ‘r’）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">fig3 = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>passed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][mask])<br>failed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][~mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][~mask], marker=<span class="hljs-string">&#x27;^&#x27;</span>)<br>plt.plot(X1, X2_new)<br>plt.xlabel(<span class="hljs-string">&#x27;Exam1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Exam2&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Exam1 - Exam2&#x27;</span>)<br>plt.legend(handles=[passed, failed], labels=[<span class="hljs-string">&#x27;Passed&#x27;</span>, <span class="hljs-string">&#x27;Failed&#x27;</span>])<br></code></pre></td></tr></table></figure></li></ol></blockquote><p>二阶边界模型</p><blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 训练二阶边界模型</span><br>&gt;LR2 = LogisticRegression()<br>&gt;LR2.fit(X_new_dict, y)<br><br>&gt;<span class="hljs-comment"># 模型预测</span><br>&gt;y2_predict = LR2.predict(X_new_dict)<br><br>&gt;<span class="hljs-comment"># 模型评估</span><br>&gt;accuracy2 =  accuracy_score(y, y2_predict)<br>&gt;<span class="hljs-built_in">print</span>(accuracy2)<br><br>&gt;<span class="hljs-comment"># 计算公式</span><br>&gt;<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>&gt;Theta0 = LR2.intercept_<br>&gt;Theta1, Theta2, Theta3, Theta4, Theta5 = LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>], LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>],LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>]<br>&gt;<span class="hljs-built_in">print</span>(Theta0, Theta1, Theta2, Theta3, Theta4, Theta5)<br>&gt;a = Theta4<br>&gt;b = Theta5 * X1 + Theta2<br>&gt;c = Theta0 + Theta1 * X1 + Theta3 * X1 ** <span class="hljs-number">2</span><br><br>&gt;X2_new_boundary = (-b + np.sqrt(b ** <span class="hljs-number">2</span> - <span class="hljs-number">4</span> * a * c)) / (<span class="hljs-number">2</span> * a)<br><br>&gt;<span class="hljs-comment"># 画图呈现</span><br>&gt;fig4 = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>&gt;passed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][mask])<br>&gt;failed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][~mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][~mask], marker=<span class="hljs-string">&#x27;^&#x27;</span>)<br><br>&gt;plt.plot(X1, X2_new_boundary)<br>&gt;plt.xlabel(<span class="hljs-string">&#x27;Exam1&#x27;</span>)<br>&gt;plt.ylabel(<span class="hljs-string">&#x27;Exam2&#x27;</span>)<br>&gt;plt.title(<span class="hljs-string">&#x27;Exam1 - Exam2&#x27;</span>)<br>&gt;plt.legend(handles=[passed, failed], labels=[<span class="hljs-string">&#x27;Passed&#x27;</span>, <span class="hljs-string">&#x27;Failed&#x27;</span>])<br><br>&gt;plt.show()<br></code></pre></td></tr></table></figure></blockquote><h3 id="3-决策树"><a href="#3-决策树" class="headerlink" title="3 决策树"></a>3 决策树</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173444935.png" alt="image-20250223100806340" style="zoom: 25%;" /><blockquote><p>决策树（Decision Tree）：一种有监督对实例进行<strong>分类</strong>的<strong>树形结构</strong>，通过<strong>多层判断</strong>区分目标所属类别</p><p>本质：通过多层判断，从训练数据集中归纳出一组分类规则。</p><p>优点：</p><blockquote><p>计算量小，运算速度快<br>易于理解，可清晰查看各属性的重要性</p></blockquote><p>缺点：</p><blockquote><p>忽略属性间的相关性<br>样本类别分布不均匀时，容易影响模型表现</p></blockquote><p>求解：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173447212.png" alt="image-20250223101640079" style="zoom:33%;" /><p>三种求解方法：ID3、C4.5、CART</p><blockquote><p>ID3：利用<strong>信息嫡</strong>原理选择<strong>信息增益最大</strong>的属性作为<strong>分类属性</strong>，递归地拓展决策树的分枝，完成决策树的构造</p></blockquote><p>信息熵：</p><blockquote><p>信息嫡（entropy）是度量随机变量不确定性的指标，商越大，变量的不确定性就越大。假定当前样本集合D中第k类样本所占的比例为$P_{k}$，亦则D的信息嫡为：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173449480.png" alt="image-20250223102538613" style="zoom:33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173451723.png" alt="image-20250223102609805" style="zoom:33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173453700.png" alt="image-20250223102802335" style="zoom: 25%;" /></blockquote></blockquote><p>举例：</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173456308.png" alt="image-20250223103308740" style="zoom: 25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173458148.png" alt="image-20250223103418760" style="zoom:25%;" /></blockquote><h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2 代码实现"></a>2 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load the data</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = pd.read_csv(<span class="hljs-string">&#x27;iris_data.csv&#x27;</span>)<br>data.head()<br><br><span class="hljs-comment">#define the X and y</span><br>X = data.drop([<span class="hljs-string">&#x27;target&#x27;</span>,<span class="hljs-string">&#x27;label&#x27;</span>],axis=<span class="hljs-number">1</span>)<br>y = data.loc[:,<span class="hljs-string">&#x27;label&#x27;</span>]<br><span class="hljs-built_in">print</span>(X.shape,y.shape)<br><br><span class="hljs-comment">#establish the decision tree model</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br>dc_tree = tree.DecisionTreeClassifier(criterion=<span class="hljs-string">&#x27;entropy&#x27;</span>,min_samples_leaf=<span class="hljs-number">5</span>)<br>dc_tree.fit(X,y)<br><br><span class="hljs-comment">#evaluate the model</span><br>y_predict = dc_tree.predict(X)<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br>accuracy = accuracy_score(y,y_predict)<br><span class="hljs-built_in">print</span>(accuracy)<br><br><span class="hljs-comment">#visualize the tree</span><br>%matplotlib inline<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>fig = plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>))<br>tree.plot_tree(dc_tree,filled=<span class="hljs-string">&#x27;True&#x27;</span>,feature_names=[<span class="hljs-string">&#x27;SepalLength&#x27;</span>, <span class="hljs-string">&#x27;SepalWidth&#x27;</span>, <span class="hljs-string">&#x27;PetalLength&#x27;</span>, <span class="hljs-string">&#x27;PetalWidth&#x27;</span>],class_names=[<span class="hljs-string">&#x27;setosa&#x27;</span>,<span class="hljs-string">&#x27;versicolor&#x27;</span>,<span class="hljs-string">&#x27;virginica&#x27;</span>])<br><br>dc_tree = tree.DecisionTreeClassifier(criterion=<span class="hljs-string">&#x27;entropy&#x27;</span>,min_samples_leaf=<span class="hljs-number">10</span>)<br>dc_tree.fit(X,y)<br>fig = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>tree.plot_tree(dc_tree,filled=<span class="hljs-string">&#x27;True&#x27;</span>,feature_names=[<span class="hljs-string">&#x27;SepalLength&#x27;</span>, <span class="hljs-string">&#x27;SepalWidth&#x27;</span>, <span class="hljs-string">&#x27;PetalLength&#x27;</span>, <span class="hljs-string">&#x27;PetalWidth&#x27;</span>],class_names=[<span class="hljs-string">&#x27;setosa&#x27;</span>,<span class="hljs-string">&#x27;versicolor&#x27;</span>,<span class="hljs-string">&#x27;virginica&#x27;</span>])<br><br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br>font2 = &#123;<span class="hljs-string">&#x27;family&#x27;</span> : <span class="hljs-string">&#x27;SimHei&#x27;</span>,<br><span class="hljs-string">&#x27;weight&#x27;</span> : <span class="hljs-string">&#x27;normal&#x27;</span>,<br><span class="hljs-string">&#x27;size&#x27;</span>   : <span class="hljs-number">20</span>,<br>&#125;<br>mpl.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = <span class="hljs-string">&#x27;SimHei&#x27;</span><br>mpl.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><br><br>fig = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>tree.plot_tree(dc_tree,filled=<span class="hljs-string">&#x27;True&#x27;</span>,feature_names=[<span class="hljs-string">&#x27;花萼长&#x27;</span>, <span class="hljs-string">&#x27;花萼宽&#x27;</span>, <span class="hljs-string">&#x27;花瓣长&#x27;</span>, <span class="hljs-string">&#x27;花瓣宽&#x27;</span>],class_names=[<span class="hljs-string">&#x27;setosa&#x27;</span>,<span class="hljs-string">&#x27;versicolor&#x27;</span>,<span class="hljs-string">&#x27;virginica&#x27;</span>])<br><br>fig.savefig(<span class="hljs-string">&#x27;test.png&#x27;</span>)<br></code></pre></td></tr></table></figure><h2 id="3-无监督学习"><a href="#3-无监督学习" class="headerlink" title="3 无监督学习"></a>3 无监督学习</h2><p>机器学习的一种方法，没有给定事先标记过的训练示例，自动对输入的数据进行分类或分群。</p><blockquote><p>优点：算法不受监督信息（偏见）的约束，可能考虑到新的信息&gt;A不需要标签数据，极大程度扩大数据样本。</p><p><strong>主要应用</strong>：聚类分析（应用最广）、关联规则、维度缩减。</p><p><font color = 'red'>聚类分析</font>概念：聚类分析又称为群分析，根据对象某些属性的相似度)将其自动化分为不同的类别。</p></blockquote><h3 id="1-K-Means聚类"><a href="#1-K-Means聚类" class="headerlink" title="1 K-Means聚类"></a>1 K-Means聚类</h3><h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><blockquote><p><strong>K-Means</strong>：以空间揪个点为中心进行聚类，对最靠近他们的对象归类，是聚类算法中最为基础但也最为重要的算法。</p><p><strong>特点</strong>：根据数据与中心点距离划分类别；基于类别数据更新中心点；重复过程直到收敛。</p><p><strong>优点</strong>：原理简单、实现容易、收敛快；参数少，方便使用</p><p><strong>缺点</strong>：必须设置簇的数量；随机选择初始类聚中心，结果可能缺乏一致性</p></blockquote><p><strong>公式：</strong></p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173220658.png" alt="image-20250222135853451" style="zoom: 33%;" /><p><strong>算法流程：</strong></p><blockquote><p>1、选择聚类的个数k</p><p>2、确定聚类中心</p><p>3、根据点到聚类中心聚类确定各个点所属类别</p><p>4、根据各个类别数据更新聚类中心</p><p>5、重复以上步骤直到收敛（中心点不再变化）</p></blockquote><h4 id="1-2-KNN和K-Means区别"><a href="#1-2-KNN和K-Means区别" class="headerlink" title="1.2 KNN和K-Means区别"></a><strong>1.2 KNN和K-Means区别</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173222815.png" alt="image-20250222140608621" style="zoom: 25%;" /><blockquote><p>KNN概念：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例（也就是上面所说的K个邻居），这K个实例的多数属于某个类，就把该输入实例分类到这个类中最简单的机器学习算法之一</p></blockquote><p>KNN代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>KNN = KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>KNN.fit(X,y)<br></code></pre></td></tr></table></figure><h4 id="1-3-实现代码"><a href="#1-3-实现代码" class="headerlink" title="1.3 实现代码"></a>1.3 实现代码</h4><div align=center><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173250584.png" alt="image-20250222150421856" style="zoom: 33%;" align=center/><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173252821.png" alt="image-20250222150508887" style="zoom:33%;" align=center/></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br><span class="hljs-keyword">from</span> sklearn.cluster imyport KMeans<br>KM= KMeans(n_clusters=<span class="hljs-number">3</span>,random _state = <span class="hljs-number">0</span>)<br>KM.fit(X)<br><br><span class="hljs-comment"># 获取模型确定的中心点:</span><br>center=KM.cluster centers<br><span class="hljs-comment"># 准确率计算:from sklearn.metrics import accuracy_score</span><br>accuracy= accuracy_score(y,y predict)<br><br><span class="hljs-comment"># 结果矫正:</span><br>y_cal = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> y predict:<br><span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>        y _cal.append(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">elif</span> i == <span class="hljs-number">1</span>:<br>        y_cal.append(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        y_cal.append(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(y predict,y_cal)<br><br></code></pre></td></tr></table></figure><h3 id="2-Meanshift聚类"><a href="#2-Meanshift聚类" class="headerlink" title="2 Meanshift聚类"></a>2 Meanshift聚类</h3><h4 id="2-1-基本概念-1"><a href="#2-1-基本概念-1" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><blockquote><p>均值漂移聚类：一种基于密度梯度上升的聚类算法（沿着密度上升方向寻找聚类中心点）</p><p>特点：</p><p>​1、自动发现类别数量，不需要人工选择</p><p>​2、需要选择区域平径</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173304951.png" alt="image-20250222145120555" style="zoom:33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173306925.png" alt="image-20250222145330994" style="zoom: 25%;" /><h4 id="2-2-实现代码"><a href="#2-2-实现代码" class="headerlink" title="2.2 实现代码"></a>2.2 实现代码</h4><div align=center><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173424668.png" alt="image-20250222152712702" style="zoom: 33%;" />    <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173427153.png" alt="1740209314376" style="zoom:33%;" /></div><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#自动计算带宽(区域半径)</span><br><span class="hljs-keyword">from</span> sklearn.cluster importMeanShift,estimate bandwidth<br><span class="hljs-comment">#detect bandwidth</span><br>bandwidth =estimate_bandwidth(X,n_samples=<span class="hljs-number">500</span>)<br><br><span class="hljs-comment"># 模型建立和训练</span><br>ms = MeanShit(bandwidth = bandwidth)<br>ms.fit(X)<br></code></pre></td></tr></table></figure><p>小结：</p><blockquote><p>kmeans和meanshift  -&gt;  un-supervised -&gt; training data: X</p><p>KNN -&gt;  supervised -&gt; training data: X, y</p><p>kmeans-&gt; category number</p><p>meanshift-&gt; calculate the bandwidth</p></blockquote><h3 id="3-DBSCAN算法"><a href="#3-DBSCAN算法" class="headerlink" title="3 DBSCAN算法"></a>3 DBSCAN算法</h3><blockquote><p>基于密度的空间聚类算法：基于区域点密度筛选有效数据基于有效数据向周边扩张，直到没有新点加入</p><p>特点：</p><p>​1、过滤噪音数据</p><p>​2、不需要人为选择类别数量</p><p>​3、数据密度不同时影响结果</p></blockquote><h3 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h3><h4 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173501671.png" alt="image-20250223104827763" style="zoom:25%;" /><p>概率密度：</p><blockquote><p>概率密度函数是一个描述随机变量在某个确定的取值点附近的可能性的函数</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173503771.png" alt="image-20250223105146766" style="zoom:25%;" /></blockquote><p>高斯分布：</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173505724.png" alt="image-20250223105321284" style="zoom:25%;" /></blockquote><p>如果高斯分布是高维度的：</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173508080.png" alt="image-20250223152029725" style="zoom:50%;" /><p>1、计算每个维度下数据均值$u_{1},u_{2}…u_{n}$，标准差$σ_{1},σ_{n}…σ_{n}$</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173509832.png" alt="image-20250223152101090" style="zoom:33%;" /></blockquote><p>2、计算概率密度函数$P(X)$</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173511858.png" alt="image-20250223152216754" style="zoom:33%;" /></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173513801.png" alt="image-20250223153137556" style="zoom: 25%;" /></blockquote><h4 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h4><blockquote><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">异常检测实战task：<br>1、基于 anomaly_data.csv数据，可视化数据分布情况、及其对应高斯分布的概率密度函数<br>2、建立模型，实现异常数据点预测<br>3、可视化异常检测处理结果<br>4、修改概率分布阈值EllipticEnvelope(<span class="hljs-attribute">contamination</span>=0.1)中的contamination，查看阈值改变对结果的影响<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#load the data</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.read_csv(<span class="hljs-string">&#x27;anomaly_data.csv&#x27;</span>)<br>data.head()<br><br><span class="hljs-comment"># visualize the data</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(figsize=(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>))<br>plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>])<br>plt.title(<span class="hljs-string">&quot;Anomaly Data&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;x1&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;x2&quot;</span>)<br>plt.show()<br><br><span class="hljs-comment"># define the x1 and x2</span><br>x1 = data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>]<br>x2 = data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>]<br><br>fig2 =  plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.hist(x1, bins=<span class="hljs-number">100</span>, alpha=<span class="hljs-number">0.5</span>, label=<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;x1 distribution&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;count&#x27;</span>)<br><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.hist(x2, bins=<span class="hljs-number">100</span>, alpha=<span class="hljs-number">0.5</span>, label=<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;x2 distribution&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;count&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># calculate the mean and sigma of x1 and x2</span><br>x1_mean = x1.mean()<br>x1_sigma = x1.std()<br>x2_mean = x2.mean()<br>x2_sigma = x2.std()<br><span class="hljs-built_in">print</span>(x1_mean, x1_sigma, x2_mean, x2_sigma)<br><br><span class="hljs-comment"># calculate the gaussian distribution p(x)</span><br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> norm<br><br>x1_range = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">300</span>)<br>x2_range = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">300</span>)<br>x1_normal = norm.pdf(x1_range, loc=x1_mean, scale=x1_sigma)<br>x2_normal = norm.pdf(x2_range, loc=x2_mean, scale=x2_sigma)<br><span class="hljs-built_in">print</span>(x1_range)<br><br><span class="hljs-comment"># visualize the gaussian distribution</span><br>fig3 = plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.plot(x1_range, x1_normal)<br>plt.title(<span class="hljs-string">&#x27;normal P(x1)&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;p(x1)&#x27;</span>)<br><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.plot(x2_range, x2_normal)<br>plt.title(<span class="hljs-string">&#x27;normal P(x2)&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;p(x2)&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># establish the model and predict</span><br><span class="hljs-keyword">from</span> sklearn.covariance <span class="hljs-keyword">import</span> EllipticEnvelope<br><br>ad_model = EllipticEnvelope()<br>ad_model.fit(data)<br><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>y_pred = ad_model.predict(data)<br><span class="hljs-built_in">print</span>(pd.value_counts(y_pred))<br><br><span class="hljs-comment"># visualize the result</span><br>f4 = plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">8</span>))<br>orange_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>], marker=<span class="hljs-string">&#x27;x&#x27;</span>)<br>anomaly_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>, facecolor=<span class="hljs-string">&#x27;none&#x27;</span>,<br>            edgecolor=<span class="hljs-string">&#x27;red&#x27;</span>,s=<span class="hljs-number">120</span>)<br>plt.title(<span class="hljs-string">&#x27;Anomaly Data&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.legend([orange_data, anomaly_data], [<span class="hljs-string">&#x27;orange data&#x27;</span>, <span class="hljs-string">&#x27;anomaly data&#x27;</span>])<br><br>plt.show()<br><br><span class="hljs-comment"># 修改概率分布阈值EllipticEnvelope(contamination=0.1)中的contamination，查看阈值改变对结果的影响</span><br><span class="hljs-keyword">from</span> sklearn.covariance <span class="hljs-keyword">import</span> EllipticEnvelope<br><br>ad_model = EllipticEnvelope(contamination=<span class="hljs-number">0.02</span>)<br>ad_model.fit(data)<br>y_pred = ad_model.predict(data)<br><br>f5 = plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">8</span>))<br>orange_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>], marker=<span class="hljs-string">&#x27;x&#x27;</span>)<br>anomaly_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>,<br>                           facecolor=<span class="hljs-string">&#x27;none&#x27;</span>,<br>                           edgecolor=<span class="hljs-string">&#x27;red&#x27;</span>, s=<span class="hljs-number">120</span>)<br>plt.title(<span class="hljs-string">&#x27;Anomaly Data&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.legend([orange_data, anomaly_data], [<span class="hljs-string">&#x27;orange data&#x27;</span>, <span class="hljs-string">&#x27;anomaly data&#x27;</span>])<br><br>plt.show()<br><br></code></pre></td></tr></table></figure><h2 id="4-半监督学习"><a href="#4-半监督学习" class="headerlink" title="4 半监督学习"></a>4 半监督学习</h2><p>监督学习与无监督学习相结合的一种学习方法，它同时利用有标记样本与无标记样本进行学习。</p><p><strong>目的</strong>：在标记样本有限的情况下，尽可能识别出总样本的共同特性。</p><p><strong>英文</strong>：Semi-Supervised Learning</p><p><strong>伪标签学习</strong>：用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，产生伪标签(pseudo label)，按一定规则挑选出认为分类正确的无标签样本，将其与有标签样本作为数据对分类器进行训练。</p><p><strong>核心</strong>：想办法利用标签数据提供的正确信息，灵活运用于模型中。</p><h1 id="三-PyTorch框架"><a href="#三-PyTorch框架" class="headerlink" title="三 PyTorch框架"></a>三 PyTorch框架</h1><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173043878.png" alt="image-20250322161937108" style="zoom: 33%;" /><p>首先是确定自己的显卡算力版本，我现在是NVIDIA GeForce GTX 1660 Ti（现在刚买了5070）</p><pre><code class="hljs">驱动程序版本:31.0.15.1601驱动程序日期:2022/4/24DirectX 版本:12 (FL 12.1)物理位置：PCI 总线 1、设备 0、功能 0利用率0%专用 GPU 内存0.0/6.0 GB共享 GPU 内存0.0/7.9 GBGPU 内存0.0/13.9 GB</code></pre><p>然后通过命令查看自己<strong>显卡驱动-cuda driver version</strong>的版本号：nvidia-smi</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173049917.png" alt="image-20250322105502383" style="zoom: 50%;" /><p>然后去官网查看自己的<strong>cuda-runtime version</strong>版本：<a href="https://en.wikipedia.org/wiki/CUDA">CUDA - Wikipedia</a></p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173051862.png" alt="image-20250322162928412" style="zoom: 50%;" /><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173054487.png" alt="image-20250322163013307"></p><p>由此可见我是算力是7.5，支持的cuda-runtime version版本7.5往上的版本均可，为了不造成cuda-runtime version版本过高导致不必要的错误</p><p><strong>切记是cuda版本一定要低于硬件11.7的版本！！！</strong></p><p><strong>切记是cuda版本一定要低于硬件11.7的版本！！！</strong></p><p><strong>切记是cuda版本一定要低于硬件11.7的版本！！！</strong></p><h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p><strong>装这个版本：Anaconda3-2024.02-1-Windows-x86_64.exe！！！</strong></p><p><strong>装这个版本：Anaconda3-2024.02-1-Windows-x86_64.exe！！！</strong></p><p><strong>装这个版本：Anaconda3-2024.02-1-Windows-x86_64.exe！！！</strong></p><p>利用pip install 或者conda安装</p><ol><li><p>再anaconda创建一个虚拟环境(比如叫 pytorch)</p><ul><li><p>利用 conda create 指令创建新的虚拟环境</p><blockquote><p>conda create -n 虚拟环境名字 python&#x3D;版本 </p><p>conda create -n pytorch python&#x3D;3.9</p></blockquote></li><li><p>添加镜像加速</p><blockquote><p>conda create -n 虚拟环境名字 python&#x3D;版本 -c 镜像地址</p></blockquote><p>相关镜像</p><blockquote><p>清华镜像：<a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a></p><p>北京外国语大学镜像：<a href="https://mirrors.bfsu.edu.cn/anaconda/pkgs/main">https://mirrors.bfsu.edu.cn/anaconda/pkgs/main</a><br>阿里巴巴镜像：<a href="http://mirrors.aliyun.com/anaconda/pkgs/main">http://mirrors.aliyun.com/anaconda/pkgs/main</a></p></blockquote></li><li><p>删除虚拟环境：</p><blockquote><p>conda remove -n 虚拟环境名字 –all</p></blockquote></li><li><p>如何查看配置文件中有哪些通道？</p><blockquote><p>conda config –get</p><p>conda config –show</p></blockquote></li><li><p>持久添加通道：</p><blockquote><p>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</a><br>conda config –add channels <a href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>conda config –set show_channel_urls yes</p></blockquote></li><li><p>删除通道：</p><blockquote><p>conda config –remove channels 通道地址</p></blockquote></li><li><p>清理缓存：</p><blockquote><p><strong>conda clean –all</strong></p></blockquote></li><li><p>所有镜像</p><blockquote><p>conda env list</p></blockquote></li></ul></li><li><p>我选择CUDA11.3（最稳定），官网安装：</p></li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># CUDA 11.3</span><br><span class="hljs-attribute">conda</span> install pytorch torchvision torchaudio cudatoolkit=<span class="hljs-number">11</span>.<span class="hljs-number">3</span> -c pytorch<br><br><span class="hljs-comment"># CUDA 11.7</span><br><span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">14</span>.<span class="hljs-number">0</span> torchaudio==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span> pytorch-cuda=<span class="hljs-number">11</span>.<span class="hljs-number">7</span> -c pytorch -c nvidia<br><br><span class="hljs-comment"># CUDA 12.4</span><br><span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">20</span>.<span class="hljs-number">1</span> torchaudio==<span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span> pytorch-cuda=<span class="hljs-number">12</span>.<span class="hljs-number">4</span> -c pytorch -c nvidia<br></code></pre></td></tr></table></figure><p>或者方法二：<a href="https://download.pytorch.org/whl/torch_stable.html">download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</a></p><p>直接到对应包连接下载</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173108822.png" alt="image-20250327153117089" style="zoom: 33%;" /><p>放在Scripts目录下pip install “torch-1.10.0+cu113-cp36-cp36m-win_amd64.whl”即可</p><ol start="3"><li>激活对应的虚拟环境(你安装Pytorch的虚拟环境)</li></ol><figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1.</span> conda activate 虚拟环境名<br><span class="hljs-number">2.</span> 输入conda list，看有没有pytorch或者torch<br>python<br><span class="hljs-keyword">import</span> torch<br>torch.cuda.is_available()<br><span class="hljs-number">3.</span> 如果显示<span class="hljs-literal">True</span>，就说明我们这个PyTorch安装成功了<br></code></pre></td></tr></table></figure><ol start="4"><li>测试cudnn</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">python<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-built_in">print</span>(torch.backends.cudnn.version())<br><span class="hljs-comment">#能够正确返回8200</span><br><span class="hljs-keyword">from</span> torch.backends <span class="hljs-keyword">import</span> cudnn <span class="hljs-comment"># 若正常则静默</span><br>cudnn.is_available() <br><span class="hljs-comment"># 若正常返回True</span><br>a=torch.tensor(<span class="hljs-number">1.</span>)<br>cudnn.is_acceptable(a.cuda())<br><span class="hljs-comment"># 若正常返回True</span><br></code></pre></td></tr></table></figure><h2 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2 基本介绍"></a>2 基本介绍</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>PyTorch 是一种用于构建深度学习模型的功能完备框架，是一种通常用于图像识别和语言处理等应用程序的机器学习。使用 Python 编写，因此对于大多数机器学习开发者而言，学习和使用起来相对简单。PyTorch 的独特之处在于，它完全支持 GPU，并且使用<strong>反向模式自动微分技术计算梯度</strong>，因此可以动态修改计算图形。这使其成为快速实验和原型设计的常用选择</p><h3 id="2-2-相关库简介"><a href="#2-2-相关库简介" class="headerlink" title="2.2 相关库简介"></a>2.2 相关库简介</h3><blockquote><p>**torchvision：**内置了常用的数据集和常见的模型</p></blockquote><blockquote><p>**transforms：**用来做数据增强，数据预处理等功能</p><p>transforms.ToTensor()：</p><ol><li><p>将图片转换为Tensor</p></li><li><p>将图片的像素值从[0,255]转换为[0,1]</p></li><li><p>将图片的通道channel放到第一个维度上</p></li></ol></blockquote><blockquote><p>pytorch中图片的表现形式**[batch_size, channel, height, width]**</p></blockquote><blockquote><p>#降维squeeze</p><p>img &#x3D; np.squeeze(img)</p></blockquote><h2 id="3-处理技术"><a href="#3-处理技术" class="headerlink" title="3 处理技术"></a>3 处理技术</h2><h3 id="3-1-数据增强"><a href="#3-1-数据增强" class="headerlink" title="3.1 数据增强"></a>3.1 数据增强</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-comment"># 图片预处理</span><br>train_transforms = transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">224</span>, <span class="hljs-number">224</span>)),<br>    transforms.RandomCrop(<span class="hljs-number">192</span>), <span class="hljs-comment"># 随机裁剪</span><br>    transforms.RandomHorizontalFlip(), <span class="hljs-comment"># 随机水平翻转</span><br>    transforms.RandomVerticalFlip(),  <span class="hljs-comment"># 随机垂直翻转</span><br>    transforms.RandomRotation(<span class="hljs-number">0.4</span>), <span class="hljs-comment"># 随机旋转</span><br>    transforms.ColorJitter(brightness=<span class="hljs-number">0.5</span>, contrast=<span class="hljs-number">0.5</span>), <span class="hljs-comment"># 随机调整亮度、对比度、饱和度、色相</span><br>    transforms.RandomGrayscale(), <span class="hljs-comment"># 转换为灰度图</span><br><br>    <span class="hljs-comment"># toTensor()有三个作用：1、将数据变化为tensor类型；2、将数据归一化到[0,1]；3、将数据的channel提前</span><br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>])<br><br>test_transforms = transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">224</span>, <span class="hljs-number">224</span>)),<br>    <span class="hljs-comment"># toTensor()有三个作用：1、将数据变化为tensor类型；2、将数据归一化到[0,1]；3、将数据的channel提前</span><br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>])<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">32</span><br><br>train_dataset = torchvision.datasets.ImageFolder(root=train_dir, transform=train_transforms)<br>test_dataset = torchvision.datasets.ImageFolder(root=test_dir, transform=test_transforms)<br><br>train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><h3 id="3-2-学习率衰减"><a href="#3-2-学习率衰减" class="headerlink" title="3.2 学习率衰减"></a>3.2 学习率衰减</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lr_scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=<span class="hljs-number">10</span>, gamma=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><h3 id="3-3-迁移GPU"><a href="#3-3-迁移GPU" class="headerlink" title="3.3 迁移GPU"></a>3.3 迁移GPU</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&quot;cuda:0&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>model = Model().to(device)<br>model<br></code></pre></td></tr></table></figure><h3 id="3-4-损失和优化器"><a href="#3-4-损失和优化器" class="headerlink" title="3.4 损失和优化器"></a>3.4 损失和优化器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义损失函数和优化器</span><br>lr = <span class="hljs-number">1e-3</span><br>loss_func = nn.CrossEntropyLoss()<br>optimizer = optim.Adam(model.parameters(), lr)<br></code></pre></td></tr></table></figure><h3 id="3-5-定义train函数"><a href="#3-5-定义train函数" class="headerlink" title="3.5 定义train函数"></a>3.5 定义train函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">epoches, model, train_loader, test_loader</span>):<br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    running_loss = <span class="hljs-number">0</span><br>    model.train()<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_loader:<br>        x, y = x.to(device), y.to(device)<br>        <span class="hljs-comment"># 前向传播</span><br>        y_pred = model(x)<br>        <span class="hljs-comment"># 计算损失</span><br>        loss = loss_func(y_pred, y)<br>        <span class="hljs-comment"># 反向传播</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-comment"># argmax() 返回最大值的索引，代表真实预测的类别</span><br>            y_pred = torch.argmax(y_pred, dim=<span class="hljs-number">1</span>)<br>            correct += (y_pred == y).<span class="hljs-built_in">sum</span>().item()<br>            total += y.size(<span class="hljs-number">0</span>)<br>            running_loss += loss.item()<br><br>    lr_scheduler.step()<br>    epoch_loss = running_loss / total<br>    epoch_acc = correct / total<br><br>    <span class="hljs-comment"># 测试过程</span><br>    model.<span class="hljs-built_in">eval</span>()<br>    test_correct = <span class="hljs-number">0</span><br>    test_total = <span class="hljs-number">0</span><br>    test_running_loss = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> test_loader:<br>            x, y = x.to(device), y.to(device)<br>            y_pred = model(x)<br>            loss = loss_func(y_pred, y)<br>            y_pred = torch.argmax(y_pred, dim=<span class="hljs-number">1</span>)<br>            test_correct += (y_pred == y).<span class="hljs-built_in">sum</span>().item()<br>            test_total += y.size(<span class="hljs-number">0</span>)<br>            test_running_loss += loss.item()<br><br>    test_epoch_loss = test_running_loss / test_total<br>    test_epoch_acc = test_correct / test_total<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch: &#123;&#125;, Loss: &#123;:.4f&#125;, Acc: &#123;:.4f&#125;, test_Loss: &#123;:.4f&#125;, test_Acc: &#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(epoches + <span class="hljs-number">1</span>, epoch_loss,<br>                                                                                             epoch_acc,<br>                                                                                             test_epoch_loss,<br>                                                                                             test_epoch_acc))<br>    <span class="hljs-keyword">return</span> epoch_loss, epoch_acc, test_epoch_loss, test_epoch_acc<br></code></pre></td></tr></table></figure><h3 id="3-6-模型保存与加载"><a href="#3-6-模型保存与加载" class="headerlink" title="3.6 模型保存与加载"></a>3.6 模型保存与加载</h3><p>保存精度最好的模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">epoches = <span class="hljs-number">20</span><br>train_loss = []<br>train_acc = []<br>test_loss = []<br>test_acc = []<br>best_acc = <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoches):<br>    epoch_loss, epoch_acc, test_epoch_loss, test_epoch_acc = train(epoch, model, train_loader, test_loader)<br>    train_loss.append(epoch_loss)<br>    train_acc.append(epoch_acc)<br>    test_loss.append(test_epoch_loss)<br>    test_acc.append(test_epoch_acc)<br><br>    <span class="hljs-keyword">if</span> test_epoch_acc &gt; best_acc:<br>        best_acc = test_epoch_acc<br>        torch.save(model.state_dict(), <span class="hljs-string">&#x27;./vgg16_best_model.pth&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;best_acc: &#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(best_acc))<br></code></pre></td></tr></table></figure><p>加载最好的模型并测试</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 恢复保存的模型</span><br>load_model = models.vgg16()<br>load_model.load_state_dict(torch.load(<span class="hljs-string">&quot;vgg16_best_model.pth&quot;</span>), map_location=device)<br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250708113323211.png" alt="image-20250708113315979"></p><h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h2><p>tensor创建</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype=torch.float32)<br>torch.tensor(np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))<br><br><span class="hljs-comment"># 随机的矩阵创建</span><br>torch.randn((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 将numpy的数值转化成tensor格式</span><br>np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>torch.from_numpy(n)<br></code></pre></td></tr></table></figure><p>取值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从归一化的数中进行随机生成</span><br>x = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># 取出第一个矩阵的第一行</span><br>x[<span class="hljs-number">0</span>, :, :]<br><span class="hljs-comment"># 取出所有的第一列</span><br>x[:, :, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 取出224 * 224 </span><br>x = torch.rand(<span class="hljs-number">32</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>)<br>x[<span class="hljs-number">0</span>, :, :, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p>运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch.randn((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment"># 转置</span><br>t.T<br><br><span class="hljs-comment"># 求逆运算</span><br>torch.inverse(t)<br><br><span class="hljs-comment"># 矩阵乘法</span><br>a1 = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>a2 = torch.randn(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>torch.matmul(a1, a2) <span class="hljs-comment"># a1 @ a2</span><br></code></pre></td></tr></table></figure><p><font color='red'><strong>自动微分：微分必须是一个标量，不能是向量~~</strong></font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, requires_grad=<span class="hljs-literal">True</span>)<br>y = x + <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 查看能否求梯度</span><br>x.requires_grad<br>x2 = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 不可求导</span><br>x2.requires_grad<br><br>y.grad_fn<br><br>z = y.mean()<br><br><span class="hljs-comment"># 反向传播</span><br>z.backward()<br><br>x.grad<br><br>z = y * y * <span class="hljs-number">3</span><br>out = z.mean()<br>out<br><br>out.backward()<br><br><span class="hljs-built_in">print</span>(y.requires_grad_(<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure><h2 id="4-经典算法实现"><a href="#4-经典算法实现" class="headerlink" title="4 经典算法实现"></a>4 经典算法实现</h2><h3 id="4-1-线性回归"><a href="#4-1-线性回归" class="headerlink" title="4.1 线性回归"></a>4.1 线性回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>data = pd.read_csv(<span class="hljs-string">&quot;./data/Income1.csv&quot;</span>)<br><br><span class="hljs-comment"># 取出数据</span><br>X = torch.from_numpy(data.Education.values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).<span class="hljs-built_in">type</span>(torch.float32)<br>Y = torch.from_numpy(data.Income.values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).<span class="hljs-built_in">type</span>(torch.float32)<br><br><span class="hljs-comment"># wx + b</span><br>model = nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 定义损失函数</span><br>loss_fn = nn.MSELoss()<br><br><span class="hljs-comment"># 定义优化器</span><br>optim = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.001</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(X, Y):<br>        y_pred = model(x)<br>        loss = loss_fn(y_pred, y)<br>        <span class="hljs-comment"># 梯度清理</span><br>        optim.zero_grad()<br>        loss.backward()<br><br>        <span class="hljs-comment"># 更新操作</span><br>        optim.step()<br><br>plt.scatter(data.Education, data.Income)<br>plt.xlabel(<span class="hljs-string">&#x27;Education&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Income&#x27;</span>)<br>plt.plot(X.numpy(), (torch.matmul(X, w) + b).data.numpy(), color=<span class="hljs-string">&#x27;red&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250705204317331.png" alt="output" style="zoom:50%;" /><h3 id="4-2-二分类封装"><a href="#4-2-二分类封装" class="headerlink" title="4.2 二分类封装"></a>4.2 二分类封装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> TensorDataset, DataLoader<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>data = pd.read_csv(<span class="hljs-string">&#x27;./data/HR_comma_sep.csv&#x27;</span>)<br><br>data<br><br><span class="hljs-comment"># 对于离散的字符串，有两种处理方式：1. 将其转化为one-hot编码；2. 将其转化为数值</span><br>data = data.join(pd.get_dummies(data[<span class="hljs-string">&#x27;part&#x27;</span>], dtype=<span class="hljs-built_in">int</span>)).join(pd.get_dummies(data[<span class="hljs-string">&#x27;salary&#x27;</span>], dtype=<span class="hljs-built_in">int</span>))<br><br><span class="hljs-comment"># 把原始的part和salary剔除</span><br>data = data.drop([<span class="hljs-string">&#x27;part&#x27;</span>, <span class="hljs-string">&#x27;salary&#x27;</span>], axis=<span class="hljs-number">1</span>)<br><br>data<br><br>data[<span class="hljs-string">&#x27;left&#x27;</span>].value_counts()<br><br><span class="hljs-comment"># 取出left中所有0的个数除以总数，算出数据比例大致是3：1</span><br>(data[<span class="hljs-string">&#x27;left&#x27;</span>] == <span class="hljs-number">0</span>).<span class="hljs-built_in">sum</span>() / <span class="hljs-built_in">len</span>(data.left)<br><br>Y_numpy = data[<span class="hljs-string">&#x27;left&#x27;</span>].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>Y = torch.from_numpy(Y_numpy).<span class="hljs-built_in">type</span>(torch.FloatTensor)<br><br>X_numpy = data[[columns <span class="hljs-keyword">for</span> columns <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> columns != <span class="hljs-string">&#x27;left&#x27;</span>]].values<br>X = torch.from_numpy(X_numpy).<span class="hljs-built_in">type</span>(torch.FloatTensor)<br>X, Y<br><br>X.shape, Y.shape<br><br><span class="hljs-comment"># pytorch中最常用的一种船舰模型的方式</span><br><span class="hljs-comment"># 子类的写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HRModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 先调用父类的方法</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 定义所需参数</span><br>        <span class="hljs-variable language_">self</span>.linear1 = nn.Linear(<span class="hljs-number">20</span>, <span class="hljs-number">64</span>)<br>        <span class="hljs-variable language_">self</span>.linear2 = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>)<br>        <span class="hljs-variable language_">self</span>.linear3 = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">1</span>)<br><br>        <span class="hljs-variable language_">self</span>.activate = nn.ReLU()<br>        <span class="hljs-variable language_">self</span>.sigmoid = nn.Sigmoid()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = <span class="hljs-variable language_">self</span>.linear1(x)<br>        x = <span class="hljs-variable language_">self</span>.activate(x)<br><br>        x = <span class="hljs-variable language_">self</span>.linear2(x)<br>        x = <span class="hljs-variable language_">self</span>.activate(x)<br><br>        x = <span class="hljs-variable language_">self</span>.linear3(x)<br>        x = <span class="hljs-variable language_">self</span>.sigmoid(x)<br>        <span class="hljs-keyword">return</span> x<br><span class="hljs-comment">#%%</span><br>lr = <span class="hljs-number">1e-3</span><br>epoches = <span class="hljs-number">100</span><br>batch_size = <span class="hljs-number">64</span><br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 定义损失函数</span><br>loss_func = nn.BCELoss()<br>steps = <span class="hljs-built_in">len</span>(X) // batch_size<br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 切割数据-&gt;分别创建训练数据和测试数据得dataloader-&gt;训练过程--&gt; 计算准确率</span><br>train_x, test_x, train_y, test_y = train_test_split(X_numpy, Y_numpy)<br><br><span class="hljs-comment"># 数据转化成tensor</span><br>train_x = torch.tensor(train_x, dtype=torch.float32)<br>test_x = torch.tensor(test_x, dtype=torch.float32)<br><br>train_y = torch.tensor(train_y, dtype=torch.float32)<br>test_y = torch.tensor(test_y, dtype=torch.float32)<br><br><span class="hljs-comment"># 创建dataloader和dataset</span><br><span class="hljs-comment"># dataloader可以分批次取数据</span><br><span class="hljs-comment"># dataloader是由dataset创建出来的</span><br>train_ds = TensorDataset(train_x, train_y)<br>train_dl = DataLoader(train_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br><br>test_ds = TensorDataset(test_x, test_y)<br>test_dl = DataLoader(test_ds, batch_size=batch_size * <span class="hljs-number">2</span>, shuffle=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 定义获取模型得函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model</span>():<br>    model = HRModel()<br>    <span class="hljs-keyword">return</span> model, torch.optim.Adam(model.parameters(), lr=lr)<br><br><br><span class="hljs-comment"># 按批次计算损失</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loss_batch</span>(<span class="hljs-params">model, loss_func, x, y, optimizer=<span class="hljs-literal">None</span></span>):<br>    loss = loss_func(model(x), y)<br><br>    <span class="hljs-keyword">if</span> optimizer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        loss.backward()<br>        optimizer.step()<br>        optimizer.zero_grad()<br>    <span class="hljs-keyword">return</span> loss.item(), <span class="hljs-built_in">len</span>(x)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">epoches, model, loss_func, optimizer, train_dl, valid_dl</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoches):<br>        <span class="hljs-comment"># 训练模式</span><br>        model.train()<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_dl:<br>            loss_batch(model, loss_func, x, y, optimizer)<br>        model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            losses, nums = <span class="hljs-built_in">zip</span>(*[loss_batch(model, loss_func, x, y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> valid_dl])<br>        val_loss = np.<span class="hljs-built_in">sum</span>(np.multiply(losses, nums)) / np.<span class="hljs-built_in">sum</span>(nums)<br>        acc_mean = np.mean([accuracy(model(x), y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> valid_dl])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch: <span class="hljs-subst">&#123;epoch&#125;</span>, val_loss: <span class="hljs-subst">&#123;val_loss&#125;</span>, acc_mean: <span class="hljs-subst">&#123;acc_mean&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-comment"># 定义计算准确率的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">output, y_true</span>):<br>    <span class="hljs-keyword">return</span> ((output.data.numpy() &gt; <span class="hljs-number">0.5</span>) == y_true.numpy()).mean()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">train_ds, valid_ds, batch_size</span>):<br>    train_dl = DataLoader(train_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>    valid_dl = DataLoader(valid_ds, batch_size=batch_size * <span class="hljs-number">2</span>, shuffle=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> train_dl, valid_dl<br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 模型训练简化代码</span><br>train_dl, valid_dl = get_data(train_ds, test_ds, batch_size)<br>model, optimizer = get_model()<br>train(epoches, model, loss_func, optimizer, train_dl, valid_dl)<br></code></pre></td></tr></table></figure><h3 id="4-3-CNN网络"><a href="#4-3-CNN网络" class="headerlink" title="4.3 CNN网络"></a>4.3 CNN网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms, datasets<br><br><br><span class="hljs-comment"># 数据预处理</span><br>transform = transforms.Compose([<br>    transforms.ToTensor(),<br>    <span class="hljs-comment"># transforms.Normalize((0.1307,), (0.3081,))</span><br>])<br><br><span class="hljs-comment"># 数据集加载</span><br>train_data = datasets.MNIST(root=<span class="hljs-string">&#x27;../dataset&#x27;</span>, train=<span class="hljs-literal">True</span>, transform=transform, download=<span class="hljs-literal">True</span>)<br>test_data = datasets.MNIST(root=<span class="hljs-string">&#x27;../dataset&#x27;</span>, train=<span class="hljs-literal">False</span>, transform=transform)<br><br><br><span class="hljs-comment"># 转化成dataloader方便进行批量处理</span><br>batch_size = <span class="hljs-number">64</span><br><br>train_loader = DataLoader(dataset=train_data, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 测试集不需要shuffle，并且数据不需要进行反向传播，可以将batch_size数值给大一些</span><br>test_loader = DataLoader(dataset=test_data, batch_size=batch_size * <span class="hljs-number">2</span>, shuffle=<span class="hljs-literal">False</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># in: 64  1 28 28   out: 64 16 26 26</span><br>        <span class="hljs-variable language_">self</span>.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># in: 64 16 26 26   out: 64 16 13 13</span><br>        <span class="hljs-variable language_">self</span>.conv2 = nn.Conv2d(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># in: 64 16 13 13   out: 64 32 11 11</span><br>        <span class="hljs-variable language_">self</span>.fc1 = nn.Linear(<span class="hljs-number">32</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">128</span>)  <span class="hljs-comment"># in: 64 32  5  5</span><br>        <span class="hljs-variable language_">self</span>.fc2 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = F.relu(<span class="hljs-variable language_">self</span>.conv1(x))<br>        x = <span class="hljs-variable language_">self</span>.pool(x)<br>        x = F.relu(<span class="hljs-variable language_">self</span>.conv2(x))<br>        x = <span class="hljs-variable language_">self</span>.pool(x)<br><br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">32</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>)<br><br>        x = F.relu(<span class="hljs-variable language_">self</span>.fc1(x))<br>        x = <span class="hljs-variable language_">self</span>.fc2(x)<br>        <span class="hljs-keyword">return</span> x<br>    <br>    <br>    <br>device = torch.device(<span class="hljs-string">&#x27;cuda:0&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>model = Model().to(device)<br>model<br><br><span class="hljs-comment"># 创建损失函数</span><br>loss_func = nn.CrossEntropyLoss()<br><br><span class="hljs-comment"># 创建优化器</span><br>lr = <span class="hljs-number">1e-3</span><br>optimizer = torch.optim.Adam(model.parameters(), lr)<br><br><span class="hljs-comment"># 学习率衰减</span><br>lr_scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=<span class="hljs-number">10</span>, gamma=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure><p>接下来定义训练函数和开始训练，代码参考 3 技术板块</p><p>绘图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(train_loss, label=<span class="hljs-string">&#x27;train_loss&#x27;</span>)<br>plt.plot(test_loss, label=<span class="hljs-string">&#x27;test_loss&#x27;</span>)<br>plt.plot(train_acc, label=<span class="hljs-string">&#x27;train_acc&#x27;</span>)<br>plt.plot(test_acc, label=<span class="hljs-string">&#x27;test_acc&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure><h2 id="5-实战"><a href="#5-实战" class="headerlink" title="5 实战"></a>5 实战</h2><h3 id="5-1-天气分类（手写版）"><a href="#5-1-天气分类（手写版）" class="headerlink" title="5.1 天气分类（手写版）"></a>5.1 天气分类（手写版）</h3><p>导入包</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure><p>数据准备</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">base_dir = <span class="hljs-string">&#x27;../dataset/weather&#x27;</span><br>train_dir = os.path.join(base_dir, <span class="hljs-string">&#x27;train&#x27;</span>)<br>test_dir = os.path.join(base_dir, <span class="hljs-string">&#x27;test&#x27;</span>)<br><br>species = [<span class="hljs-string">&#x27;cloudy&#x27;</span>, <span class="hljs-string">&#x27;rain&#x27;</span>, <span class="hljs-string">&#x27;shine&#x27;</span>, <span class="hljs-string">&#x27;sunrise&#x27;</span>]<br><br><span class="hljs-comment"># 获取所有图片列表</span><br>filenames = os.listdir(base_dir)<br><br><span class="hljs-comment"># 创建train和test目录</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(train_dir):<br>    os.mkdir(train_dir)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(test_dir):<br>    os.mkdir(test_dir)<br>    <br><span class="hljs-comment"># 先判断是否存在，如果不存在的话，在train_dir和test_dir中分别创建species目录</span><br><span class="hljs-keyword">for</span> species_name <span class="hljs-keyword">in</span> species:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(os.path.join(train_dir, species_name)):<br>        os.mkdir(os.path.join(train_dir, species_name))<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(os.path.join(test_dir, species_name)):<br>        os.mkdir(os.path.join(test_dir, species_name))<br></code></pre></td></tr></table></figure><p>图片转移到对应数据目录：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将dataset/weather中的图片分别移动到train和test目录中</span><br><span class="hljs-comment"># 其中i是每隔五个将数据放入test集中</span><br><span class="hljs-keyword">for</span> i, img <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(filenames):<br>    <span class="hljs-keyword">for</span> species_name <span class="hljs-keyword">in</span> species:<br>        <span class="hljs-keyword">if</span> species_name <span class="hljs-keyword">in</span> img:<br>            img_source_path = os.path.join(base_dir, img)<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                img_target_path = os.path.join(test_dir, species_name, img)<br>            <span class="hljs-keyword">else</span>:<br>                img_target_path = os.path.join(train_dir, species_name, img)<br><br>            shutil.copy(img_source_path, img_target_path)<br></code></pre></td></tr></table></figure><p>查看train和test目录中的图片数量</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> train_or_test <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>]:<br>    <span class="hljs-keyword">for</span> species_name <span class="hljs-keyword">in</span> species:<br>        <span class="hljs-built_in">print</span>(train_or_test, species_name, <span class="hljs-built_in">len</span>(os.listdir(os.path.join(base_dir, train_or_test, species_name))))<br></code></pre></td></tr></table></figure><p>图片增强</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 图片预处理</span><br>transforms = transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">96</span>, <span class="hljs-number">96</span>)),<br>    transforms.RandomCrop(<span class="hljs-number">96</span>),<br>    transforms.RandomHorizontalFlip(),<br>    transforms.RandomVerticalFlip(),<br>    <span class="hljs-comment"># toTensor()有三个作用：1、将数据变化为tensor类型；2、将数据归一化到[0,1]；3、将数据的channel提前</span><br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>])<br></code></pre></td></tr></table></figure><p>数据加载</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">train_dataset = torchvision.datasets.ImageFolder(root=train_dir, transform=transforms)<br>test_dataset = torchvision.datasets.ImageFolder(root=test_dir, transform=transforms)<br><br>batch_size = <span class="hljs-number">32</span><br><br>train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">True</span>)<br>test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>, drop_last=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>模型定义</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加BN层</span><br><span class="hljs-comment"># 定义网络</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>)    <span class="hljs-comment"># 16 * 94 * 94</span><br>        <span class="hljs-variable language_">self</span>.bn1 = nn.BatchNorm2d(<span class="hljs-number">16</span>)<br>        <span class="hljs-variable language_">self</span>.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)      <span class="hljs-comment"># 16 * 47 * 47</span><br><br>        <span class="hljs-variable language_">self</span>.conv2 = nn.Conv2d(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 32 * 45 * 45 --&gt; 32 * 22 * 22</span><br>        <span class="hljs-variable language_">self</span>.bn2 = nn.BatchNorm2d(<span class="hljs-number">32</span>)<br><br>        <span class="hljs-variable language_">self</span>.conv3 = nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 64 * 20 * 20 --&gt; 64 * 10 * 10</span><br>        <span class="hljs-variable language_">self</span>.bn3 = nn.BatchNorm2d(<span class="hljs-number">64</span>)<br><br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout()<br><br>        <span class="hljs-comment"># 全连接层</span><br>        <span class="hljs-variable language_">self</span>.fc1 = nn.Linear(<span class="hljs-number">64</span> * <span class="hljs-number">10</span> * <span class="hljs-number">10</span>, <span class="hljs-number">1024</span>)<br>        <span class="hljs-variable language_">self</span>.bn_fc1 = nn.BatchNorm1d(<span class="hljs-number">1024</span>)<br>        <span class="hljs-variable language_">self</span>.fc2 = nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">256</span>)<br>        <span class="hljs-variable language_">self</span>.bn_fc2 = nn.BatchNorm1d(<span class="hljs-number">256</span>)<br>        <span class="hljs-variable language_">self</span>.fc3 = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">4</span>)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = <span class="hljs-variable language_">self</span>.pool(<span class="hljs-variable language_">self</span>.bn1(F.relu(<span class="hljs-variable language_">self</span>.conv1(x))))<br>        x = <span class="hljs-variable language_">self</span>.pool(<span class="hljs-variable language_">self</span>.bn2(F.relu(<span class="hljs-variable language_">self</span>.conv2(x))))<br>        x = <span class="hljs-variable language_">self</span>.pool(<span class="hljs-variable language_">self</span>.bn3(F.relu(<span class="hljs-variable language_">self</span>.conv3(x))))<br><br>        <span class="hljs-comment"># x = x.view(-1, 64 * 10 * 10)</span><br>        x = nn.Flatten()(x)<br><br>        x = <span class="hljs-variable language_">self</span>.bn_fc1(F.relu(<span class="hljs-variable language_">self</span>.fc1(x)))<br>        x = <span class="hljs-variable language_">self</span>.dropout(x)<br>        x = <span class="hljs-variable language_">self</span>.bn_fc2(F.relu(<span class="hljs-variable language_">self</span>.fc2(x)))<br>        x = <span class="hljs-variable language_">self</span>.dropout(x)<br>        x = <span class="hljs-variable language_">self</span>.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>转移GPU</p><p>定义损失函数和优化器</p><p>最后训练函数定义，和开始训练，代码参考第三节</p><h3 id="5-1-迁移学习"><a href="#5-1-迁移学习" class="headerlink" title="5.1 迁移学习"></a>5.1 迁移学习</h3><p>仅需更换model如下即可：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入预训练好的模型</span><br>os.environ[<span class="hljs-string">&#x27;TORCH_HOME&#x27;</span>] = <span class="hljs-string">&#x27;../dataset&#x27;</span><br>model = models.vgg16(weights=models.VGG16_Weights.IMAGENET1K_V1)<br><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.features.parameters():<br>    param.requires_grad = <span class="hljs-literal">False</span><br><br>model.classifier[-<span class="hljs-number">1</span>].out_features = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure><h2 id="6-tensorboard"><a href="#6-tensorboard" class="headerlink" title="6 tensorboard"></a>6 tensorboard</h2><h3 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装"></a>6.1 安装</h3><blockquote><p>pip install tensorboard</p></blockquote><h3 id="6-2-使用"><a href="#6-2-使用" class="headerlink" title="6.2 使用"></a>6.2 使用</h3><p>创建总体文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-comment"># default `log_dir` is &quot;runs&quot; - we&#x27;ll be more specific here</span><br>writer = SummaryWriter(<span class="hljs-string">&#x27;runs/fashion_mnist_experiment_1&#x27;</span>)<br></code></pre></td></tr></table></figure><p>写入数据</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">dataiter = <span class="hljs-built_in">iter</span>(trainloader)<br>images, labels = <span class="hljs-built_in">next</span>(dataiter)<br><br><span class="hljs-comment"># create grid of images</span><br>img_grid = torchvision.utils.make_grid(images)<br><br><span class="hljs-comment"># show images</span><br>matplotlib_imshow(img_grid, one_channel=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># write to tensorboard</span><br>writer.add_image(<span class="hljs-string">&#x27;four_fashion_mnist_images&#x27;</span>, img_grid)<br></code></pre></td></tr></table></figure><p>运行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tensorboard --logdir=runs<br></code></pre></td></tr></table></figure><p>添加模型查看</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">writer.add_graph(net, images)<br>writer.close()<br></code></pre></td></tr></table></figure><p>等等详情请看官网：<a href="https://pytorch.ac.cn/tutorials/intermediate/tensorboard_tutorial.html">使用 TensorBoard 可视化模型、数据和训练 — PyTorch 教程 2.7.0+cu126 文档 - PyTorch 深度学习库</a></p><h1 id="四-深度学习"><a href="#四-深度学习" class="headerlink" title="四 深度学习"></a>四 深度学习</h1><h2 id="1-多层感知器-MLP"><a href="#1-多层感知器-MLP" class="headerlink" title="1 多层感知器(MLP)"></a>1 多层感知器(MLP)</h2><p>​感知机（perceptron）是<strong>二分类的线性分类模型</strong>，属于监督学习算法。输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机<font color='red'><strong>旨在求出将输入空间中的实例划分为两类的分离超平面</strong></font>。为求得超平面，感知机导入了基于误分类的损失函数，利用<strong>梯度下降法</strong>对损失函数进行最优化求解。</p><p>​<strong>多层感知器</strong>（英语：Multilayer Perceptron，缩写：<strong>MLP</strong>）是一种前向结构的人工神经网络，映射一组输入向量到一组输出向量，一种被称为反向传播算法的监督学习方法常被用来训练MLP。</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173521155.png" alt="image-20250227213130151" style="zoom:30%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173523532.png" alt="image-20250227213832655" style="zoom:25%;" /></p><p><strong>同或门函数：</strong></p><blockquote><p>y : $x_{1} OR x_{2}$ ，其中有一个为1，那就是1。</p><p><strong>函数表达式为</strong>：$h(\Theta,x)&#x3D;g(-10+15x_{1}+15x_{2})$</p></blockquote><p><strong>与门函数：</strong></p><blockquote><p>y : $x_{1} AND x_{2}$ ，只有两个同时为1时候才是1。</p><p><strong>函数表达式为</strong>：$h(\Theta,x)&#x3D;g(-20+15x_{1}+15x_{2})$</p><p>y : $(NOT x_{1}) AND (NOT x_{2})$ ，只有两个同时为0时候才是1。</p><p><strong>函数表达式为</strong>：$h(\Theta,x)&#x3D;g(5-10x_{1}-10x_{2})$</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173527711.png" alt="image-20250227215536679" style="zoom:33%;" /><blockquote><p>问题:在建立MLP模型实现图像多分类任务中，其流程应该是怎么样的？（B A C E F D）</p><p>A、对输入数据进行维度转换与归一化处理</p><p>B、加载图片并将其转换为数字矩阵</p><p>C、建立MLP模型结构</p><p>D、对输出结果进行格式转化</p><p>E、MLP模型训练参数配置</p><p>F、模型训练与预测</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立一个Sequential顺序模型</span><br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br>model = Sequential()<br><br><span class="hljs-comment"># 通过.add()叠加各层网络</span><br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense<br>model.add(Dense(units=<span class="hljs-number">3</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>, <span class="hljs-built_in">input</span> dim=<span class="hljs-number">3</span>))<br>model.add(Dense(units=<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>))<br><br><span class="hljs-comment">#通过.compile()配置模型求解过程参数</span><br>model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>)<br><br><span class="hljs-comment">#训练模型</span><br>model.fit(x_train, y_train, epochs=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure><h2 id="2-卷积神经网络"><a href="#2-卷积神经网络" class="headerlink" title="2 卷积神经网络"></a>2 卷积神经网络</h2><h3 id="2-1-基本概念-2"><a href="#2-1-基本概念-2" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p>对MLP的处理是否可能进一步减少训练参数数量?<br>办法：提取出图像中的关键信息(轮廓)，再建立MLP模型进行训练——即图像卷积运算</p><h4 id="2-1-1-卷积层：图像卷积运算（CNN）"><a href="#2-1-1-卷积层：图像卷积运算（CNN）" class="headerlink" title="2.1.1 卷积层：图像卷积运算（CNN）"></a>2.1.1 卷积层：图像卷积运算（CNN）</h4><blockquote><p>对图像矩阵与滤波器矩阵进行对应相乘再求和运算，转化得到新的矩阵。</p><p><strong>作用：快速定位图像中某些边缘特征</strong></p><p><strong>A与B的卷积通常表示为：A * B 或 convolution(A, B)</strong></p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173531314.png" alt="image-20250301184958130" style="zoom:33%;" /></blockquote><h4 id="2-1-2-池化层：实现维度缩减"><a href="#2-1-2-池化层：实现维度缩减" class="headerlink" title="2.1.2 池化层：实现维度缩减"></a>2.1.2 池化层：实现维度缩减</h4><blockquote><p>池化：按照一个固定规则对图像矩阵进行处理，将其转换为更低维度的矩阵</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173533637.png" alt="image-20250301190859364" style="zoom: 25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173536011.png" alt="image-20250301191247087" style="zoom:25%;" /><p><strong>卷积神经网络两大特点：</strong></p><blockquote><p>参数共享（parameter sharing)：同一个特征过滤器可用于整张图片<br>稀疏连接（sparsity of connections)：生成的特征图片每个节点只与原图片中特定节点连接</p></blockquote><p>**图像填充：**通过在图像各边增加像素，使其在进行卷积运算后维持原图大小。通过padding增加像素的数量，由过滤器尺气<br>stride决定。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173538298.png" alt="image-20250301195714897" style="zoom:33%;" /><p><strong>轮廓过滤器</strong></p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173542027.png" alt="image-20250301185647018" style="zoom: 56%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173545123.png" alt="image-20250301185315331" style="zoom:33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173548919.png" alt="image-20250301185425962" style="zoom:33%;" /></p><p><strong>RGB的图像卷积</strong></p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173552051.png" alt="image-20250301190604625" style="zoom:33%;" /><p><strong>通道计算</strong></p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173556237.png" alt="image-20250331171957836" style="zoom:50%;" /><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173558617.png" alt="image-20250301194859458" style="zoom:55%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173600830.png" alt="image-20250301194937544" style="zoom: 80%;" /></p><h3 id="2-2-经典CNN模型"><a href="#2-2-经典CNN模型" class="headerlink" title="2.2 经典CNN模型"></a>2.2 经典CNN模型</h3><h4 id="2-2-1-LeNet-5"><a href="#2-2-1-LeNet-5" class="headerlink" title="2.2.1 LeNet-5"></a>2.2.1 LeNet-5</h4><p>操作：</p><blockquote><p>输入图像：32 ×32灰度图，1个通道(channel)<br>训练参数：约60,000个</p></blockquote><p>特点：</p><blockquote><p>1、随着网络越深，图像的高度和宽度在缩小，通道数在增加<br>2、卷积与池化先后成对使用</p></blockquote><p>流程图：</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173607634.png" alt="image-20250301200543151" style="zoom:33%;" /></blockquote><h4 id="2-2-2-AlexNet"><a href="#2-2-2-AlexNet" class="headerlink" title="2.2.2 AlexNet"></a>2.2.2 AlexNet</h4><p>操作：</p><blockquote><p>输入图像：227×227×3 <strong>RGB图</strong>，3个通道</p><p>训练参数：约60,000,000个</p></blockquote><p>特点：</p><blockquote><p>1、适用于识别较为复杂的彩色图，可识别1000种类别<br>2、结构比LeNet更为复杂，使用Relu作为激活函数</p></blockquote><p>流程图：</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173610592.png" alt="image-20250301202409445" style="zoom:25%;" /></blockquote><p>意义：</p><blockquote><p>学术界开始相信深度学习技术，在计算机视觉应用中可以得到很不错的结果。</p></blockquote><h4 id="2-2-3-VGG-16"><a href="#2-2-3-VGG-16" class="headerlink" title="2.2.3 VGG-16"></a>2.2.3 VGG-16</h4><p>操作：</p><blockquote><p>输入图像：227×227× 3 RGB图，3个通道</p><p>训练参数：约138,000,000个</p></blockquote><p>特点：</p><blockquote><p>1、所有卷积层filter 宽和高都是3，步长为1，padding 都使用same convolution（相同的卷积操作保证数据的稳定性）；<br>2、所有池化层的filter 宽和高都是2，步长都是2;<br>3、相比AlexNet，有更多的filter用于提取轮廓信息，具有更高精准性</p></blockquote><p>流程图：</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173616049.png" alt="image-20250301203705907" style="zoom:33%;" /></blockquote><h3 id="2-3-实战"><a href="#2-3-实战" class="headerlink" title="2.3 实战"></a>2.3 实战</h3><h4 id="2-3-1建立CNN实现猫狗识别"><a href="#2-3-1建立CNN实现猫狗识别" class="headerlink" title="2.3.1建立CNN实现猫狗识别"></a>2.3.1建立CNN实现猫狗识别</h4><blockquote><p>图片加载</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> lmageDataGenerator<br><span class="hljs-comment"># 图像增强/预处理配置(数值归一化、缩放、旋转、平移等)</span><br>train_datagen = lmageDataGenerator(rescale = <span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<br><span class="hljs-comment"># 加载图像:</span><br>training <span class="hljs-built_in">set</span> = train datagen.flow <span class="hljs-keyword">from</span> directory(<span class="hljs-string">&quot;./Dataset/training set, target_size =(50,50), batch_size = 32, class_mode = &#x27;binary&#x27;)</span><br></code></pre></td></tr></table></figure><blockquote><p>建立CNN模型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D,MaxPooling2D, Flatten,Dense<br><br>model = Sequential()<br><span class="hljs-comment">#卷积层</span><br>model.add(Conv2D(<span class="hljs-number">32</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),input_shape = (<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">3</span>), activation = <span class="hljs-string">&#x27;relu&#x27;</span>))<br><span class="hljs-comment">#池化层</span><br>model.add(MaxPooling2D(pool_size =(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br><span class="hljs-comment">#第二个卷积、池化层</span><br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation = <span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(MaxPooling2D(pool_size = (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><span class="hljs-comment">#Flattening层</span><br>model.add(Flatten())<br><span class="hljs-comment">#全连接层</span><br>model.add(Dense(units = <span class="hljs-number">128</span>, activation = <span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(units = <span class="hljs-number">1</span>, activation = <span class="hljs-string">&#x27;sigmoid&#x27;</span>))<br><br></code></pre></td></tr></table></figure><blockquote><p>训练与预测：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 配置模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer = <span class="hljs-string">&#x27;adam&#x27;</span>, loss = <span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>, metrics = [<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment"># 查看模型结构</span><br>model.summary()<br><span class="hljs-comment">#训练模型</span><br>model.fit_generator(training_set,epochs = <span class="hljs-number">25</span>)<br><span class="hljs-comment">#计算预测准确率</span><br>model.evaluate_generator(training_set)<br><br></code></pre></td></tr></table></figure><h4 id="2-3-2-基于VGG-16、结合MLP实现猫狗识别"><a href="#2-3-2-基于VGG-16、结合MLP实现猫狗识别" class="headerlink" title="2.3.2 基于VGG-16、结合MLP实现猫狗识别"></a>2.3.2 基于VGG-16、结合MLP实现猫狗识别</h4><blockquote><p>图片加载：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> img_to_array, load_img<br>img_path = <span class="hljs-string">&#x27;1.jpg&#x27;</span><br>img = load_img(img_path, target_size=(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br>img = img_to_array(img)<br></code></pre></td></tr></table></figure><blockquote><p>图片预处理：</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> preprocess_input<br>x = np.expand_dims(img, axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#把图片矩阵转化为可用于VGG16输入的矩阵</span><br>x = preprocess_input(x)<br></code></pre></td></tr></table></figure><blockquote><p>载入VGG16结构（去除全连接层)∶</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> VGG16<br>model_vgg = vGG16(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><blockquote><p>特征提取</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">features = model_vgg.predict(x)<br></code></pre></td></tr></table></figure><blockquote><p>建立mlp模型</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#建立一个Sequential顺序模型并添加各层from keras.models import Sequentialmodel = Sequential()</span><br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense<br>model.add(Dense(units=<span class="hljs-number">10</span>, activation= <span class="hljs-string">&#x27;relu&#x27;</span>, input_dim=<span class="hljs-number">25088</span>))<br>model.add(Dense(units=<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>))<br>model.summary()<br><span class="hljs-comment">#通过.compile()配置模型求解过程参数</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,loss=<span class="hljs-string">&#x27;binatiry_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment">#训练模型</span><br>model.fit(X_train, y_train, epochs=<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure><h2 id="3-循环神经网络RNN"><a href="#3-循环神经网络RNN" class="headerlink" title="3 循环神经网络RNN"></a>3 循环神经网络RNN</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><p>序列模型：</p><blockquote><p>输入或者输出中包含有序列数据的模型</p><p>两大特点：</p><ol><li>输入（输出）元素之间是具有顺序关系。不同的顺序，得到的结果应该是不同的，比如“不吃饭”和“吃饭不”这两个短语的意思是不同的</li><li>输入输出不定长。比如文章生成、聊天机器人</li></ol></blockquote><blockquote><p>应用场景：语音识别、翻译、股价预测、行为预测</p></blockquote><h3 id="3-2-常见结构"><a href="#3-2-常见结构" class="headerlink" title="3.2 常见结构"></a>3.2 常见结构</h3><p>结构一：多输入多输出</p><blockquote><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173620915.png" alt="image-20250303173149107" style="zoom: 25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173623264.png" alt="image-20250303174355242" style="zoom:23%;" /></p></blockquote><p>结构二：一对多，多对一</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173626343.png" alt="image-20250303174222083" style="zoom:23%;" /></blockquote><h3 id="3-2-LSTM"><a href="#3-2-LSTM" class="headerlink" title="3.2 LSTM"></a>3.2 LSTM</h3><p>目的：为解决前部序列信息距离远丢失信息多的问题</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173628923.png" alt="image-20250303174947897" style="zoom:25%;" /></blockquote><p>结构：</p><blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173631035.png" alt="image-20250303175226965" style="zoom:25%;" /></blockquote><p>特点：</p><blockquote><p>在网络结构很深(很多层)的情况下，也能保留重要信息;</p><p>解决了普通RNN求解过程中的梯度消失问题；解决长期依赖问题，通过引入记忆单元和门控制机制来控制信息得流动</p></blockquote><p>应用场景：</p><blockquote><p>语音识别、文本生成、情感分析</p></blockquote><h3 id="3-3-其他常见模型"><a href="#3-3-其他常见模型" class="headerlink" title="3.3 其他常见模型"></a>3.3 其他常见模型</h3><p>双向循环神经网络BRNN：前后均可判断信息，提高判断得准确性</p><p>深层循环神经网络DRNN：解决更复杂的序列任务，可以把单层RNN叠起来或者在输出前和普通mlp结构结合使用</p><h3 id="3-4-实战"><a href="#3-4-实战" class="headerlink" title="3.4 实战"></a>3.4 实战</h3><h4 id="3-4-1-RNN股价预测"><a href="#3-4-1-RNN股价预测" class="headerlink" title="3.4.1 RNN股价预测"></a>3.4.1 RNN股价预测</h4><p>基于zgpa_train.csv数据，建立RNN模型，预测股价：</p><blockquote><p>完成数据颈处理，将序列数据转化为可用下RNN输入的数据</p><p>对新数据zgpa_test.csv进行预测，可视化结果</p><p>存储预测结果，并观察局部预测结果</p></blockquote><p>模型要求：</p><blockquote><p>单层RNN输出有5个神经元</p><p>每次使用前8个数据预测第9个数据</p></blockquote><h4 id="3-4-2-LSTM自动生成文本"><a href="#3-4-2-LSTM自动生成文本" class="headerlink" title="3.4.2 LSTM自动生成文本"></a>3.4.2 LSTM自动生成文本</h4><p>基于flare文本数据，建立LSTM模型预测序列文字：</p><blockquote><p>完成数据预处理将文字序列数据转化为可用于LSTM输入的数据</p><p>查看文字数据预处理后的数据结构，并进行数据分离操作</p><p>针对字符串输入(”flare is a teacher in AI industry. He obtained his phd in Australia.“)，预测其对应的后续字符</p><p>模型结构：(单层LSTM输出有20个神经元；每次使用前20个字符预测）</p></blockquote><h2 id="4-迁移学习"><a href="#4-迁移学习" class="headerlink" title="4 迁移学习"></a>4 迁移学习</h2><h3 id="4-1-相关概念"><a href="#4-1-相关概念" class="headerlink" title="4.1 相关概念"></a>4.1 相关概念</h3><p>概念：以已经训练好的模型A为起点，在新场景中，根据新数据建立模型B。</p><p>目的：将某个领域或任务上学习到的知识或模式，应用到不同但相关的领域或问题中。</p><p>英文：transfer learning</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173635309.png" alt="image-20250304145644120" style="zoom:25%;" /><p>学习方式：</p><blockquote><ol><li>特征提取：使用模型A，移除输出层，提取目标特征信息</li><li>结构引用：使用模型A的结构，重新&#x2F;二次训练权重系数参数</li><li>部分训练：使用模型A的结构，重新训练部分层的权重系数参数</li></ol></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173637324.png" alt="image-20250304154502818" style="zoom:25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173639999.png" alt="image-20250304154731985" style="zoom:25%;" /><h3 id="4-2-实战"><a href="#4-2-实战" class="headerlink" title="4.2 实战"></a>4.2 实战</h3><h4 id="4-2-1-迁移预测"><a href="#4-2-1-迁移预测" class="headerlink" title="4.2.1 迁移预测"></a>4.2.1 迁移预测</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173642407.png" alt="image-20250304163510651" style="zoom:23%;" /><p>要求：</p><blockquote><p>模型结构：mlp</p><p>两个隐藏层，每层50个神经元，</p><p>激活函数relu，</p><p>输出层激活函数linear,</p><p>迭代次数：100次</p></blockquote><p>操作：</p><blockquote><p>建立MLP模型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.models importSequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense<br>model = Sequentia()<br>model.add(Dense(units= <span class="hljs-number">50</span>, input_dim= <span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(units = <span class="hljs-number">50</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(units =<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;linear&#x27;</span>))<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<br><br>model.summary()<br></code></pre></td></tr></table></figure><p>模型训练与二次训练:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model.fit(x,y)<br>model.fit(x2,y2)<br></code></pre></td></tr></table></figure><p>模型保存到本地:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.externals <span class="hljs-keyword">import</span> joblib<br>joblib.dump(model, <span class="hljs-string">&quot;model1.m&quot;</span>)<br></code></pre></td></tr></table></figure><p>加载本地模型:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model2=joblib.load(<span class="hljs-string">&quot;model1.m&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote><h4 id="4-2-2-苹果检测"><a href="#4-2-2-苹果检测" class="headerlink" title="4.2.2 苹果检测"></a>4.2.2 苹果检测</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173645557.png" alt="image-20250304165859988" style="zoom:25%;" /><p>数据增强，扩充确认为普通苹果的样本数量：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator<br><span class="hljs-comment">#待增强图片的路径</span><br>path = <span class="hljs-string">&#x27;origin_data&#x27;</span><br><span class="hljs-comment">#图片增强后的存储路径#创建实例、配置图片增强参数</span><br>dst_path = <span class="hljs-string">&#x27;gen_data&#x27;</span><br>datagen = ImageDataGenerator(rotation_range=<span class="hljs-number">10</span>, width_shift_range=<span class="hljs-number">0.1</span>, height_shift_range=<span class="hljs-number">0.02</span>, horizontal_flip=<span class="hljs-literal">True</span>,vertical_flip=<span class="hljs-literal">True</span>)<br>gen = datagen.flow_from_directory(path, target_size=(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>), batch_size=<span class="hljs-number">2</span>, save_to_dir=dst_path,<br>                                  save_prefix=<span class="hljs-string">&#x27;gen&#x27;</span>, save_format=<span class="hljs-string">&#x27;jpg&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    gen.<span class="hljs-built_in">next</span>()<br></code></pre></td></tr></table></figure><p>单张图片载入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> load_img,img_to_array<br>img_path = <span class="hljs-string">&#x27;1.jpg&#x27;</span><br>img = load_img(img_path, target_size=(<span class="hljs-number">224</span>,<span class="hljs-number">224</span>))<br>img = img_to_array(img)<br></code></pre></td></tr></table></figure><p>单张图片可视化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>fig = plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br>img = load_img(img_path, target_size=(<span class="hljs-number">224</span>,<span class="hljs-number">224</span>))<br>plt.imshow(img)<br></code></pre></td></tr></table></figure><p>单张图片特征提取：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#模型加载、图像矩阵预处理</span><br><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> VGG16<br><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> preprocess_input<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>model_vgg = VGG16(weights = <span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top = <span class="hljs-literal">False</span>)<br>x = np.expand_dims(img, axis=O)<br>x = preprocess_input(x)<br><br><span class="hljs-comment">#特征提取</span><br>features = model_vgg.predict(x)<br><br><span class="hljs-comment">#特征数据格式预处理</span><br>features = features.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">7</span> * <span class="hljs-number">7</span> * <span class="hljs-number">512</span>)<br></code></pre></td></tr></table></figure><p>批量图片路径加载：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-comment">#训练数据文件夹名称</span><br>folder = <span class="hljs-string">&quot;train_data&quot;</span><br><span class="hljs-comment">#获取文件夹下所有文件名称#图片路径合成</span><br>dirs = os.listdir(folder)<br>img_path =[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dirs:<br>    <span class="hljs-keyword">if</span> os.path.splitext(i)[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;.jpg&quot;</span>:<br>        img_path.append(i)<br>    img_path = [folder+<span class="hljs-string">&quot;//&quot;</span> + i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> img_path]<br><br></code></pre></td></tr></table></figure><p>定义一个提取图片特征的方法:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">modelProcess</span>(<span class="hljs-params">img_path,model</span>):<br>    img = load_img(img_path, target_size = (<span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br>    img = img_to_array(img)<br>    x = np.expand_dims(img, axis=O)<br>    x = preprocess_input(x)<br>    x_vgg = model.predict(x)<br>    x_vgg = x_vgg.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">512</span>)<br>    <span class="hljs-keyword">return</span> x_vgg<br></code></pre></td></tr></table></figure><p>批量提取图片特征：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">features1 = np.zeros([<span class="hljs-built_in">len</span>(img_path), <span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">512</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(img_path)):<br>    feature_i = modelProcess(img_path[i], model_vgg)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;preprocessed:&#x27;</span>, img_path[i])<br>    features1[i]= feature_i<br><br></code></pre></td></tr></table></figure><p>KMeans聚类(2类)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.cluster Import KMeans<br>cnn_kmeans = KMeans(n_clusters=<span class="hljs-number">2</span>, max_iter=<span class="hljs-number">2000</span>)<br>cnn kmeans.fit(x)<br>y_pred_kmeans  =cnn_kmeans.fit_predict(X)<br></code></pre></td></tr></table></figure><p>Meanshift聚类:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> MeanShift,estimate_bandwidth<br><span class="hljs-comment">#自动获取区域宽度</span><br>bw = estimate_bandwidth(X1, n_samples=<span class="hljs-number">140</span>)<br><span class="hljs-comment">#建立模型</span><br>ms = MeanShift(bandwidth = bw)<br>ms.fit(X)<br>y_pred_ms = ms.predict(X)<br></code></pre></td></tr></table></figure><p>数据降维(PCA处理)：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-comment">#数据标准化处理</span><br>stds = StandardScaler()<br>X_norm = stds.fit_transform(X)<br><span class="hljs-comment">#PCA降维</span><br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br>pca = PCA(n_components=<span class="hljs-number">200</span>)<br>x pca = pca.fit_transform(X_norm)<br><span class="hljs-comment">#计算主成分方差比例</span><br>var_ratio = pca.explained_variance_ratio<br><span class="hljs-comment">#查看主成分方差比之和</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(var_ratio))<br></code></pre></td></tr></table></figure><p>统计数据次数:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-built_in">print</span>(Counter(y_pred_ms))<br></code></pre></td></tr></table></figure><p>批量可视化结果:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>))<br>fori <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">45</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        img = load_img(img_path[i*<span class="hljs-number">5</span>+j]) <span class="hljs-comment">#read the image as a PIL image</span><br>        plt.subplot(<span class="hljs-number">45</span>, i*<span class="hljs-number">5</span>+j+<span class="hljs-number">1</span>)<br>        plt.title(<span class="hljs-string">&#x27;apple&#x27;</span> <span class="hljs-keyword">if</span> y_pred_ms[i*<span class="hljs-number">5</span> + j] == normal_apple_id <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;others&#x27;</span>)<br>        plt.imshow(img), plt.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="5-在线学习"><a href="#5-在线学习" class="headerlink" title="5 在线学习"></a>5 在线学习</h2><p>概念：给已经训练好的模型输入新的数掺，模型将进行更新适应新数据的趋势。</p><p>目的：针对新数据，在不需要对全数据集进行再次训练的基础上，实现模型更新</p><p>英文：online learning</p><p>适合场景：场景中有连续的数据流</p><p>特点：不改变模型结构，根据新数据跟新权重系数</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173651414.png" alt="image-20250304154959814" style="zoom:33%;" /><blockquote><p>任务:针对航空公司机票价格，在不同时期，如何确定不同的价格<br>方式一：考虑天气、假期、旅行人数、同时期其他公司航班数、历史参考价格等等，建立一个专家模型<br>方式二：根据客户的实时购票情况，预测客户对不同价格的购买意愿，根据意愿度调整价格</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173655401.png" alt="image-20250304155221773" style="zoom:33%;" /></blockquote><h1 id="五-openCV"><a href="#五-openCV" class="headerlink" title="五 openCV"></a>五 openCV</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为3.4.2之后有一些视觉申请了专利，所以我们选择安装环境版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install opencv-python==<span class="hljs-number">3.4</span><span class="hljs-number">.1</span><span class="hljs-number">.15</span><br>pip install opencv-contrib-python==<span class="hljs-number">3.4</span><span class="hljs-number">.1</span><span class="hljs-number">.15</span><br></code></pre></td></tr></table></figure><p>安装完成之后对其检验：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 进入python环境下</span><br>python<br><span class="hljs-keyword">import</span> cv2<br>cv2.__version__<br><span class="hljs-comment"># 如果显示出来版本号即安装成功</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-built_in">print</span>(tf.__version__)<br><span class="hljs-built_in">print</span>(tf.test.is_gpu_available())<br></code></pre></td></tr></table></figure><h2 id="1-图像处理"><a href="#1-图像处理" class="headerlink" title="1 图像处理"></a>1 图像处理</h2><h3 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h3><p><strong>数据读取-图像</strong>：图像分为彩色、灰色图像，实际上彩色图片是分为RGB三个通道组合而成。</p><p>灰度图</p><ul><li>cv2.IMREAD_COLOR：彩色图像</li><li>cv2.IMREAD_GRAYSCALE：灰度图像</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2  <span class="hljs-comment">#opencv读取的格式是BGR</span><br><br>img = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>) <span class="hljs-comment"># 默认就是color</span><br>img = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE) <span class="hljs-comment"># 读取图片为灰度图</span><br><br><span class="hljs-comment">#保存</span><br>cv2.imwrite(<span class="hljs-string">&#x27;mycat.png&#x27;</span>, img)<br></code></pre></td></tr></table></figure><p><strong>数据读取-视频</strong></p><ul><li>cv2.VideoCapture可以捕获摄像头，用数字来控制不同的设备，例如0,1。</li><li>如果是视频文件，直接指定好路径即可。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">vc = cv2.VideoCapture(<span class="hljs-string">&#x27;test.mp4&#x27;</span>)<br><br><span class="hljs-comment"># 检查是否打开正确</span><br><span class="hljs-keyword">if</span> vc.isOpened():<br>    <span class="hljs-comment"># open是读取的标志，frame是每一帧的图像</span><br>    <span class="hljs-built_in">open</span>, frame = vc.read()<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">open</span> = <span class="hljs-literal">False</span><br>    <br><span class="hljs-comment"># 读取视频</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">open</span>:<br>    ret, frame = vc.read()<br>    <span class="hljs-keyword">if</span> frame <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> ret == <span class="hljs-literal">True</span>:<br>        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>        cv2.imshow(<span class="hljs-string">&#x27;result&#x27;</span>, gray)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">50</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-number">27</span>:<br>            <span class="hljs-keyword">break</span><br>vc.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><p><strong>截取部分数据</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>)<br>cat = img[<span class="hljs-number">0</span>:<span class="hljs-number">200</span>, <span class="hljs-number">0</span>:<span class="hljs-number">200</span>]<br>cv_show(<span class="hljs-string">&#x27;cat&#x27;</span>, cat)<br></code></pre></td></tr></table></figure><p><strong>边界填充</strong></p><ul><li>BORDER_REPLICATE：复制法，也就是复制最边缘像素。</li><li>BORDER_REFLECT：反射法，对感兴趣的图像中的像素在两边进行复制例如：fedcba|abcdefgh|hgfedcb   </li><li>BORDER_REFLECT_101：反射法，也就是以最边缘像素为轴，对称，gfedcb|abcdefgh|gfedcba</li><li>BORDER_WRAP：外包装法cdefgh|abcdefgh|abcdefg  </li><li>BORDER_CONSTANT：常量法，常数值填充。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>top_size, bottom_size, left_size, right_size = (<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>)<br><br>replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)<br>reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT)<br>reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT_101)<br>wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_WRAP)<br>constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_CONSTANT, value=<span class="hljs-number">0</span>)<br><br>plt.subplot(<span class="hljs-number">231</span>), plt.imshow(img, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;ORIGINAL&#x27;</span>)<br>plt.subplot(<span class="hljs-number">232</span>), plt.imshow(replicate, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REPLICATE&#x27;</span>)<br>plt.subplot(<span class="hljs-number">233</span>), plt.imshow(reflect, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REFLECT&#x27;</span>)<br>plt.subplot(<span class="hljs-number">234</span>), plt.imshow(reflect101, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REFLECT_101&#x27;</span>)<br>plt.subplot(<span class="hljs-number">235</span>), plt.imshow(wrap, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;WRAP&#x27;</span>)<br>plt.subplot(<span class="hljs-number">236</span>), plt.imshow(constant, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;CONSTANT&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><strong>数值计算</strong>：如果加10，相当于所有均加10，超过256的数值，则需要用当前数值减去256。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">img_cat = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>)<br>img_dog = cv2.imread(<span class="hljs-string">&#x27;dog.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 选择图像数据的前5行，所有列，以及第0个通道</span><br>img_cat[:<span class="hljs-number">5</span>, :, <span class="hljs-number">0</span>]<br><br>img_cat2 = img_cat + <span class="hljs-number">10</span><br>img_cat2[:<span class="hljs-number">5</span>, :, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure><p><strong>图像融合</strong>：两个图像融合必须要shape值相同才能一一对应相加减。</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173702009.png" alt="image-20250319141020278"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前面一个是高度，后面一个是宽度，最后一个是通道数RGB</span><br>img_cat.shape<br><br><span class="hljs-comment"># 记住(500， 414)是图像的大小</span><br>img_dog = cv2.resize(img_dog, (<span class="hljs-number">500</span>, <span class="hljs-number">414</span>))<br>img_dog.shape<br><br><span class="hljs-comment"># 融合。0.4代表前面的图像占40%，后面的图像占60%</span><br>res = cv2.addWeighted(img_cat, <span class="hljs-number">0.4</span>, img_dog, <span class="hljs-number">0.6</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 重新设置图片大小。(0,0)代表左上角，fx代表宽度，fy代表高度</span><br>res = cv2.resize(img, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), fx=<span class="hljs-number">4</span>, fy=<span class="hljs-number">4</span>)<br>plt.imshow(res)<br></code></pre></td></tr></table></figure><h3 id="1-2-阈值和平滑处理"><a href="#1-2-阈值和平滑处理" class="headerlink" title="1.2 阈值和平滑处理"></a>1.2 阈值和平滑处理</h3><h4 id="1-2-1-HSV"><a href="#1-2-1-HSV" class="headerlink" title="1.2.1 HSV"></a>1.2.1 HSV</h4><ul><li>H - 色调（主波长）。</li><li>S - 饱和度（纯度&#x2F;颜色的阴影）。</li><li>V值（强度）</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">hsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)<br><br>cv2.imshow(<span class="hljs-string">&quot;hsv&quot;</span>, hsv)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure><h4 id="1-2-2-图像阈值"><a href="#1-2-2-图像阈值" class="headerlink" title="1.2.2 图像阈值"></a>1.2.2 图像阈值</h4><p>ret, dst &#x3D; cv2.threshold(src, thresh, maxval, type)</p><ul><li><p>dst： 输出图</p></li><li><p>src： 输入图，只能输入单通道图像，通常来说为灰度图</p></li><li><p>thresh： 阈值</p></li><li><p>maxval： 当像素值超过了阈值（或者小于阈值，根据type来决定），所赋予的值</p></li><li><p>type：二值化操作的类型，包含以下5种类型： cv2.THRESH_BINARY； cv2.THRESH_BINARY_INV； cv2.THRESH_TRUNC； cv2.THRESH_TOZERO；cv2.THRESH_TOZERO_INV</p></li><li><p>cv2.THRESH_BINARY           超过阈值部分取maxval（最大值），否则取0</p></li><li><p>cv2.THRESH_BINARY_INV      THRESH_BINARY的反转</p></li><li><p>cv2.THRESH_TRUNC            大于阈值部分设为阈值，否则不变</p></li><li><p>cv2.THRESH_TOZERO           大于阈值部分不改变，否则设为0</p></li><li><p>cv2.THRESH_TOZERO_INV  THRESH_TOZERO的反转</p></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">ret, thresh1 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, thresh2 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, thresh3 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, thresh4 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, thresh5 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">&#x27;Original Image&#x27;</span>, <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-string">&#x27;BINARY_INV&#x27;</span>, <span class="hljs-string">&#x27;TRUNC&#x27;</span>, <span class="hljs-string">&#x27;TOZERO&#x27;</span>, <span class="hljs-string">&#x27;TOZERO_INV&#x27;</span>]<br>images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i])<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173708312.png" alt="image-20250319142521046"></p><h4 id="1-2-3图像平滑"><a href="#1-2-3图像平滑" class="headerlink" title="1.2.3图像平滑"></a>1.2.3图像平滑</h4><blockquote><p>均值滤波：将滤波器覆盖范围内的所有像素值相加，然后除以滤波器的元素个数，得到均值并更新。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 均值滤波</span><br><span class="hljs-comment"># 简单的平均卷积操作</span><br>blur = cv2.blur(img, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173711376.png" alt="image-20250319144047951" style="zoom: 50%;" /><p>方框滤波：基本和均值滤波一样，可以选择归一化（normalize&#x3D;True）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># True的话和均值滤波一模一样</span><br>box = cv2.boxFilter(img,-<span class="hljs-number">1</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173713668.png" alt="image-20250319144618220" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以不选择归一化,容易越界，造成曝光</span><br>box = cv2.boxFilter(img,-<span class="hljs-number">1</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), normalize=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173716375.png" alt="image-20250319144733135" style="zoom:50%;" /><p>高斯滤波：高斯模糊的卷积核里的数值是满足高斯分布，相当于更重视中间的(离中心越远越不重视)</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># img:输入图像</span><br><span class="hljs-comment"># (5, 5):卷积核的大小</span><br><span class="hljs-comment"># 1: 高斯分布的标准差</span><br>aussian = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173718362.png" alt="image-20250319161205150" style="zoom:50%;" /><p>中值滤波：相当于用中值代替，即先排序，然后直接用中间的值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">median = cv2.medianBlur(img, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 中值滤波</span><br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173722097.png" alt="image-20250319173416236" style="zoom:50%;" /></blockquote><blockquote><p>上诉整合：可以看出中值滤波效果相对最好</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173726443.png" alt="image-20250319173540170" style="zoom:50%;" /><h3 id="1-3-图像形态学操作"><a href="#1-3-图像形态学操作" class="headerlink" title="1.3 图像形态学操作"></a>1.3 图像形态学操作</h3><h4 id="1-3-1-腐蚀操作"><a href="#1-3-1-腐蚀操作" class="headerlink" title="1.3.1 腐蚀操作"></a>1.3.1 腐蚀操作</h4><blockquote><p><strong>腐蚀操作（Erosion）</strong>：是图像处理和计算机视觉中的一种基本的形态学操作。它主要用于减少图像中的噪声、细化图像中的对象、断开相邻的对象等。腐蚀操作通常应用于二值图像，但也可以用于灰度图像</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173731590.png" alt="image-20250319174509918" style="zoom:50%;" /><p><strong>我们可以看出相较于之前未处理的图片来说，腐蚀操作将噪声进行了处理，同时字体变小了</strong></p><h4 id="1-3-2-膨胀操作"><a href="#1-3-2-膨胀操作" class="headerlink" title="1.3.2 膨胀操作"></a>1.3.2 膨胀操作</h4><blockquote><p>**膨胀操作（Dilation）：**图像处理和计算机视觉中的一种基本的形态学操作。它主要用于扩大图像中的前景对象，通常用于填补对象中的小孔洞，连接相邻的对象，或者增加对象的边界。膨胀操作通常与腐蚀操作（Erosion）结合使用，以实现更复杂的图像处理任务。</p></blockquote><h4 id="1-3-3-开运算和闭运算"><a href="#1-3-3-开运算和闭运算" class="headerlink" title="1.3.3 开运算和闭运算"></a>1.3.3 开运算和闭运算</h4><blockquote><p>**开运算：**先腐蚀，再膨胀。</p></blockquote><blockquote><p>**闭运算：**先膨胀，再腐蚀。</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173734492.png" alt="image-20250319175231526" style="zoom:50%;" /><h4 id="1-3-4-梯度计算"><a href="#1-3-4-梯度计算" class="headerlink" title="1.3.4 梯度计算"></a>1.3.4 梯度计算</h4><p>**梯度运算：**梯度&#x3D;膨胀-腐蚀，可以理解为就是轮廓边缘检测。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 梯度=膨胀-腐蚀</span><br>pie = cv2.imread(<span class="hljs-string">&#x27;pie.png&#x27;</span>)<br>kernel = np.ones((<span class="hljs-number">7</span>,<span class="hljs-number">7</span>),np.uint8)<br>dilate = cv2.dilate(pie,kernel,iterations = <span class="hljs-number">5</span>)<br>erosion = cv2.erode(pie,kernel,iterations = <span class="hljs-number">5</span>)<br><br>res = np.hstack((dilate,erosion))<br><br>cv_show(<span class="hljs-string">&#x27;res&#x27;</span>, res)<br></code></pre></td></tr></table></figure><h4 id="1-3-5-礼帽与黑帽"><a href="#1-3-5-礼帽与黑帽" class="headerlink" title="1.3.5 礼帽与黑帽"></a>1.3.5 礼帽与黑帽</h4><ul><li>礼帽 &#x3D; 原始输入-开运算结果</li></ul><blockquote><p>留下的就是去除掉的噪声</p></blockquote><ul><li>黑帽 &#x3D; 闭运算-原始输入</li></ul><blockquote><p>去除效果不佳</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173736955.png" alt="image-20250319175921036" style="zoom:50%;" /><h3 id="1-4-图像梯度"><a href="#1-4-图像梯度" class="headerlink" title="1.4 图像梯度"></a>1.4 图像梯度</h3><h4 id="1-4-1-sobel算子"><a href="#1-4-1-sobel算子" class="headerlink" title="1.4.1 sobel算子"></a>1.4.1 sobel算子</h4><p>**sobel算子：**使用两个3x3的卷积核分别在水平和垂直方向上对图像进行卷积操作，从而得到图像在两个方向上的梯度值。</p><p><img src="E:\Markdown\img\sobel_1.png" alt="sobel_1"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># CV_64F相当于把负数保留下来；1表示x方向，0表示y方向，两者合起来相当于只要水平方向；ksize表示卷积核的大小</span><br>sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># 这里只显示了左边的半个框，因为始终是右边减去左边，所以只显示左边的半个框</span><br>cv_show(sobelx, <span class="hljs-string">&#x27;sobelx&#x27;</span>) <br></code></pre></td></tr></table></figure><p>具体实现步骤：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 白到黑是正数，黑到白就是负数了，所有的负数会被截断成0，所以要取绝对值</span><br>sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">3</span>)<br>sobelx = cv2.convertScaleAbs(sobelx)<br>cv_show(sobelx, <span class="hljs-string">&#x27;sobelx&#x27;</span>)<br><br>sobely = cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,ksize=<span class="hljs-number">3</span>)<br>sobely = cv2.convertScaleAbs(sobely)  <br>cv_show(sobely,<span class="hljs-string">&#x27;sobely&#x27;</span>)<br><br><span class="hljs-comment"># 分别计算再求和</span><br>sobelxy = cv2.addWeighted(sobelx,<span class="hljs-number">0.5</span>,sobely,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>)<br>cv_show(sobelxy,<span class="hljs-string">&#x27;sobelxy&#x27;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>不建议直接计算，效果很差！！！</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173739738.png" alt="image-20250319191532319" style="zoom: 67%;" /><h4 id="1-4-2-Scharr算子"><a href="#1-4-2-Scharr算子" class="headerlink" title="1.4.2 Scharr算子"></a>1.4.2 Scharr算子</h4><p><img src="E:\Markdown\img\scharr-1742278952995-2.png" alt="scharr"></p><h4 id="1-4-3-laplacian算子"><a href="#1-4-3-laplacian算子" class="headerlink" title="1.4.3 laplacian算子"></a>1.4.3 laplacian算子</h4><p>噪音点比较敏感</p><p><img src="E:\Markdown\img\l.png" alt="l"></p><p>三个算子对比图（从左2至右分别是sobel、scharrx、laplacian）：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173742746.png" alt="image-20250319191811454" style="zoom:67%;" /><h3 id="1-5-边缘检测"><a href="#1-5-边缘检测" class="headerlink" title="1.5 边缘检测"></a>1.5 边缘检测</h3><p>Canny边缘检测</p><ul><li><ol><li><pre><code class="hljs">   使用高斯滤波器，以平滑图像，滤除噪声。</code></pre></li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173747933.png" alt="canny_1" style="zoom:50%;" /></li><li><ol start="2"><li><pre><code class="hljs">   计算图像中每个像素点的梯度强度和方向。</code></pre></li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173752403.png" alt="canny_2" style="zoom: 50%;" /></li><li><ol start="3"><li><pre><code class="hljs">   应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。</code></pre></li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173755911.png" alt="canny_3" style="zoom:50%;" /><img src="E:\Markdown\img\canny_4.png" alt="canny_4" style="zoom:50%;" /></li><li><ol start="4"><li><pre><code class="hljs">   应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。</code></pre></li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173758902.png" alt="canny_5" style="zoom:50%;" /></li><li><ol start="5"><li><pre><code class="hljs">   通过抑制孤立的弱边缘最终完成边缘检测。</code></pre></li></ol></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">img=cv2.imread(<span class="hljs-string">&quot;car.png&quot;</span>,cv2.IMREAD_GRAYSCALE)<br><br><span class="hljs-comment"># 二值设定不同，展现出来的效果就不同</span><br>v1=cv2.Canny(img,<span class="hljs-number">120</span>,<span class="hljs-number">250</span>)<br>v2=cv2.Canny(img,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)<br><br>res = np.hstack((v1,v2))<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173808188.png" alt="image-20250319192157423" style="zoom:50%;" /><h3 id="1-6-图像金字塔"><a href="#1-6-图像金字塔" class="headerlink" title="1.6 图像金字塔"></a>1.6 图像金字塔</h3><h4 id="1-6-1-高斯金字塔"><a href="#1-6-1-高斯金字塔" class="headerlink" title="1.6.1 高斯金字塔"></a>1.6.1 高斯金字塔</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173811652.png" alt="Pyramid_1" style="zoom:50%;" /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">高斯金字塔：向下采样方法（图像缩小，提取特征，降噪）<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173817518.png" alt="Pyramid_2" style="zoom:50%;" /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">高斯金字塔：向上采样方法（图像放大，生成模型，恢复细节）<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173820289.png" alt="Pyramid_3" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">img=cv2.imread(<span class="hljs-string">&quot;AM.png&quot;</span>)<br>cv_show(img,<span class="hljs-string">&#x27;img&#x27;</span>)<br><span class="hljs-built_in">print</span> (img.shape)<br><br>up=cv2.pyrUp(img)<br>cv_show(up,<span class="hljs-string">&#x27;up&#x27;</span>)<br><span class="hljs-built_in">print</span> (up.shape)<br><br>down=cv2.pyrDown(img)<br>cv_show(down,<span class="hljs-string">&#x27;down&#x27;</span>)<br><span class="hljs-built_in">print</span> (down.shape)<br><br>up2=cv2.pyrUp(up)<br>cv_show(up2,<span class="hljs-string">&#x27;up2&#x27;</span>)<br><span class="hljs-built_in">print</span> (up2.shape)<br><br>up=cv2.pyrUp(img)<br>up_down=cv2.pyrDown(up)<br>cv_show(up_down,<span class="hljs-string">&#x27;up_down&#x27;</span>)<br><br>cv_show(np.hstack((img,up_down)),<span class="hljs-string">&#x27;up_down&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173824171.png" alt="image-20250319192428274" style="zoom:50%;" /><h4 id="1-6-2-拉普拉斯金字塔"><a href="#1-6-2-拉普拉斯金字塔" class="headerlink" title="1.6.2 拉普拉斯金字塔"></a>1.6.2 拉普拉斯金字塔</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173827560.png" alt="Pyramid_4" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">up=cv2.pyrUp(img)<br>up_down=cv2.pyrDown(up)<br>cv_show(img-up_down,<span class="hljs-string">&#x27;img-up_down&#x27;</span>)<br><br>down=cv2.pyrDown(img)<br>down_up=cv2.pyrUp(down)<br>l_1=img-down_up<br>cv_show(l_1,<span class="hljs-string">&#x27;l_1&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173831333.png" alt="image-20250319193325256" style="zoom: 67%;" /><h3 id="1-7-图像轮廓"><a href="#1-7-图像轮廓" class="headerlink" title="1.7 图像轮廓"></a>1.7 图像轮廓</h3><p>操作解析：</p><blockquote><p>cv2.findContours(img, mode,method)</p><p>mode：轮廓检索模式</p><ul><li>RETR_EXTERNAL ：只检索最外面的轮廓；</li><li>RETR_LIST：检索所有的轮廓，并将其保存到一条链表当中；</li><li>RETR_CCOMP：检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界;</li><li>RETR_TREE：检索所有的轮廓，并重构嵌套轮廓的整个层次;</li></ul><p>method：轮廓逼近方法</p><ul><li>CHAIN_APPROX_NONE：以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）。</li><li>CHAIN_APPROX_SIMPLE：压缩水平的、垂直的和斜的部分，也就是，函数只保留他们的终点部分。</li></ul></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173834572.png" alt="chain" style="zoom: 67%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 为了更高的准确率，使用二值图像</span><br>img = cv2.imread(<span class="hljs-string">&#x27;car.png&#x27;</span>)<br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv_show(thresh,<span class="hljs-string">&#x27;thresh&#x27;</span>)<br><br>binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br></code></pre></td></tr></table></figure><p>绘制轮廓</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意需要copy,要不原图会变。</span><br>draw_img = img.copy()<br><span class="hljs-comment"># 传入绘制图像，轮廓，轮廓索引，颜色模式，线条厚度</span><br>res = cv2.drawContours(draw_img, contours, -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173837687.png" alt="image-20250319193949988" style="zoom:50%;" /><p>轮廓特征</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># (5, 1, 2)</span><br>cnt = contours[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">#面积</span><br>cv2.contourArea(cnt)<br><br><span class="hljs-comment">#周长，True表示闭合的</span><br>cv2.arcLength(cnt, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><p>轮廓近似</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;contours2.png&#x27;</span>)<br><span class="hljs-comment"># 将图像转换为灰度图像</span><br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><br><span class="hljs-comment"># 对灰度图像进行二值化处理</span><br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><span class="hljs-comment"># 查找图像中的轮廓</span><br>binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br><span class="hljs-comment"># 选择第一个轮廓</span><br><br>cnt = contours[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 复制原图像，用于绘制轮廓</span><br>draw_img = img.copy()<br><span class="hljs-comment"># 在复制的图像上绘制选定的轮廓</span><br>res = cv2.drawContours(draw_img, [cnt], -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 显示绘制了轮廓的图像</span><br>cv_show(res, <span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173841108.png" alt="image-20250319202106877" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算轮廓的弧长</span><br>epsilon = <span class="hljs-number">0.1</span> * cv2.arcLength(cnt, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 近似轮廓</span><br>approx = cv2.approxPolyDP(cnt, epsilon, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 复制原始图像</span><br>draw_img = img.copy()<br><span class="hljs-comment"># 绘制近似轮廓，[approx]：包含近似轮廓的列表。注意这里是一个列表，即使只有一个轮廓</span><br>res = cv2.drawContours(draw_img, [approx], -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv_show(res, <span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173844024.png" alt="image-20250319202133764" style="zoom:50%;" /><blockquote><p>注：这个不规整主要是跟计算轮廓的0.1有关</p></blockquote><p>边界矩形：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;contours.png&#x27;</span>)<br><br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br>cnt = contours[<span class="hljs-number">5</span>]<br><br>x,y,w,h = cv2.boundingRect(cnt)<br>img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)<br>cv_show(img,<span class="hljs-string">&#x27;img&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173847483.png" alt="image-20250319202702057" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">area = cv2.contourArea(cnt)<br>x, y, w, h = cv2.boundingRect(cnt)<br>rect_area = w * h<br>extent = <span class="hljs-built_in">float</span>(area) / rect_area<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;轮廓面积与边界矩形比&#x27;</span>,extent)<br></code></pre></td></tr></table></figure><blockquote><p>输出结果：轮廓面积与边界矩形比 0.5154317244724715</p></blockquote><p>外接圆</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(x, y), radius = cv2.minEnclosingCircle(cnt)<br>center = (<span class="hljs-built_in">int</span>(x), <span class="hljs-built_in">int</span>(y))<br>radius = <span class="hljs-built_in">int</span>(radius)<br>img = cv2.circle(img, center, radius, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>cv_show(img, <span class="hljs-string">&#x27;img&#x27;</span>)<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173850298.png" alt="image-20250319202857356" style="zoom:50%;" /><h3 id="1-8-模板匹配"><a href="#1-8-模板匹配" class="headerlink" title="1.8 模板匹配"></a>1.8 模板匹配</h3><blockquote><p>模板匹配和卷积原理很像，模板在原图像上从原点开始滑动，计算模板与（图像被模板覆盖的地方）的差别程度，这个差别程度的计算方法在opencv里有6种，然后将每次计算的结果放入一个矩阵里，作为结果输出。假如原图形是AxB大小，而模板是axb大小，则输出结果的矩阵是(A-a+1)x(B-b+1)</p></blockquote><ul><li>TM_SQDIFF：计算平方不同，计算出来的值越小，越相关        </li><li>TM_CCORR：计算相关性，计算出来的值越大，越相关</li><li>TM_CCOEFF：计算相关系数，计算出来的值越大，越相关</li><li>TM_SQDIFF_NORMED：计算归一化平方不同，计算出来的值越接近0，越相关</li><li>TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关</li><li>TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">methods = [<span class="hljs-string">&#x27;cv2.TM_CCOEFF&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_CCOEFF_NORMED&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_CCORR&#x27;</span>,<br>           <span class="hljs-string">&#x27;cv2.TM_CCORR_NORMED&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_SQDIFF&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_SQDIFF_NORMED&#x27;</span>]<br><br><span class="hljs-comment"># 计算模板匹配</span><br>res = cv2.matchTemplate(img, template, cv2.TM_SQDIFF)<br>res.shape<br><br>min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)<br><br><span class="hljs-keyword">for</span> meth <span class="hljs-keyword">in</span> methods:<br>    img2 = img.copy()<br><br>    <span class="hljs-comment"># 匹配方法的真值</span><br>    method = <span class="hljs-built_in">eval</span>(meth)<br>    <span class="hljs-built_in">print</span>(method)<br>    res = cv2.matchTemplate(img, template, method)<br>    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)<br><br>    <span class="hljs-comment"># 如果是平方差匹配TM_SQDIFF或归一化平方差匹配TM_SQDIFF_NORMED，取最小值</span><br>    <span class="hljs-keyword">if</span> method <span class="hljs-keyword">in</span> [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:<br>        top_left = min_loc<br>    <span class="hljs-keyword">else</span>:<br>        top_left = max_loc<br>    bottom_right = (top_left[<span class="hljs-number">0</span>] + w, top_left[<span class="hljs-number">1</span>] + h)<br><br>    <span class="hljs-comment"># 画矩形</span><br>    cv2.rectangle(img2, top_left, bottom_right, <span class="hljs-number">255</span>, <span class="hljs-number">2</span>)<br><br>    plt.subplot(<span class="hljs-number">121</span>), plt.imshow(res, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 隐藏坐标轴</span><br>    plt.subplot(<span class="hljs-number">122</span>), plt.imshow(img2, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.xticks([]), plt.yticks([])<br>    plt.suptitle(meth, c=<span class="hljs-string">&#x27;w&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173857774.png" alt="image-20250319204828072"><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173906813.png" alt="image-20250319204901151"></p><p>匹配多个对象（超级玛丽的小金币）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">img_rgb = cv2.imread(<span class="hljs-string">&#x27;mario.jpg&#x27;</span>)<br>img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)<br>template = cv2.imread(<span class="hljs-string">&#x27;mario_coin.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br>h, w = template.shape[:<span class="hljs-number">2</span>]<br><br>res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)<br>threshold = <span class="hljs-number">0.8</span><br><span class="hljs-comment"># 取匹配程度大于%80的坐标</span><br>loc = np.where(res &gt;= threshold)<br><span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*loc[::-<span class="hljs-number">1</span>]):  <span class="hljs-comment"># *号表示可选参数</span><br>    bottom_right = (pt[<span class="hljs-number">0</span>] + w, pt[<span class="hljs-number">1</span>] + h)<br>    cv2.rectangle(img_rgb, pt, bottom_right, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br>cv2.imshow(<span class="hljs-string">&#x27;img_rgb&#x27;</span>, img_rgb)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173914806.png" alt="image-20250319204943249"></p><h3 id="1-9-直方图"><a href="#1-9-直方图" class="headerlink" title="1.9 直方图"></a>1.9 直方图</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173917399.png" alt="hist_1" style="zoom: 50%;" /><p>cv2.calcHist(images,channels,mask,histSize,ranges)</p><ul><li>images: 原图像图像格式为 uint8 或 ﬂoat32。当传入函数时应 用中括号 [] 括来例如[img]</li><li>channels: 同样用中括号括来它会告函数我们统幅图 像的直方图。如果入图像是灰度图它的值就是 [0]如果是彩色图像 的传入的参数可以是 [0][1][2] 它们分别对应着 BGR。 </li><li>mask: 掩模图像。统整幅图像的直方图就把它为 None。但是如果你想统图像某一分的直方图的你就制作一个掩模图像并使用它。</li><li>histSize:BIN 的数目。也应用中括号括来</li><li>ranges: 像素值范围常为 [0, 256]</li></ul><p>直方图均衡化：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;clahe.jpg&#x27;</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">#0表示灰度图 #clahe</span><br>plt.hist(img.ravel(),<span class="hljs-number">256</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173922007.png" alt="image-20250319204303994" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">equ = cv2.equalizeHist(img) <br>plt.hist(equ.ravel(),<span class="hljs-number">256</span>)<br>plt.show()<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173924308.png" alt="image-20250319204327529" style="zoom:50%;" /><h3 id="1-10-傅里叶变换"><a href="#1-10-傅里叶变换" class="headerlink" title="1.10 傅里叶变换"></a>1.10 傅里叶变换</h3><blockquote><p>我们生活在时间的世界中，早上7:00起来吃早饭，8:00去挤地铁，9:00开始上班。。。以时间为参照就是时域分析。</p><p>但是在频域中一切都是静止的！</p><p><a href="https://zhuanlan.zhihu.com/p/19763358">https://zhuanlan.zhihu.com/p/19763358</a></p></blockquote><p><strong>傅里叶变换的作用</strong></p><ul><li><p>高频：变化剧烈的灰度分量，例如边界</p></li><li><p>低频：变化缓慢的灰度分量，例如一片大海</p></li></ul><p><strong>滤波</strong></p><ul><li><p>低通滤波器：只保留低频，会使得图像模糊</p></li><li><p>高通滤波器：只保留高频，会使得图像细节增强</p></li></ul><p><strong>操作流程：</strong></p><ul><li>opencv中主要就是cv2.dft()和cv2.idft()，输入图像需要先转换成np.float32 格式。</li><li>得到的结果中频率为0的部分会在左上角，通常要转换到中心位置，可以通过shift变换来实现。</li><li>cv2.dft()返回的结果是双通道的（实部，虚部），通常还需要转换成图像格式才能展示（0,255）。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br>dft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><span class="hljs-comment"># 得到灰度图能表示的形式</span><br>magnitude_spectrum = <span class="hljs-number">20</span> * np.log(cv2.magnitude(dft_shift[:, :, <span class="hljs-number">0</span>], dft_shift[:, :, <span class="hljs-number">1</span>]))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Magnitude Spectrum&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173928562.png" alt="image-20250319203356606"></p><blockquote><p>上面输出的图片中，input Image由 dft 变换后的图片，Magnitude Spectrum是频谱图</p><p>Magnitude Spectrum由 idft 可转化为input Image</p></blockquote><p>低通滤波：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br><span class="hljs-comment"># 傅里叶变换</span><br>dft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><br>rows, cols = img.shape<br>crow, ccol = <span class="hljs-built_in">int</span>(rows / <span class="hljs-number">2</span>), <span class="hljs-built_in">int</span>(cols / <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 低通滤波</span><br>mask = np.zeros((rows, cols, <span class="hljs-number">2</span>), np.uint8)<br>mask[crow - <span class="hljs-number">30</span>:crow + <span class="hljs-number">30</span>, ccol - <span class="hljs-number">30</span>:ccol + <span class="hljs-number">30</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># IDFT</span><br>fshift = dft_shift * mask<br>f_ishift = np.fft.ifftshift(fshift)<br>img_back = cv2.idft(f_ishift)  <span class="hljs-comment">#之前转换到中间了，这是转换回去，但是这是实部 虚部双通道不能绘图观看</span><br>img_back = cv2.magnitude(img_back[:, :, <span class="hljs-number">0</span>], img_back[:, :, <span class="hljs-number">1</span>])  <span class="hljs-comment"># 合并实部虚部</span><br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(img_back, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Result&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br><br>plt.show()                <br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173931795.png" alt="image-20250319203922133"></p><p>高通滤波：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br>dft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><br>rows, cols = img.shape<br>crow, ccol = <span class="hljs-built_in">int</span>(rows / <span class="hljs-number">2</span>), <span class="hljs-built_in">int</span>(cols / <span class="hljs-number">2</span>)  <span class="hljs-comment"># 中心位置</span><br><br><span class="hljs-comment"># 高通滤波</span><br>mask = np.ones((rows, cols, <span class="hljs-number">2</span>), np.uint8)<br>mask[crow - <span class="hljs-number">30</span>:crow + <span class="hljs-number">30</span>, ccol - <span class="hljs-number">30</span>:ccol + <span class="hljs-number">30</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># IDFT</span><br>fshift = dft_shift * mask<br>f_ishift = np.fft.ifftshift(fshift)<br>img_back = cv2.idft(f_ishift)<br>img_back = cv2.magnitude(img_back[:, :, <span class="hljs-number">0</span>], img_back[:, :, <span class="hljs-number">1</span>])<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>, c = <span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(img_back, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Result&#x27;</span>, c = <span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br><br>plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173934317.png" alt="image-20250319203947157"></p><blockquote><p><strong>总结</strong><br>为什么我们会转换到频域当中做处理？</p><ul><li>因为在频域中，我们可以很容易的分离出图像的高频和低频部分，然后通过滤波的方式，去除图像中的噪声，或者是增强图像的细节。</li><li>这样的方式更加的高效，而且更加的方便。</li></ul></blockquote><h2 id="2-背景建模"><a href="#2-背景建模" class="headerlink" title="2 背景建模"></a>2 背景建模</h2><p>帧差法</p><blockquote><p>由于场景中的目标在运动，目标的影像在不同图像帧中的位置不同。该类算法对<strong>时间上连续的两帧图像</strong>进行<strong>差分运算</strong>，不同帧对应的像素点相减，判断灰度差的绝对值，当绝对值超过一定阈值时，即可判断为运动目标，从而实现目标的检测功能。</p></blockquote><blockquote><p>帧差法非常简单，但是会引入噪音和空洞问题</p></blockquote><h2 id="3-label标注"><a href="#3-label标注" class="headerlink" title="3 label标注"></a>3 label标注</h2><blockquote><p>安装：pip install labelme</p><p>启动：labelme</p></blockquote><h1 id="六-爬虫相关"><a href="#六-爬虫相关" class="headerlink" title="六 爬虫相关"></a>六 爬虫相关</h1><h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1 正则表达式"></a>1 正则表达式</h2><p>Regular Expression，正则表达式，一种使用表达式的方式对字符串进行匹配的语法规则。</p><p>正则的语法: </p><blockquote><p> 使用元字符进行排列组合用来匹配字符串，<a href="https://tool.oschina.net/regex">在线测试正则表达式</a></p></blockquote><p>元字符：具有固定含义的特殊符号</p><p>常用元字符：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">.       匹配除换行符以外的任意字符<br>\w      匹配字母或数字或下划线<br>\s      匹配任意的空白符<br>\d      匹配数字<br>\n      匹配一个换行符<br>\t      匹配一个制表符<br><br>^       匹配字符串的开始<br>$       匹配字符串的结尾<br><br>\W      匹配非字母或数字或下划线<br>\S      匹配非空白符<br>\D      匹配非数字<br>a|b     匹配字符a或字符b<br>()      匹配括号内的表达式，也表示一个组<br>[...]   匹配字符组中的字符<br>[^...]  匹配除了字符组中字符的所有字符<br></code></pre></td></tr></table></figure><p>量词：控制前面的元字符出现的次数</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span>     重复零次或更多次<br><span class="hljs-bullet">+</span>     重复一次或更多次<br>?     重复零次或一次<br>&#123;n&#125;   重复n次<br>&#123;n,&#125;  重复n次或更多次<br>&#123;n,m&#125; 重复n到m次<br></code></pre></td></tr></table></figure><p>贪婪匹配和惰性匹配</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">.*    贪婪匹配<br>.*?   惰性匹配<br></code></pre></td></tr></table></figure><h2 id="2-re模块"><a href="#2-re模块" class="headerlink" title="2 re模块"></a>2 re模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># # findall：匹配字符串中所有符合正则的内容</span><br><span class="hljs-comment"># lst = re.findall(&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># print(lst)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # finditer：匹配字符串中所有的内容【返回的是迭代器】，从迭代器中拿数据需要.group()</span><br><span class="hljs-comment"># it = re.finditer(&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># for item in it:</span><br><span class="hljs-comment">#     print(item.group())</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # search：匹配字符串中第一个符合正则的内容，拿数据需要.group()</span><br><span class="hljs-comment"># s = re.search(r&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment"># print(s.group())</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # match：从头开始匹配</span><br><span class="hljs-comment"># match = re.match(r&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment"># print(match)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # 预加载正则表达式</span><br><span class="hljs-comment"># pattern = re.compile(r&quot;\d+&quot;)</span><br><span class="hljs-comment"># print(pattern.findall(&quot;我的电话是10086，我女朋友的电话是10010&quot;))</span><br><br><span class="hljs-comment"># (?P&lt;分组名字&gt;正则) 可以单独从正则匹配的内容中进一步提取到目标数据</span><br>s = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;div class=&#x27;jay&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;郭麒麟&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;jj&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;宋铁&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;join&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;大聪明&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;solar&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;范思哲&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;tory&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;胡说八道&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;div class=&#x27;(?P&lt;class&gt;.*?)&#x27;&gt;&lt;span id=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;</span>, re.S)<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> obj.finditer(s):<br>    <span class="hljs-built_in">print</span>(item.group(<span class="hljs-string">&quot;class&quot;</span>))<br>    <span class="hljs-built_in">print</span>(item.group(<span class="hljs-string">&quot;id&quot;</span>))<br>    <span class="hljs-built_in">print</span>(item.group(<span class="hljs-string">&quot;name&quot;</span>))<br></code></pre></td></tr></table></figure><h2 id="3-request模块"><a href="#3-request模块" class="headerlink" title="3 request模块"></a>3 request模块</h2><h3 id="3-1-人名搜索"><a href="#3-1-人名搜索" class="headerlink" title="3.1 人名搜索"></a>3.1 人名搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_html</span>(<span class="hljs-params">url</span>):<br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#x27;</span><br>    &#125;<br>    resp = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">return</span> resp.text<br><br>query = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你想查询的人名：&quot;</span>)<br><br>url = <span class="hljs-string">f&#x27;https://www.sogou.com/web?query=<span class="hljs-subst">&#123;query&#125;</span>&#x27;</span><br><br><span class="hljs-built_in">print</span>(get_html(url))<br></code></pre></td></tr></table></figure><h3 id="3-2-百度翻译"><a href="#3-2-百度翻译" class="headerlink" title="3.2 百度翻译"></a>3.2 百度翻译</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://fanyi.baidu.com/sug&#x27;</span><br><br>query = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你想查询的单词：&quot;</span>)<br><br>data = &#123;<br>    <span class="hljs-string">&#x27;kw&#x27;</span>: query<br>&#125;<br><br>resp = requests.post(url, data=data)<br><br><span class="hljs-built_in">print</span>(resp.json())<br>resp.close()<br></code></pre></td></tr></table></figure><h3 id="3-3-豆瓣电影"><a href="#3-3-豆瓣电影" class="headerlink" title="3.3 豆瓣电影"></a>3.3 豆瓣电影</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span><br><br>params = &#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;24&quot;</span>,<br>    <span class="hljs-string">&quot;interval_id&quot;</span>: <span class="hljs-string">&quot;100:90&quot;</span>,<br>    <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;limit&quot;</span>: <span class="hljs-number">20</span><br>&#125;<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#x27;</span><br>&#125;<br><br>resp = requests.get(url, params=params, headers=headers)<br><br><span class="hljs-built_in">print</span>(resp.request.headers)<br><span class="hljs-built_in">print</span>(resp.json())<br><br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;movie.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).write(resp.text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ok&quot;</span>)<br><br>resp.close()<br></code></pre></td></tr></table></figure><h2 id="4-实战模块"><a href="#4-实战模块" class="headerlink" title="4 实战模块"></a>4 实战模块</h2><h3 id="4-1-bs4图片下载"><a href="#4-1-bs4图片下载" class="headerlink" title="4.1 bs4图片下载"></a>4.1 bs4图片下载</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span><br><br>params = &#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;24&quot;</span>,<br>    <span class="hljs-string">&quot;interval_id&quot;</span>: <span class="hljs-string">&quot;100:90&quot;</span>,<br>    <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;limit&quot;</span>: <span class="hljs-number">20</span><br>&#125;<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#x27;</span><br>&#125;<br><br>resp = requests.get(url, params=params, headers=headers)<br><br><span class="hljs-built_in">print</span>(resp.request.headers)<br><span class="hljs-built_in">print</span>(resp.json())<br><br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;movie.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).write(resp.text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ok&quot;</span>)<br><br>resp.close()<br></code></pre></td></tr></table></figure><h3 id="4-2-盗版天堂"><a href="#4-2-盗版天堂" class="headerlink" title="4.2 盗版天堂"></a>4.2 盗版天堂</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># 拿到页面源代码 request</span><br><span class="hljs-comment"># 通过re来提取想要的有效信息 re</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br>url = <span class="hljs-string">&#x27;https://www.dytt8899.com/&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36 Edg/135.0.0.0&#x27;</span><br>&#125;<br><br>resp = requests.get(url, headers=headers, verify=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># verify=False 忽略证书</span><br>resp.encoding = <span class="hljs-string">&#x27;gb2312&#x27;</span><br><span class="hljs-comment"># print(resp.text)</span><br><br>ul = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;2025必看热片.*?&lt;ul&gt;(?P&lt;content&gt;.*?)&lt;/ul&gt;&quot;</span>, re.S)<br>movie_href = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;a href=&#x27;(?P&lt;href&gt;.*?)&#x27;&quot;</span>, re.S)<br>movie_name = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;◎片　　名(?P&lt;name&gt;.*?)&lt;br /&gt;.*?&lt;td &#x27;</span><br>                        <span class="hljs-string">r&#x27;style=&quot;WORD-WRAP: break-word&quot; bgcolor=&quot;#fdfddf&quot;&gt;&lt;a href=&quot;(?P&lt;download&gt;.*?)&quot;&#x27;</span>, re.S)<br><br>res = ul.finditer(resp.text)<br>child_href_list = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> res:<br>    content = item.group(<span class="hljs-string">&quot;content&quot;</span>)<br>    <span class="hljs-comment"># 提取子页面链接</span><br>    movie_url = movie_href.finditer(content)<br>    <span class="hljs-keyword">for</span> movie_item <span class="hljs-keyword">in</span> movie_url:<br>        all_url =url + movie_item.group(<span class="hljs-string">&quot;href&quot;</span>).strip(<span class="hljs-string">&quot;/&quot;</span>)<br>        child_href_list.append(all_url)<br><br><span class="hljs-comment"># 提取子页面内容</span><br><span class="hljs-keyword">for</span> child_url <span class="hljs-keyword">in</span> child_href_list:<br>    child_resp = requests.get(child_url, verify=<span class="hljs-literal">False</span>)<br>    child_resp.encoding = <span class="hljs-string">&#x27;gb2312&#x27;</span><br>    <span class="hljs-comment"># print(child_resp.text)</span><br>    <span class="hljs-comment"># 提取片名和下载地址</span><br>    result = movie_name.search(child_resp.text)<br>    <span class="hljs-comment"># 将name和download写入进csv文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;看片爬虫.csv&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;gb2312&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(result.group(<span class="hljs-string">&quot;name&quot;</span>) + <span class="hljs-string">&quot;,&quot;</span> + result.group(<span class="hljs-string">&quot;download&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>机器学习</tag>
      
      <tag>计算机视觉</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringCould</title>
    <link href="/2025/02/28/SpringCloud/"/>
    <url>/2025/02/28/SpringCloud/</url>
    
    <content type="html"><![CDATA[<p>微服务是一种软件架构风格，它是以专注于单一职责的很多小型项目为基础，组合出复杂的大型应用。</p><h1 id="一、Mybatis-Plus"><a href="#一、Mybatis-Plus" class="headerlink" title="一、Mybatis-Plus"></a>一、Mybatis-Plus</h1><h2 id="1-常见注解"><a href="#1-常见注解" class="headerlink" title="1 常见注解"></a>1 常见注解</h2><p><strong>MybatisPlus是如何获取实现CRUD的数据库表信息的?</strong></p><ul><li>默认以类名驼峰转下划线作为表名</li><li>默认把名为id的字段作为主键</li><li>默认把变量名驼峰转下划线作为表的字段名</li></ul><p><strong>MybatisPlus中比较常用的几个注解如下:</strong></p><ul><li>@TableName：用来指定表名</li><li>@Tableld：用来指定表中的主键字段信息</li><li>@TableField：用来指定表中的普通字段信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@TableName(&quot;tb_user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">User</span>&#123;<br>    <span class="hljs-meta">@TableId(value=&quot;id&quot;,type= IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Long id;<br>    <br>    <span class="hljs-meta">@TableField(&quot;username&quot;)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <br>    <span class="hljs-meta">@TableField(&quot;is_married&quot;)</span><br>    <span class="hljs-keyword">private</span> Boolean isMarried;<br>    <br>    <span class="hljs-meta">@TableField(&quot; order&#x27;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer order;<br>    <br>    <span class="hljs-meta">@TableField(exist=false)</span><br>    <span class="hljs-keyword">private</span> String address;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>IdType枚举：</strong></p><ul><li>AUTO：数据库自增长</li><li>INPUT：通过set方法自行输入</li><li>ASSIGN ID：分配lD，接口ldentifierGenerator的方法nextld来生成id</li><li>默认实现类为DefaultldentifierGenerator雪花算法</li></ul><p><strong>使用@TableField的常见场景：</strong></p><ul><li>成员变量名与数据库字段名不一致</li><li>成员变量名以is开头，且是布尔值</li><li>成员变量名与数据库关键字冲突</li><li>成员变量不是数据库字段</li></ul><h2 id="2-常见配置"><a href="#2-常见配置" class="headerlink" title="2 常见配置"></a>2 常见配置</h2><p>MyBatisPlus的配置项继承了MyBatis原生配置和一些自己特有的配置。例如:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>    <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.itheima.mp.domain.po</span>   <span class="hljs-comment"># 别名扫描包</span><br>    <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">&quot;classpath*:/mapper/**/*.xml&quot;</span>  <span class="hljs-comment"># Mapper.xml文件地址，默认值</span><br>    <span class="hljs-attr">configuration:</span><br>      <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span>             <span class="hljs-comment"># 是否开启下划线和驼峰的映射</span><br>      <span class="hljs-attr">cache-enabled:</span> <span class="hljs-literal">false</span>                           <span class="hljs-comment"># 是否开启二级缓存</span><br>    <span class="hljs-attr">global-config:</span><br>      <span class="hljs-attr">db-config:</span><br>        <span class="hljs-attr">id-type:</span> <span class="hljs-string">assign_id</span>                           <span class="hljs-comment"># id为雪花算法生成</span><br>        <span class="hljs-attr">update-strategy:</span> <span class="hljs-string">not_null</span>                    <span class="hljs-comment"># 更新策略:只更新非空字段</span><br></code></pre></td></tr></table></figure><h2 id="3-条件构造器"><a href="#3-条件构造器" class="headerlink" title="3 条件构造器"></a>3 条件构造器</h2><p>条件构造器的用法：</p><ul><li>QueryWrapper和LambdaQueryWrapper通常用来构建select、delete、update的where条件部分</li><li>UpdateWrapper和LambdaUpdateWrapper通常只有在set语句比较特殊才使用</li><li>尽量使用LambdaQueryWrapper和LambdaUpdateWrapper避免硬编码</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.构建查询条件</span><br>    QueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">QueryWrapper</span>&lt;User&gt;()<br>            .select(<span class="hljs-string">&quot;id&quot;</span>, <span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-string">&quot;info&quot;</span>)<br>            .like(<span class="hljs-string">&quot;username&quot;</span>, <span class="hljs-string">&quot;o&quot;</span>)<br>            .ge(<span class="hljs-string">&quot;balance&quot;</span>, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// 2.查询</span><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testLambdaQueryWrapper</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 1.构建查询条件</span><br>    LambdaQueryWrapper&lt;User&gt; wrapper = <span class="hljs-keyword">new</span> <span class="hljs-title class_">LambdaQueryWrapper</span>&lt;User&gt;()<br>            .select(User::getId, User::getUsername, User::getBalance, User::getInfo)<br>            .like(User::getUsername, <span class="hljs-string">&quot;o&quot;</span>)<br>            .ge(User::getBalance, <span class="hljs-number">1000</span>);<br>    <span class="hljs-comment">// 2.查询</span><br>    List&lt;User&gt; users = userMapper.selectList(wrapper);<br>    users.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-自定义SQL"><a href="#4-自定义SQL" class="headerlink" title="4 自定义SQL"></a>4 自定义SQL</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625172929277.png" alt="image-20250425181952713" style="zoom: 67%;" /><p>第③也可用注解的方式合并到第二个</p><h2 id="5-批量新增"><a href="#5-批量新增" class="headerlink" title="5 批量新增"></a>5 批量新增</h2><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> User <span class="hljs-title function_">buidUser</span><span class="hljs-params">(<span class="hljs-type">int</span> i)</span> &#123;<br>    <span class="hljs-keyword">return</span> User.builder()<br>        .username(<span class="hljs-string">&quot;user_&quot;</span> + i)<br>        .password(<span class="hljs-string">&quot;6666&quot;</span>)<br>        .phone(<span class="hljs-string">&quot;&quot;</span> + (<span class="hljs-number">18688990011L</span> + i))<br>        .balance(<span class="hljs-number">1680</span>)<br>        .info(<span class="hljs-string">&quot;&#123;\&quot;age\&quot;: 24, \&quot;intro\&quot;: \&quot;英文老师\&quot;, \&quot;gender\&quot;: \&quot;male\&quot;&#125;&quot;</span>)<br>        .createTime(LocalDateTime.now())<br>        .updateTime(LocalDateTime.now()).build();<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><strong>需求：批量插入10万条用户数据，并作出对比</strong></p></blockquote><ul><li>普通for循环插入，<strong>速度极差，不推荐。</strong></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveOneByOne</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e5</span>; i++) &#123;<br>        userService.save(buidUser(i));<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625172957009.png" alt="image-20250426105950580" style="zoom:67%;" /><ul><li>IService的批量插入，MP的批量新增，基于预编译的批处理，性能不错。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-keyword">void</span> <span class="hljs-title function_">testSaveBatch</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-comment">// 我们每次批量插入1000条数据，插入100次即10万条数据</span><br>    ArrayList&lt;User&gt; userList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(<span class="hljs-number">1000</span>);<br>    <span class="hljs-type">long</span> <span class="hljs-variable">begin</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1e5</span>; i++) &#123;<br>        userList.add(buidUser(i));<br>        <span class="hljs-keyword">if</span> (i % <span class="hljs-number">1000</span> == <span class="hljs-number">0</span>) &#123;<br>            userService.saveBatch(userList);<br>            userList.clear();<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">long</span> <span class="hljs-variable">end</span> <span class="hljs-operator">=</span> System.currentTimeMillis();<br>    System.out.println(<span class="hljs-string">&quot;耗时：&quot;</span> + (end - begin) + <span class="hljs-string">&quot;ms&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173002434.png" alt="image-20250426110811587" style="zoom:67%;" /><ul><li>开启rewriteBatchedStatements&#x3D;true参数，配置jdbc参数，性能最好</li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173007633.png" alt="image-20250426111008718" style="zoom:67%;" /><h2 id="6-扩展功能"><a href="#6-扩展功能" class="headerlink" title="6 扩展功能"></a>6 扩展功能</h2><h3 id="6-1-DB静态工具"><a href="#6-1-DB静态工具" class="headerlink" title="6.1 DB静态工具"></a>6.1 DB静态工具</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> List&lt;UserVO&gt; <span class="hljs-title function_">queryUserAndAddressByIds</span><span class="hljs-params">(List&lt;Long&gt; ids)</span> &#123;<br>    <span class="hljs-comment">//1. 查询用户，且过滤掉冻结用户</span><br>    List&lt;User&gt; users = listByIds(ids).stream().filter(user -&gt; user.getStatus() != <span class="hljs-number">2</span>).collect(Collectors.toList());<br>    <span class="hljs-keyword">if</span> (CollUtil.isEmpty(users)) &#123;<br>        <span class="hljs-keyword">return</span> Collections.emptyList();<br>    &#125;<br>    <span class="hljs-comment">//2. 查询地址</span><br>    <span class="hljs-comment">//2.1 获取用户id集合</span><br>    List&lt;Long&gt; userIds = users.stream().map(User::getId).collect(Collectors.toList());<br><br>    <span class="hljs-comment">//2.2 根据用户id查询地址</span><br>    List&lt;Address&gt; addresses = Db.lambdaQuery(Address.class).in(Address::getUserId, userIds).list();<br>    <span class="hljs-comment">//2.3 地址封装到AddressVO中</span><br>    List&lt;AddressVO&gt; addressVOList = BeanUtil.copyToList(addresses, AddressVO.class);<br>    <span class="hljs-comment">//2.4 将地址按用户id分组</span><br>    Map&lt;Long, List&lt;AddressVO&gt;&gt; addressMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">if</span> (CollUtil.isNotEmpty(addressVOList)) &#123;<br>        addressMap = addressVOList.stream().collect(Collectors.groupingBy(AddressVO::getUserId));<br>    &#125;<br>    <span class="hljs-comment">//3. 将用户封装到UserVO中</span><br>    List&lt;UserVO&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;(users.size());<br>    <span class="hljs-keyword">for</span> (User user : users) &#123;<br>        <span class="hljs-type">UserVO</span> <span class="hljs-variable">vo</span> <span class="hljs-operator">=</span> BeanUtil.copyProperties(user, UserVO.class);<br>        list.add(vo);<br>        vo.setAddresses(addressMap.get(user.getId()));<br>    &#125;<br>    <span class="hljs-keyword">return</span> list;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-2-枚举转换"><a href="#6-2-枚举转换" class="headerlink" title="6.2 枚举转换"></a>6.2 枚举转换</h3><p>如何实现PO类中的枚举类型变量与数据库字段的转换?</p><p>①给枚举中的与数据库对应value值添加@EnumValue注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@EnumValue</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">int</span> value;<br><span class="hljs-meta">@JsonValue</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String desc;<br></code></pre></td></tr></table></figure><p>②在配置文件中配置统一的枚举处理器，实现类型转换</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis-plus:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">default-enum-type-handler:</span> <span class="hljs-string">com.baomidou.mybatisplus.core.handlers.MybatisEnumTypeHandler</span> <span class="hljs-comment"># 枚举返回类</span><br></code></pre></td></tr></table></figure><p>记住实体类也需要更改</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173011712.png" alt="image-20250426201741934" style="zoom:80%;" /><h3 id="6-3-JSON转换"><a href="#6-3-JSON转换" class="headerlink" title="6.3 JSON转换"></a>6.3 JSON转换</h3><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173015207.png" alt="image-20250426203732831"></p><blockquote><p>首先进行实体类的创建</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.itheima.mp.domain.po;<br><br><span class="hljs-keyword">import</span> io.swagger.annotations.ApiModelProperty;<br><span class="hljs-keyword">import</span> lombok.AllArgsConstructor;<br><span class="hljs-keyword">import</span> lombok.Builder;<br><span class="hljs-keyword">import</span> lombok.Data;<br><span class="hljs-keyword">import</span> lombok.NoArgsConstructor;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Title</span>: userInfo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Author</span>: Alaskaboo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Package</span>: mp-demo</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Date</span>: 2025/4/26 20:27</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@description</span>: TODO</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@AllArgsConstructor(staticName = &quot;of&quot;)</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">UserInfo</span> &#123;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;年龄&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;介绍&quot;)</span><br>    <span class="hljs-keyword">private</span> String intro;<br><br>    <span class="hljs-meta">@ApiModelProperty(&quot;性别&quot;)</span><br>    <span class="hljs-keyword">private</span> String gender;<br>&#125;<br><br></code></pre></td></tr></table></figure><blockquote><p>然后将实体类和VO类中的info进行更改为UserInfo类型，同时添加注解：@TableField(typeHandler &#x3D; JacksonTypeHandler.class)，</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment">  * 详细信息</span><br><span class="hljs-comment">  */</span><br><span class="hljs-meta">@TableField(typeHandler = JacksonTypeHandler.class)</span><br><span class="hljs-keyword">private</span> UserInfo info;<br></code></pre></td></tr></table></figure><blockquote><p>最后进行User实体类上面的@TableName(value &#x3D; “tb_user”, autoResultMap &#x3D; true)，开始autoResultMap自动映射</p></blockquote><h3 id="6-4-插件功能"><a href="#6-4-插件功能" class="headerlink" title="6.4 插件功能"></a>6.4 插件功能</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173018571.png" alt="image-20250426204401361" style="zoom:67%;" />]]></content>
    
    
    <categories>
      
      <category>微服务</category>
      
    </categories>
    
    
    <tags>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>python语法</title>
    <link href="/2024/06/25/python%E5%AD%A6%E4%B9%A0/"/>
    <url>/2024/06/25/python%E5%AD%A6%E4%B9%A0/</url>
    
    <content type="html"><![CDATA[<h1 id="一-基础语法"><a href="#一-基础语法" class="headerlink" title="一 基础语法"></a>一 基础语法</h1><h2 id="1-基本操作"><a href="#1-基本操作" class="headerlink" title="1 基本操作"></a>1 基本操作</h2><p>输出：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;每日增长系数：%.1f，经过%d天的增长后，股价达到了：%0.2f&quot;</span> % (stock_price_daily_growth_factor, <br>                                             growth_days,stock_price_daily_growth_factor ** growth_days * stock_price))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;公司：<span class="hljs-subst">&#123;name&#125;</span>,股票代码：<span class="hljs-subst">&#123;stock_code&#125;</span>，当前股价：<span class="hljs-subst">&#123;stock_price&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>输入：input()</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请告诉我你是谁？\n&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;我知道了，你是：<span class="hljs-subst">&#123;name&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>变量类型查看：type(num)</p><p>注释：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 单行注释</span><br><br><span class="hljs-string">&quot;&quot;&quot; </span><br><span class="hljs-string">多行</span><br><span class="hljs-string">注释</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br></code></pre></td></tr></table></figure><h2 id="2-数据容器"><a href="#2-数据容器" class="headerlink" title="2 数据容器"></a>2 数据容器</h2><h3 id="2-1-列表"><a href="#2-1-列表" class="headerlink" title="2.1 列表"></a>2.1 列表</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213825352.png" alt="image-20241015102741282" style="zoom: 50%;" /><h3 id="2-2-元组"><a href="#2-2-元组" class="headerlink" title="2.2 元组"></a>2.2 元组</h3><p>元组如下特点：</p><ul><li>可以容纳多个数据</li><li>可以容纳不同类型的数据(混装)</li><li>数据是有序存储的(下标索引)</li><li>允许重复数据存在</li><li><strong>不可以修改(增加或删除元素等</strong>)</li><li>支持for循环</li></ul><p>多数特性和list一致，不同点在于不可修改的特性</p><h3 id="2-3-字符串"><a href="#2-3-字符串" class="headerlink" title="2.3 字符串"></a>2.3 字符串</h3><p><strong>字符串常用操作</strong>：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213832867.png" alt="QQ_1728993503669" style="zoom: 50%;" /><p>作为数据容器，字符串有如下特点：</p><ul><li>只可以存储字符串</li><li>长度任意(取决于内存大小)</li><li>支持下标索引</li><li>允许重复字符串存在</li><li><font color = 'red'>不可以修改(增加或删除元素等)</font></li><li>支持for循环</li></ul><p><font color = 'red'>序列的操作——切片</font></p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213835311.png" alt="QQ_1729253002333" style="zoom: 50%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213837620.png" alt="QQ_1729404550833" style="zoom:50%;" /><h3 id="2-4-集合"><a href="#2-4-集合" class="headerlink" title="2.4 集合"></a>2.4 集合</h3><p>特点：</p><ul><li>可以容纳多个数据</li><li>可以容纳不同类型的数据(混装)</li><li><font color = 'red'>数据是无序存储的(不支持下标索引)</font></li><li><font color = 'red'>不允许重复数据存在</font></li><li>可以修改(增加或删除元素等)</li><li>支持for循环</li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213839927.png" alt="QQ_1729405849701" style="zoom:50%;" /><h3 id="2-5-字典"><a href="#2-5-字典" class="headerlink" title="2.5 字典"></a>2.5 字典</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213842319.png" alt="QQ_1729408491876" style="zoom:50%;" /><p>特点：</p><ul><li>可以容纳多个数据</li><li>可以容纳不同类型的数据</li><li>每一份数据是KeyValue键值对</li><li>可以通过Key获取到Value，Key不可重复（重复会覆盖）</li><li>不支持下标索引</li><li>可以修改(增加或删除更新元素等)</li><li>支持for循环，不支持while循环</li></ul><h2 id="3-数据容器特点对比"><a href="#3-数据容器特点对比" class="headerlink" title="3 数据容器特点对比"></a>3 数据容器特点对比</h2><p>数据容器可以从以下视角进行简单的分类:</p><ul><li><strong>是否支持下标索引</strong><ul><li>支持：列表、元组、字符串-序列类型</li><li>不支持：集合、字典-非序列类型</li></ul></li><li><strong>是否支持重复元素</strong><ul><li>支持：列表、元组、字符串-序列类型</li><li>不支持：集合、字典-非序列类型</li></ul></li><li><strong>是否可以修改</strong><ul><li>支持：列表、集合、字典</li><li>不支持：元组、字符串</li></ul></li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213904529.png" alt="QQ_1729409879651" style="zoom: 50%;" /><p>使用场景：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213906260.png" alt="QQ_1729409922983" style="zoom: 50%;" /><p>sorted(容器，[reverse &#x3D; True])</p><h2 id="4-函数操作"><a href="#4-函数操作" class="headerlink" title="4 函数操作"></a>4 函数操作</h2><h3 id="4-1-多种参数使用形式"><a href="#4-1-多种参数使用形式" class="headerlink" title="4.1 多种参数使用形式"></a>4.1 多种参数使用形式</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">name, age, gender</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;您的姓名是<span class="hljs-subst">&#123;name&#125;</span>，年龄是：<span class="hljs-subst">&#123;age&#125;</span>，性别是：<span class="hljs-subst">&#123;gender&#125;</span>&#x27;</span>)<br>    <br>user_info(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;男&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>位置参数不定长</strong>：传进的所有参数都会被args变量收集，它会根据传进参数的位置合并为一个元组(tuple)，args是元组类型，这就是位置传递</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info</span>(<span class="hljs-params">*args</span>):<br>    <span class="hljs-built_in">print</span>(args)<br>    <br>user_info(<span class="hljs-string">&quot;tom&quot;</span>, <span class="hljs-number">20</span>, <span class="hljs-string">&quot;男&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>关键字参数不定长</strong>：参数是“键&#x3D;值”形式的形式的情况下，所有的“键&#x3D;值”都会被kwargs接受，同时会根据“键&#x3D;值”组成字典</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">user_info3</span>(<span class="hljs-params">**kwargs</span>):<br>    <span class="hljs-built_in">print</span>(kwargs)<br><br><br>user_info3(name=<span class="hljs-string">&quot;tom&quot;</span>, age=<span class="hljs-number">20</span>, gender=<span class="hljs-string">&quot;男&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-2-匿名函数"><a href="#4-2-匿名函数" class="headerlink" title="4.2 匿名函数"></a>4.2 匿名函数</h3><h4 id="4-2-1-函数作为参数传递"><a href="#4-2-1-函数作为参数传递" class="headerlink" title="4.2.1 函数作为参数传递"></a>4.2.1 函数作为参数传递</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 调用一个函数，接受另一个函数作为传入参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">mult_func</span>):<br>    <span class="hljs-comment"># 确定mult_func是函数</span><br>    result = mult_func(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算的结果是：<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><br><span class="hljs-comment"># 定义一个函数，准备作为参数传入另一个函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">mult_func</span>(<span class="hljs-params">x, y</span>):<br>    <span class="hljs-keyword">return</span> x * y<br><br><br><span class="hljs-comment"># 调用，并传入函数</span><br>test_func(mult_func)<br></code></pre></td></tr></table></figure><h4 id="4-2-2-lambda函数"><a href="#4-2-2-lambda函数" class="headerlink" title="4.2.2 lambda函数"></a>4.2.2 lambda函数</h4><p>函数的定义中</p><ul><li>def键字，可以定义带有名称的函数</li><li>lambda关键字，可以定义匿名函数(无名称)</li></ul><p>有名称的函数，可以基于名称<strong>重复使用</strong></p><p>无名称的匿名函数，只可<strong>临时使用一次</strong>。</p><p>匿名函数定义语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">lambda</span> 传入参数:函数体(一行代码)<br></code></pre></td></tr></table></figure><ul><li>lambda 是关键字，表示定义匿名函数</li><li>传入参数表示匿名函数的形式参数，如：x，y表示接收2个形式参数</li><li>函数体，就是函数的执行逻辑，要注意：只能写一行，无法写多行代码</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 调用一个函数，接受另一个函数作为传入参数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_func</span>(<span class="hljs-params">mult_func</span>):<br>    <span class="hljs-comment"># 确定mult_func是函数</span><br>    result = mult_func(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;计算的结果是：<span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br><br><span class="hljs-comment"># 调用，并传入函数</span><br>test_func(<span class="hljs-keyword">lambda</span> x, y: x * y)<br></code></pre></td></tr></table></figure><h1 id="二-文件操作"><a href="#二-文件操作" class="headerlink" title="二 文件操作"></a>二 文件操作</h1><h2 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h2><p>在Python，使用open函数，可以打开一个已经存在的文件，或者创建一个新文件，语法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">open</span>(name,mode,encoding)<br></code></pre></td></tr></table></figure><p>name：是要打开的目标文件名的字符串(可以包含文件所在的具体路径)。</p><p>mode：设置打开文件的模式(访问模式):只读、写入、追加等。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213911681.png" alt="QQ_1729420889601" style="zoom:50%;" /><p>encoding：编码格式(推荐使用UTF-8)</p><p>示例代码:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;python.txt&#x27;</span>,<span class="hljs-string">&#x27;r&#x27;</span>,encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br><span class="hljs-comment">#encoding的顺序不是第三位，所以不能用位置参数，用关键字参数直接指定</span><br></code></pre></td></tr></table></figure><h2 id="2-2-读取相关操作"><a href="#2-2-读取相关操作" class="headerlink" title="2.2 读取相关操作"></a>2.2 读取相关操作</h2><p><strong>read()方法：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">文件对象.read(num)<br></code></pre></td></tr></table></figure><p>num表示要从文件中读取的数据的长度(单位是字节)，如果没有传入num，那么就表示读取文件中所有的数据</p><p><strong>readlines()方法：</strong></p><p>readlines可以按照行的方式把整个文件中的内容进行一次性读取，并且返回的是一个列表，其中每一行的数据为一个元素。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 通过在with open的语句块中对文件进行操作</span><br><span class="hljs-comment"># 可以在操作完成后自动关闭close文件，避免遗忘掉close方法</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;python.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.readlines()<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213914824.png" alt="QQ_1729422292042" style="zoom: 50%;" /><h2 id="2-3-写入相关操作"><a href="#2-3-写入相关操作" class="headerlink" title="2.3 写入相关操作"></a>2.3 写入相关操作</h2><p><strong>覆盖用w</strong></p><p>2.写入的方法有:</p><ul><li>wirte()，写入内容</li><li>flush()，刷新内容到硬盘中</li></ul><p>3.注意事项:</p><ul><li><p>w模式，文件不存在，会创建新文件</p></li><li><p>w模式，文件存在，会清空原有内容</p></li><li><p>close()方法，带有flush()方法的功能</p></li></ul><p><strong>追加用a</strong></p><h1 id="三-异常"><a href="#三-异常" class="headerlink" title="三 异常"></a>三 异常</h1><h2 id="3-1-异常概念"><a href="#3-1-异常概念" class="headerlink" title="3.1 异常概念"></a>3.1 异常概念</h2><blockquote><p>捕获异常的作用在于：提前假设某处会出现异常，做好提前准备，当真的出现异常的时候，可以有后续手段。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    <span class="hljs-built_in">print</span>(name)<br><span class="hljs-keyword">except</span> NameError <span class="hljs-keyword">as</span> e:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;name变量名称未定义错误&#x27;</span>)<br></code></pre></td></tr></table></figure><p><strong>异常的finally</strong></p><p>finally表示的是无论是否异常都要执行的代码，例如关闭文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">try</span>:<br>    f= <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;r&#x27;</span>)<br><span class="hljs-keyword">except</span> Exception <span class="hljs-keyword">as</span> e:<br>    f= <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;test.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>)<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;没有异常，真开心&#x27;</span>)<br><span class="hljs-keyword">finally</span>:<br>    f.close()<br></code></pre></td></tr></table></figure><p><strong>异常的传递</strong></p><p>异常是具有传递性的</p><p>当函数<font color='red'>func01</font>中发生异常，并且没有捕获处理这个异常的时候，异常会传递到函数<font color='red'>func02</font>，当func02也没有捕获处理这个异常的时候main函数会捕获这个异常，这就是异常的传递性</p><p>提示：<font color='red'>当所有函数都没有捕获异常的时候，程序就会报错</font></p><h2 id="3-2-模块"><a href="#3-2-模块" class="headerlink" title="3.2 模块"></a>3.2 模块</h2><blockquote><p>什么是模块？</p><p>Python 模块(Module)，是一个Python 文件，以.py 结尾。模块能定义函数，类和变量，模块里也能包含可执行的代码</p><p><font color ='red'>模块的作用</font>：python中有很多各种不同的模块，每一个模块都可以帮助我们快速的实现一些功能，比如实现和时间相关的功能就可以使用time模块。我们可以认为一个模块就是一个工具包，每一个工具包中都有各种不同的工具供我们使用进而实现各种不同的功能。</p><p>大白话：模块就是一个Python文件，里面有类、函数、变量等，我们可以拿过来用(导入模块去使用)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模块块在使用前需要先导入 导入的语法如下</span><br>[<span class="hljs-keyword">from</span> 模块名] <span class="hljs-keyword">import</span>[模块 | 类 | 变量 | 函数 |*][<span class="hljs-keyword">as</span> 别名]<br><span class="hljs-comment"># 常用的组合形式如:</span><br><span class="hljs-keyword">import</span> 模块名<br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 类、变量、方法等<br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">import</span> 块名 <span class="hljs-keyword">as</span>别名<br><span class="hljs-keyword">from</span> 模块名 <span class="hljs-keyword">import</span> 功能名 <span class="hljs-keyword">as</span> 别名<br></code></pre></td></tr></table></figure><p><strong>name__main变量使用</strong></p><p>if <strong><strong>name</strong></strong> &#x3D;&#x3D;“<strong><strong>main</strong></strong> ”表示，只有当程序是直接执行的才会进入if内部，如果是被导入的，则if无法进入</p><p>03_my_module_use.py </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> my_module<br><br><span class="hljs-built_in">print</span>(my_module.add(<span class="hljs-number">1</span>, <span class="hljs-number">4</span>))<br></code></pre></td></tr></table></figure><p>my_module.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">a, b</span>):<br>    <span class="hljs-keyword">return</span> a + b<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(add(<span class="hljs-number">7</span>, <span class="hljs-number">2</span>))<br></code></pre></td></tr></table></figure><h2 id="3-3-Python包"><a href="#3-3-Python包" class="headerlink" title="3.3 Python包"></a>3.3 Python包</h2><h3 id="3-3-1-自定义包"><a href="#3-3-1-自定义包" class="headerlink" title="3.3.1 自定义包"></a>3.3.1 自定义包</h3><p>创建包必须要有文件</p><p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213920954.png" alt="QQ_1729496934323"></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">演示python包</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-comment"># 创建一个包</span><br><br><span class="hljs-comment"># 导入自定义包中的模块，并使用</span><br><span class="hljs-comment"># import my_package.my_module1</span><br><span class="hljs-comment"># import my_package.my_module2</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># my_package.my_module1.info_print1()</span><br><span class="hljs-comment"># my_package.my_module2.info_print2()</span><br><br><span class="hljs-comment"># from my_package import my_module1</span><br><span class="hljs-comment"># from my_package import my_module2</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># my_module1.info_print1()</span><br><span class="hljs-comment"># my_module2.info_print2()</span><br><br><span class="hljs-comment"># from my_package.my_module1 import info_print1</span><br><span class="hljs-comment"># from my_package.my_module2 import info_print2</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># info_print1()</span><br><span class="hljs-comment"># info_print2()</span><br><span class="hljs-comment"># 通过__all__变量，控制import</span><br><span class="hljs-keyword">from</span> my_package <span class="hljs-keyword">import</span> *<br><br>my_module1.info_print1()<br>my_module2.info_print2()<br></code></pre></td></tr></table></figure><h3 id="3-3-2-安装第三方包"><a href="#3-3-2-安装第三方包" class="headerlink" title="3.3.2 安装第三方包"></a>3.3.2 安装第三方包</h3><p>什么是第三方包？</p><p>我们知道，包可以包含一堆的Python模块，而每个模块又内含许多的功能。所以，我们可以认为：一个包，就是一堆同类型功能的集合体。在Python程序的生态中，有许多非常多的第三方包(非Pvthon官方)，可以极大的帮助我们提高开发效率，如：</p><ul><li>科学计算中常用的：numpy包</li><li>数据分析中常用的：pandas包</li><li>大数据计算中常用的：pyspark、apache-flink包</li><li>图形可视化常用的：matplotlib、pyecharts</li><li>人工智能常用的：tensorflow</li></ul><p>这些第三方包，极大的丰富了python的编程生态，提高了我们的开发效率</p><p>安装方法：</p><p>由于pip是连接的国外的网站进行包的下载，所以有的时候会速度很慢我们可以通过如下命令，让其连接国内的网站进行包的安装:</p><blockquote><p>pip install -i <a href="https://pypi.tuna.tsinghua.edu.cn/simple">https://pypi.tuna.tsinghua.edu.cn/simple</a> 包名称</p><p>pip install 包名称</p></blockquote><h1 id="四-可视化"><a href="#四-可视化" class="headerlink" title="四 可视化"></a>四 可视化</h1><h2 id="4-1-基本介绍"><a href="#4-1-基本介绍" class="headerlink" title="4.1 基本介绍"></a>4.1 基本介绍</h2><h3 id="4-1-1-json数据格式"><a href="#4-1-1-json数据格式" class="headerlink" title="4.1.1 json数据格式"></a>4.1.1 json数据格式</h3><ol><li><p><strong>json</strong>：是一种轻量级的数据交互格式,采用完全独立于编程语言的文本格式来存储和表示数据(就是字符串)</p><p>Python语言使用ISON有很大优势，因为：JSON无非就是一个单独的字典或一个内部元素都是字典的列表，所以JSON可以直接和</p><p>Python的字典或列表进行无缝转换。</p></li><li><p><strong>json格式数据转化</strong></p><p>通过 json.dumps(data)方法把python数据转化为了 json数据</p><p>data&#x3D; json.dumps(data)</p><p>如果有中文可以带上:ensure ascii-False参数来确保中文正常转换通过json.loads(data)方法把josn数据转化为了python列表或字典</p></li></ol><h3 id="4-1-2-pyecharts模块介绍"><a href="#4-1-2-pyecharts模块介绍" class="headerlink" title="4.1.2 pyecharts模块介绍"></a>4.1.2 pyecharts模块介绍</h3><p>Echarts 是个由百度开源的数据可视化，凭借着良好的交互性，精巧的图表设计，得到了众多开发者的认可。而 Python 是门富有表达立的语言，很适合用于数据处理。当数据分析遇上数据可视化时pyecharts 诞生了</p><p>set _global opts方法（全局配置）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">line.set_global_opts(<br>    title_opts = Title0pts(<span class="hljs-string">&quot;测试&quot;</span>, pos_left = <span class="hljs-string">&quot;center&quot;</span>, pos_bottom = <span class="hljs-string">&quot;1%&quot;</span>),<br>    legend_opts = Legendopts(is_show = <span class="hljs-literal">True</span>),<br>    toolbox_opts = Toolbox0pts(is_show = <span class="hljs-literal">True</span>)<br>    visualmap_opts = VisualMapOpts(is_show = <span class="hljs-literal">True</span>)<br>    tooltip opts = Tooltipopts(is_show = <span class="hljs-literal">True</span>),<br>)<br></code></pre></td></tr></table></figure><h2 id="4-2-折线图可视化"><a href="#4-2-折线图可视化" class="headerlink" title="4.2 折线图可视化"></a>4.2 折线图可视化</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">演示可视化需求1:折线图开发</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Line<br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 处理数据</span><br>f_us = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;utils/美国.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>us_data = f_us.read()  <span class="hljs-comment"># 美国的全部数据</span><br><br>f_jp = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;utils/日本.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>jp_data = f_jp.read()  <span class="hljs-comment"># 日本的全部数据</span><br><br>f_in = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;utils/印度.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>in_data = f_in.read()  <span class="hljs-comment"># 印度的全部数据</span><br><br><span class="hljs-comment"># 去掉不合JSON规范的开头</span><br>us_data = us_data.replace(<span class="hljs-string">&quot;jsonp_1629344292311_69436(&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>jp_data = jp_data.replace(<span class="hljs-string">&quot;jsonp_1629350871167_29498(&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br>in_data = in_data.replace(<span class="hljs-string">&quot;jsonp_1629350745930_63180(&quot;</span>, <span class="hljs-string">&quot;&quot;</span>)<br><br><span class="hljs-comment"># 去掉不合JSON规范的结尾</span><br>us_data = us_data[:-<span class="hljs-number">2</span>]<br>jp_data = jp_data[:-<span class="hljs-number">2</span>]<br>in_data = in_data[:-<span class="hljs-number">2</span>]<br><br><span class="hljs-comment"># JSON转Python字典</span><br>us_dict = json.loads(us_data)<br>jp_dict= json.loads(jp_data)<br>in_dict = json.loads(in_data)<br><br><span class="hljs-comment"># 获取trend key</span><br>us_trend_data = us_dict[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;trend&#x27;</span>]<br>jp_trend_data = jp_dict[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;trend&#x27;</span>]<br>in_trend_data = in_dict[<span class="hljs-string">&#x27;data&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;trend&#x27;</span>]<br><br><span class="hljs-comment"># 获取日期数据，用于x轴，取2020年(到 314 下标结束)</span><br>us_x_data = us_trend_data[<span class="hljs-string">&#x27;updateDate&#x27;</span>][:<span class="hljs-number">314</span>]<br>jp_x_data = jp_trend_data[<span class="hljs-string">&#x27;updateDate&#x27;</span>][:<span class="hljs-number">314</span>]<br>in_x_data = in_trend_data[<span class="hljs-string">&#x27;updateDate&#x27;</span>][:<span class="hljs-number">314</span>]<br><br><span class="hljs-comment"># 获取确认数据，用于y轴，取2020年(到 314 下标结束)</span><br>us_y_data = us_trend_data[<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;data&#x27;</span>][:<span class="hljs-number">314</span>]<br>jp_y_data = jp_trend_data[<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;data&#x27;</span>][:<span class="hljs-number">314</span>]<br>in_y_data = in_trend_data[<span class="hljs-string">&#x27;list&#x27;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;data&#x27;</span>][:<span class="hljs-number">314</span>]<br><br><span class="hljs-comment"># 生成图表</span><br>line = Line()<br><br><span class="hljs-comment"># 添加x轴数据</span><br>line.add_xaxis(us_x_data)  <span class="hljs-comment"># x轴数据是公用的，使用一个国家即可</span><br><br><span class="hljs-comment"># 添加y轴数据</span><br>line.add_yaxis(<span class="hljs-string">&quot;美国确诊人数&quot;</span>, us_y_data, label_opts=LabelOpts(is_show=<span class="hljs-literal">False</span>))<br>line.add_yaxis(<span class="hljs-string">&quot;日本确诊人数&quot;</span>, jp_y_data, label_opts=LabelOpts(is_show=<span class="hljs-literal">False</span>))<br>line.add_yaxis(<span class="hljs-string">&quot;印度确诊人数&quot;</span>, in_y_data, label_opts=LabelOpts(is_show=<span class="hljs-literal">False</span>))<br><br><span class="hljs-comment"># 设置全局选项</span><br>line.set_global_opts(<br>    title_opts=TitleOpts(title=<span class="hljs-string">&quot;2020年美日印三国确诊人数对比折线图&quot;</span>, pos_left=<span class="hljs-string">&quot;center&quot;</span>, pos_bottom=<span class="hljs-string">&#x27;1%&#x27;</span>)<br>)<br><br><br><span class="hljs-comment"># 调用render方法生成图表</span><br>line.render(path=<span class="hljs-string">&quot;03_折线图.html&quot;</span>)<br><br><span class="hljs-comment"># 关闭文件对象</span><br>f_us.close()<br>f_jp.close()<br>f_in.close()<br></code></pre></td></tr></table></figure><h2 id="4-3-地图可视化"><a href="#4-3-地图可视化" class="headerlink" title="4.3 地图可视化"></a>4.3 地图可视化</h2><p>地图现在版本更新必须将其补全</p><h3 id="4-3-1-全国地图"><a href="#4-3-1-全国地图" class="headerlink" title="4.3.1 全国地图"></a>4.3.1 全国地图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：05_全国疫情可视化地图开发.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/23 19:45 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Map<br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> TitleOpts, VisualMapOpts<br><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 读取原始数据文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;疫情.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    data = json.load(f)<br><br>lastUpdateTime = data[<span class="hljs-string">&quot;lastUpdateTime&quot;</span>]<br>lastUpdateTime = <span class="hljs-built_in">str</span>(lastUpdateTime)<br>chinaTotal = data[<span class="hljs-string">&#x27;chinaTotal&#x27;</span>]<br>chinaAdd = data[<span class="hljs-string">&quot;chinaAdd&quot;</span>]<br>isShowAdd = data[<span class="hljs-string">&quot;isShowAdd&quot;</span>],<br><span class="hljs-built_in">print</span>(isShowAdd)<br>showAddSwitch = data[<span class="hljs-string">&quot;showAddSwitch&quot;</span>],<br><br><span class="hljs-comment"># 更改需要的数据</span><br>province_list = data[<span class="hljs-string">&quot;areaTree&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;children&quot;</span>]<br><br><span class="hljs-comment"># 遍历省份列表，对全称进行补全</span><br><span class="hljs-keyword">for</span> province <span class="hljs-keyword">in</span> province_list:<br>    <span class="hljs-comment"># 如果是几个直辖市后面直接写市</span><br>    <span class="hljs-keyword">if</span> province[<span class="hljs-string">&quot;name&quot;</span>] <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;北京&quot;</span>, <span class="hljs-string">&quot;上海&quot;</span>, <span class="hljs-string">&quot;天津&quot;</span>, <span class="hljs-string">&quot;重庆&quot;</span>]:<br>        province[<span class="hljs-string">&quot;name&quot;</span>] += <span class="hljs-string">&quot;市&quot;</span><br>    <span class="hljs-comment"># 如果是港澳台，后面直接写特别行政区</span><br>    <span class="hljs-keyword">elif</span> province[<span class="hljs-string">&quot;name&quot;</span>] <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;香港&quot;</span>, <span class="hljs-string">&quot;澳门&quot;</span>, ]:<br>        province[<span class="hljs-string">&quot;name&quot;</span>] += <span class="hljs-string">&quot;特别行政区&quot;</span><br>    <span class="hljs-keyword">elif</span> province[<span class="hljs-string">&quot;name&quot;</span>] <span class="hljs-keyword">in</span> [<span class="hljs-string">&quot;内蒙古&quot;</span>, <span class="hljs-string">&quot;西藏&quot;</span>]:<br>        province[<span class="hljs-string">&quot;name&quot;</span>] += <span class="hljs-string">&quot;自治区&quot;</span><br>    <span class="hljs-keyword">elif</span> province[<span class="hljs-string">&quot;name&quot;</span>] == <span class="hljs-string">&quot;广西&quot;</span>:<br>        province[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;广西壮族自治区&quot;</span><br>    <span class="hljs-keyword">elif</span> province[<span class="hljs-string">&quot;name&quot;</span>] == <span class="hljs-string">&quot;新疆&quot;</span>:<br>        province[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;新疆维吾尔自治区&quot;</span><br>    <span class="hljs-keyword">elif</span> province[<span class="hljs-string">&quot;name&quot;</span>] == <span class="hljs-string">&quot;宁夏&quot;</span>:<br>        province[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;宁夏回族自治区&quot;</span><br><br>    <span class="hljs-comment"># 其他省份后面直接写省</span><br>    <span class="hljs-keyword">else</span>:<br>        province[<span class="hljs-string">&quot;name&quot;</span>] += <span class="hljs-string">&quot;省&quot;</span><br><br><span class="hljs-comment"># 重新组织数据，生成新的 JSON 字符串</span><br>new_data = &#123;<br>    <span class="hljs-string">&quot;lastUpdateTime&quot;</span>: lastUpdateTime,<br>    <span class="hljs-string">&quot;chinaTotal&quot;</span>: chinaTotal,<br>    <span class="hljs-string">&quot;chinaAdd&quot;</span>: chinaAdd,<br>    <span class="hljs-string">&quot;isShowAdd&quot;</span>: isShowAdd,<br>    <span class="hljs-string">&quot;showAddSwitch&quot;</span>: showAddSwitch,<br>    <span class="hljs-string">&quot;areaTree&quot;</span>: [data[<span class="hljs-string">&quot;areaTree&quot;</span>][<span class="hljs-number">0</span>]]<br>&#125;<br>new_data[<span class="hljs-string">&quot;areaTree&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;children&quot;</span>] = province_list<br>new_data_str = json.dumps(new_data, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<br><br><span class="hljs-comment"># 写回文件</span><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;疫情.txt&quot;</span>, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    f.write(new_data_str)<br></code></pre></td></tr></table></figure><p>完成前期准备工作之后：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：05_全国疫情可视化地图开发.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/23 19:45 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Map<br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> TitleOpts, VisualMapOpts<br><br><span class="hljs-comment"># 读取数据文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;utils/疫情.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>)<br>data = f.read()<br><br><span class="hljs-comment"># 关闭文件</span><br>f.close()<br><span class="hljs-comment"># 取到各省数据,并转换为字典</span><br>data_dict = json.loads(data)<br>province_data_list = data_dict[<span class="hljs-string">&quot;areaTree&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;children&quot;</span>]<br><span class="hljs-comment"># 组装每个省份和确诊人数为元组，并各个省的数据都封装入列表内</span><br>data_list = []  <span class="hljs-comment"># 存放每个省份的数据</span><br><span class="hljs-keyword">for</span> province_data <span class="hljs-keyword">in</span> province_data_list:<br>    province_name = province_data[<span class="hljs-string">&quot;name&quot;</span>]<br>    province_confirm = province_data[<span class="hljs-string">&quot;total&quot;</span>][<span class="hljs-string">&quot;confirm&quot;</span>]<br>    data_list.append((province_name, province_confirm))<br><br><span class="hljs-built_in">print</span>(data_list)<br><span class="hljs-comment"># 创建地图对象</span><br><span class="hljs-built_in">map</span> = Map()<br><span class="hljs-comment"># 添加数据</span><br><span class="hljs-built_in">map</span>.add(<span class="hljs-string">&quot;各省份确诊人数&quot;</span>, data_list, <span class="hljs-string">&quot;china&quot;</span>)<br><span class="hljs-comment"># 设置全局配置，定制分段视觉映射</span><br><span class="hljs-built_in">map</span>.set_global_opts(<br>    TitleOpts(title=<span class="hljs-string">&quot;全国疫情可视化地图&quot;</span>),<br>    visualmap_opts=VisualMapOpts(<br>        is_show=<span class="hljs-literal">True</span>,<br>        is_piecewise=<span class="hljs-literal">True</span>,<br>        pieces=[<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">99</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;1-99人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#CCFFFF&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">999</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;100-999人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FFFF99&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">1000</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">4999</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;1000-4999人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FF9966&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">5000</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">9999</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;5000-9999人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FF6666&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">10000</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">99999</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;10000-99999人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#CC3333&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">100000</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;10000人以上&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#990033&quot;</span>&#125;,<br>        ]<br>    )<br><br>)<br><span class="hljs-comment"># 绘图</span><br><span class="hljs-built_in">map</span>.render(<span class="hljs-string">&quot;05_全国疫情可视化地图.html&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-3-2-省级地图"><a href="#4-3-2-省级地图" class="headerlink" title="4.3.2 省级地图"></a>4.3.2 省级地图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：06_省级疫情可视化开发.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/25 15:38 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Map<br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 读取文件</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../utils/疫情.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>)<br>data = f.read()<br><span class="hljs-comment"># 关闭文件</span><br>f.close()<br><span class="hljs-comment"># 获取河南省数据</span><br>data_dict = json.loads(data)<br>cities_data = data_dict[<span class="hljs-string">&quot;areaTree&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&quot;children&quot;</span>][<span class="hljs-number">1</span>][<span class="hljs-string">&quot;children&quot;</span>]<br><br>data_list = []<br><span class="hljs-comment"># 准备数据为元组并放入list</span><br><span class="hljs-keyword">for</span> city_data <span class="hljs-keyword">in</span> cities_data:<br>    city_name = city_data[<span class="hljs-string">&quot;name&quot;</span>] + <span class="hljs-string">&quot;市&quot;</span><br>    city_confirm = city_data[<span class="hljs-string">&quot;total&quot;</span>][<span class="hljs-string">&quot;confirm&quot;</span>]<br>    data_list.append((city_name, city_confirm))<br><br><span class="hljs-comment"># 构建地图</span><br><span class="hljs-built_in">map</span> = Map()<br><span class="hljs-built_in">map</span>.add(<span class="hljs-string">&quot;江苏省疫情分布&quot;</span>, data_list, <span class="hljs-string">&quot;江苏&quot;</span>).set_global_opts(<br>    TitleOpts(title=<span class="hljs-string">&quot;全国疫情可视化地图&quot;</span>),<br>    visualmap_opts=VisualMapOpts(<br>        is_show=<span class="hljs-literal">True</span>,<br>        is_piecewise=<span class="hljs-literal">True</span>,<br>        pieces=[<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">1</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">9</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;1-9人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#CCFFFF&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">10</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">99</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;10-99人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FFFF99&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">100</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">199</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;100-199人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FF9966&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">200</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">299</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;200-299人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#FF6666&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">300</span>, <span class="hljs-string">&quot;max&quot;</span>: <span class="hljs-number">399</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;300-399人&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#CC3333&quot;</span>&#125;,<br>            &#123;<span class="hljs-string">&quot;min&quot;</span>: <span class="hljs-number">400</span>, <span class="hljs-string">&quot;label&quot;</span>: <span class="hljs-string">&quot;400人以上&quot;</span>, <span class="hljs-string">&quot;color&quot;</span>: <span class="hljs-string">&quot;#990033&quot;</span>&#125;,<br>        ]<br>    )<br>)<br><br><span class="hljs-comment"># 绘图</span><br><span class="hljs-built_in">map</span>.render(<span class="hljs-string">&quot;06_省级疫情可视化开发.html&quot;</span>)<br><br></code></pre></td></tr></table></figure><h2 id="4-4-柱状图"><a href="#4-4-柱状图" class="headerlink" title="4.4 柱状图"></a>4.4 柱状图</h2><h3 id="4-4-1-基础柱状图"><a href="#4-4-1-基础柱状图" class="headerlink" title="4.4.1 基础柱状图"></a>4.4.1 基础柱状图</h3><p>设置步骤：</p><ol><li>通过Bar()构建一个柱状图对象</li><li>和折线图一样，通过add_xaxis()和add_yaxis()添加x和y轴数据</li><li>通过柱状图对象的：reversal_axis()，反转x和y轴</li><li>通过label_opts&#x3D;LabelOpts(position&#x3D;”right”)设置数值标签在右侧显示</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：07_基础柱状图开发.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/25 16:57 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Bar<br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> *<br><br><span class="hljs-comment"># 使用Bar构建基础柱状图</span><br>bar = Bar()<br><br><span class="hljs-comment"># 添加X轴</span><br>bar.add_xaxis([<span class="hljs-string">&quot;英国&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>, <span class="hljs-string">&quot;中国&quot;</span>])<br><br><span class="hljs-comment"># 添加Y轴</span><br>bar.add_yaxis(<span class="hljs-string">&quot;GDP&quot;</span>, [<span class="hljs-number">100</span>, <span class="hljs-number">200</span>, <span class="hljs-number">300</span>], label_opts=LabelOpts(position=<span class="hljs-string">&quot;right&quot;</span>), color=<span class="hljs-string">&quot;#990033&quot;</span>)<br><br><span class="hljs-comment"># 反转X和Y轴</span><br>bar.reversal_axis()<br><br><span class="hljs-comment"># 绘图</span><br>bar.render(<span class="hljs-string">&quot;07_基础柱状图.html&quot;</span>)<br><br></code></pre></td></tr></table></figure><h3 id="4-4-2-基础时间柱状图"><a href="#4-4-2-基础时间柱状图" class="headerlink" title="4.4.2 基础时间柱状图"></a>4.4.2 基础时间柱状图</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：08_基础时间线柱状图开发.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/25 17:45 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyecharts.<span class="hljs-built_in">globals</span> <span class="hljs-keyword">import</span> *<br><br>bar1 = Bar()<br>bar1.add_xaxis([<span class="hljs-string">&quot;英国&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>, <span class="hljs-string">&quot;中国&quot;</span>])<br>bar1.add_yaxis(<span class="hljs-string">&quot;GDP&quot;</span>, [<span class="hljs-number">10</span>, <span class="hljs-number">20</span>, <span class="hljs-number">80</span>], label_opts=LabelOpts(position=<span class="hljs-string">&quot;right&quot;</span>))<br>bar1.reversal_axis()<br><br>bar2 = Bar()<br>bar2.add_xaxis([<span class="hljs-string">&quot;英国&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>, <span class="hljs-string">&quot;中国&quot;</span>])<br>bar2.add_yaxis(<span class="hljs-string">&quot;GDP&quot;</span>, [<span class="hljs-number">40</span>, <span class="hljs-number">50</span>, <span class="hljs-number">90</span>], label_opts=LabelOpts(position=<span class="hljs-string">&quot;right&quot;</span>))<br>bar2.reversal_axis()<br><br>bar3 = Bar()<br>bar3.add_xaxis([<span class="hljs-string">&quot;英国&quot;</span>, <span class="hljs-string">&quot;美国&quot;</span>, <span class="hljs-string">&quot;中国&quot;</span>])<br>bar3.add_yaxis(<span class="hljs-string">&quot;GDP&quot;</span>, [<span class="hljs-number">70</span>, <span class="hljs-number">100</span>, <span class="hljs-number">200</span>], label_opts=LabelOpts(position=<span class="hljs-string">&quot;right&quot;</span>))<br>bar3.reversal_axis()<br><br><span class="hljs-comment"># 构建时间线对象</span><br>timeline = Timeline(<br>    <span class="hljs-comment"># 设置主题</span><br>    &#123;<span class="hljs-string">&quot;theme&quot;</span>: ThemeType.LIGHT&#125;<br>)<br><br><span class="hljs-comment"># 在时间线内添加柱状图</span><br>timeline.add(bar1, <span class="hljs-string">&quot;2017年&quot;</span>)<br>timeline.add(bar2, <span class="hljs-string">&quot;2018年&quot;</span>)<br>timeline.add(bar3, <span class="hljs-string">&quot;2019年&quot;</span>)<br><span class="hljs-comment"># 自动播放设置</span><br>timeline.add_schema(<br>    is_auto_play=<span class="hljs-literal">True</span>,<br>    play_interval=<span class="hljs-number">1000</span>,<br>    is_loop_play=<span class="hljs-literal">True</span>,<br>    is_timeline_show=<span class="hljs-literal">True</span><br>)<br><span class="hljs-comment"># 时间线播放间隔</span><br><span class="hljs-comment"># 主题设置</span><br><br><span class="hljs-comment"># 绘图</span><br>timeline.render(<span class="hljs-string">&quot;08_基础时间线柱状图.html&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="4-4-3-动态图绘制"><a href="#4-4-3-动态图绘制" class="headerlink" title="4.4.3 动态图绘制"></a>4.4.3 动态图绘制</h3><p>列表的sort方法</p><p>使用方式:</p><blockquote><p>列表.sort(key&#x3D;选择排序依据的函数,reverse&#x3D;TruelFalse)</p><p>参数key，是要求传入一个函数，表示将列表的每一个元素都传入函数中，返回排序的依据</p><p>参数reverse，是否反转排序结果，True表示降序，False表示升序</p></blockquote><p>python版本3.7之后字典就开始排序了</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：10_GDP动态柱状图开发.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/25 18:25 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Bar, Timeline<br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyecharts.<span class="hljs-built_in">globals</span> <span class="hljs-keyword">import</span> ThemeType<br><br><span class="hljs-comment"># 读取数据</span><br>f = <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;../utils/1960-2019全球GDP数据.csv&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;GB2312&quot;</span>)<br>data_lines = f.readlines()<br><br><span class="hljs-comment"># 关闭文件</span><br>f.close()<br><span class="hljs-comment"># 删除第一条数据</span><br>data_lines.pop(<span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 将数据转换为字典存储，格式为:</span><br><span class="hljs-comment"># &#123;年份:[[国家，gdp]，[国家,gdp]，......]，年份:[[国家，gdp]，[国家,gdp],...... ]，......&#125;</span><br>data_dict = &#123;&#125;<br><span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> data_lines:<br>    year = <span class="hljs-built_in">int</span>(line.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">0</span>])<br>    country = line.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">1</span>]<br>    GDP = <span class="hljs-built_in">float</span>(line.split(<span class="hljs-string">&quot;,&quot;</span>)[<span class="hljs-number">2</span>])<br><br>    <span class="hljs-comment"># 如何判断字典里面有没有指定的key讷？</span><br>    <span class="hljs-keyword">try</span>:<br>        data_dict[year].append([country, GDP])<br>    <span class="hljs-keyword">except</span> KeyError:<br>        data_dict[year] = []<br>        data_dict[year].append([country, GDP])<br><br><span class="hljs-comment"># 创建时间线对象</span><br>timeline = Timeline(&#123;<span class="hljs-string">&quot;theme&quot;</span>: ThemeType.LIGHT&#125;)<br><br><span class="hljs-comment"># for循环每一年的数据，基于每一年的数据，创建每一年的bar对象</span><br><span class="hljs-keyword">for</span> year <span class="hljs-keyword">in</span> data_dict.keys():<br>    data_dict[year].sort(key=<span class="hljs-keyword">lambda</span> element: element[<span class="hljs-number">1</span>], reverse=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 将每一年的数据按照gdp从大到小排序,取出前八</span><br>    data_year = data_dict[year][<span class="hljs-number">0</span>:<span class="hljs-number">8</span>]<br><br>    x_data = []<br>    y_data = []<br><br>    <span class="hljs-keyword">for</span> element <span class="hljs-keyword">in</span> data_year:<br>        x_data.append(element[<span class="hljs-number">0</span>])<br>        y_data.append(element[<span class="hljs-number">1</span>] / <span class="hljs-number">1000000000</span>)<br><br>    <span class="hljs-comment"># 创建bar对象</span><br>    bar = Bar()<br>    x_data.reverse()<br>    y_data.reverse()<br><br>    bar.add_xaxis(x_data)<br>    bar.add_yaxis(<span class="hljs-string">&quot;GDP(亿)&quot;</span>, y_data, label_opts=LabelOpts(position=<span class="hljs-string">&quot;right&quot;</span>))<br><br>    <span class="hljs-comment"># 反转x和y轴</span><br>    bar.reversal_axis()<br><br>    <span class="hljs-comment"># 设置标题</span><br>    bar.set_global_opts(<br>        title_opts=TitleOpts(title=<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;year&#125;</span>年全球前8国家GDP数据&quot;</span>)<br>    )<br><br>    <span class="hljs-comment"># 在for中，将每一年的bar对象添加到时间线中</span><br>    timeline.add(bar, <span class="hljs-built_in">str</span>(year))<br><br><span class="hljs-comment"># 设置时间线自动播放</span><br>timeline.add_schema(<br>    play_interval=<span class="hljs-number">1000</span>,<br>    is_auto_play=<span class="hljs-literal">True</span>,<br>    is_loop_play=<span class="hljs-literal">True</span>,<br>    is_timeline_show=<span class="hljs-literal">True</span><br>)<br><span class="hljs-comment"># 绘图</span><br>timeline.render(<span class="hljs-string">&quot;10_1960-2019全球GDP前8国家.html&quot;</span>)<br><br></code></pre></td></tr></table></figure><h1 id="五-面向对象"><a href="#五-面向对象" class="headerlink" title="五 面向对象"></a>五 面向对象</h1><h2 id="5-1-基本概念"><a href="#5-1-基本概念" class="headerlink" title="5.1 基本概念"></a>5.1 基本概念</h2><h3 id="5-1-1-成员变量"><a href="#5-1-1-成员变量" class="headerlink" title="5.1.1 成员变量"></a>5.1.1 成员变量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">student</span>:<br>    <span class="hljs-comment">#学生的姓名</span><br>    name = <span class="hljs-literal">None</span><br>    <span class="hljs-comment"># 学生的年龄</span><br>    age = <span class="hljs-literal">None</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">say_hi</span>(<span class="hljs-params">self, msg</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Hi大家好，我是<span class="hljs-subst">&#123;self.name&#125;</span>，<span class="hljs-subst">&#123;msg&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="5-1-2-类、对象和构造方法"><a href="#5-1-2-类、对象和构造方法" class="headerlink" title="5.1.2 类、对象和构造方法"></a>5.1.2 类、对象和构造方法</h3><p>类、对象：</p><p>1.现实世界的事物由什么组成? </p><ul><li>属性</li><li>行为</li></ul><p>类也可以包含属性和行为，所以使用类描述现实世界事物是非常合适的</p><p>构造方法：</p><p>Python类可以使用: –init–()方法，称之为构造方法。</p><p>可以实现：</p><ul><li>在创建类对象(构造类)的时候，会自动执行</li><li>在创建类对象(构造类)的时候，将传入参数自动传递给 init 方法使用。</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    name = <span class="hljs-literal">None</span><br>    age = <span class="hljs-literal">None</span><br>    tel = <span class="hljs-literal">None</span><br>    <br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, tel</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.tel =tel<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213937928.png" alt="QQ_1729862268576" style="zoom: 33%;" /><p>例题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：创建类对象.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/25 20:30 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age, address</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br>        <span class="hljs-variable language_">self</span>.address = address<br><br><br><span class="hljs-comment"># 通过for循环，配合input输入语句，并使用构造方法，完成学生信息的键盘录入</span><br>students = []<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前录入第<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>位学生，总共需要录入3位&quot;</span>)<br>    <span class="hljs-comment"># 输入学生姓名</span><br>    name = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入学生姓名：&quot;</span>)<br>    <span class="hljs-comment"># 输入学生年龄</span><br>    age = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入学生年龄：&quot;</span>)<br>    <span class="hljs-comment"># 输入学生成绩</span><br>    address = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入学生地址：&quot;</span>)<br><br>    <span class="hljs-comment"># 创建学生对象</span><br>    student = Student(name, age, address)<br>    students.append(student)<br><br>    <span class="hljs-comment"># 打印学生信息</span><br>    <span class="hljs-built_in">print</span>(<br>        &#123;<span class="hljs-string">f&quot;学生<span class="hljs-subst">&#123;i + <span class="hljs-number">1</span>&#125;</span>信息的信息录入完成，学生的信息为:【姓名:<span class="hljs-subst">&#123;student.name&#125;</span>，年龄:<span class="hljs-subst">&#123;student.age&#125;</span>，地址:<span class="hljs-subst">&#123;student.address&#125;</span>】&quot;</span>&#125;)<br><br></code></pre></td></tr></table></figure><h3 id="5-1-3-内置方法"><a href="#5-1-3-内置方法" class="headerlink" title="5.1.3 内置方法"></a>5.1.3 内置方法</h3><p>魔术方法：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213940349.png" alt="QQ_1729862337478" style="zoom: 50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：02_内置方法.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/25 21:21 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> traceback <span class="hljs-keyword">import</span> print_tb<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, name, age</span>):<br>        <span class="hljs-variable language_">self</span>.name = name<br>        <span class="hljs-variable language_">self</span>.age = age<br><br>    <span class="hljs-comment"># __str__魔术方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;Student类对象，name:<span class="hljs-subst">&#123;self.name&#125;</span>，age:<span class="hljs-subst">&#123;self.age&#125;</span>&quot;</span><br><br>    <span class="hljs-comment"># __lt__魔术方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__lt__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.age &lt; other.age<br><br>    <span class="hljs-comment"># __le__魔术方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__le__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.age &lt;= other.age<br><br>    <span class="hljs-comment"># __eq__魔术方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__eq__</span>(<span class="hljs-params">self, other</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-variable language_">self</span>.age == other.age<br><br><br>student1 = Student(<span class="hljs-string">&quot;周杰伦&quot;</span>, <span class="hljs-number">30</span>)<br>student2 = Student(<span class="hljs-string">&quot;邓紫棋&quot;</span>, <span class="hljs-number">20</span>)<br><br><span class="hljs-comment"># __str__魔术方法</span><br><span class="hljs-built_in">print</span>(student1)<br><br><span class="hljs-comment"># __lt__魔术方法</span><br><span class="hljs-built_in">print</span>(student1 &lt; student2)<br><br><span class="hljs-comment"># __le__魔术方法</span><br>student3 = Student(<span class="hljs-string">&quot;周杰伦&quot;</span>, <span class="hljs-number">30</span>)<br>student4 = Student(<span class="hljs-string">&quot;邓紫棋&quot;</span>, <span class="hljs-number">33</span>)<br><br><span class="hljs-built_in">print</span>(student3 &lt;= student4)<br><br><span class="hljs-comment"># __eq__魔术方法</span><br>student5 = Student(<span class="hljs-string">&quot;周杰伦&quot;</span>, <span class="hljs-number">30</span>)<br>student6 = Student(<span class="hljs-string">&quot;邓紫棋&quot;</span>, <span class="hljs-number">30</span>)<br><span class="hljs-built_in">print</span>(student5 == student6)<br></code></pre></td></tr></table></figure><h2 id="5-2-封装"><a href="#5-2-封装" class="headerlink" title="5.2 封装"></a>5.2 封装</h2><p>私有成员</p><p>类中提供了私有成员的形式来支持：私有成员变量；私有成员方法</p><p>定义私有成员的方式非常简单，只需要:</p><ul><li>私有成员变量：变量名以__开头(2个下划线)</li><li>私有成员方法：方法名以__开头(2个下划线)</li></ul><p>即可完成私有成员的设置</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：03_封装课后练习题.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/28 09:32 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 设计一个类，用来描述手机</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>:<br>    <span class="hljs-comment"># 提供私有成员变量</span><br>    __is_5g_enable = <span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 提供私有成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__check_5g</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">if</span> <span class="hljs-variable language_">self</span>.__is_5g_enable:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5g is enable&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5g is disable&quot;</span>)<br><br><span class="hljs-comment"># 提供公开的成员方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">check_5g</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-variable language_">self</span>.__check_5g()<br><br>phone = Phone()<br>phone.check_5g()<br><br></code></pre></td></tr></table></figure><h2 id="5-3-继承"><a href="#5-3-继承" class="headerlink" title="5.3 继承"></a>5.3 继承</h2><h3 id="5-3-1-单继承和多继承"><a href="#5-3-1-单继承和多继承" class="headerlink" title="5.3.1 单继承和多继承"></a>5.3.1 单继承和多继承</h3><ul><li>单继承：一个类继承另一个类</li><li>多继承：一个类继承多个类，按照顺序从左向右依次继承</li></ul><p>多继承中，如果父类有同名方法或属性，先继承的优先级高于后继承</p><p>pass关键字的作用是什么：</p><blockquote><p>pass是占位语句，用来保证函数(方法)或类定义的完整性，表示无内容，空的意思</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：04_继承.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/28 10:01 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> symtable <span class="hljs-keyword">import</span> Class<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>:<br>    IMEI = <span class="hljs-literal">None</span><br>    producer = <span class="hljs-string">&quot;IT_CAST&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_by_5g</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5g通话已开启&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">NFCReader</span>:<br>    nfc_type = <span class="hljs-string">&quot;第五代&quot;</span><br>    producer = <span class="hljs-string">&quot;HM&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_card</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NFC读卡器已开启&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrire_card</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;NFC写卡器已开启&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">RedRemoteControl</span>:<br>    rc_type = <span class="hljs-string">&quot;红外遥控&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">control</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;红外遥控器已开启&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPhone</span>(Phone, NFCReader, RedRemoteControl):<br>    <span class="hljs-keyword">pass</span><br><br>phone = MyPhone()<br>phone.call_by_5g()<br>phone.read_card()<br>phone.wrire_card()<br>phone.control()<br><span class="hljs-built_in">print</span>(phone.producer)<br><br></code></pre></td></tr></table></figure><h3 id="5-3-2-复写和父类成员"><a href="#5-3-2-复写和父类成员" class="headerlink" title="5.3.2 复写和父类成员"></a>5.3.2 复写和父类成员</h3><p>**复写：**子类继承父类的成员属性和成员方法后，如果对其“不满意”，那么可以进行复写。即：在子类中重新定义同名的属性或方法即可</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：04_继承_复写.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 18:40 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>:<br>    IMEI = <span class="hljs-literal">None</span><br>    producer = <span class="hljs-string">&quot;IT_CAST&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_by_5g</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5g通话已开启&quot;</span>)<br><br><span class="hljs-comment"># 定义子类，复写父类方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPhone</span>(<span class="hljs-title class_ inherited__">Phone</span>):<br>    IMEI = <span class="hljs-string">&quot;123456789012345&quot;</span><br>    producer = <span class="hljs-string">&quot;Made in China&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_by_5g</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5g通话已开启，请拨打110&quot;</span>)<br><br><br>myPhone = MyPhone()<br><span class="hljs-built_in">print</span>(myPhone.IMEI)<br><span class="hljs-built_in">print</span>(myPhone.producer)<br>myPhone.call_by_5g()<br><br></code></pre></td></tr></table></figure><p>调用父类成员：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：04_继承_复写.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 18:40 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Phone</span>:<br>    IMEI = <span class="hljs-literal">None</span><br>    producer = <span class="hljs-string">&quot;IT_CAST&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_by_5g</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;5g通话已开启&quot;</span>)<br><br><span class="hljs-comment"># 定义子类，复写父类方法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyPhone</span>(<span class="hljs-title class_ inherited__">Phone</span>):<br>    IMEI = <span class="hljs-string">&quot;123456789012345&quot;</span><br>    producer = <span class="hljs-string">&quot;Made in China&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">call_by_5g</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;开启单核模式，确保通话的时候省电&quot;</span>)<br>        <span class="hljs-comment"># 调用父类方法方式一</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;父类的厂商是：<span class="hljs-subst">&#123;Phone.producer&#125;</span>&quot;</span>)<br>        Phone.call_by_5g(<span class="hljs-variable language_">self</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----------------------&quot;</span>)<br><br>        <span class="hljs-comment"># 调用父类方法方式二</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;父类的厂商是：<span class="hljs-subst">&#123;<span class="hljs-built_in">super</span>().producer&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">super</span>().call_by_5g()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;关闭单核模式，确保通话的时候省电&quot;</span>)<br><br><br>myPhone = MyPhone()<br><span class="hljs-built_in">print</span>(myPhone.IMEI)<br><span class="hljs-built_in">print</span>(myPhone.producer)<br>myPhone.call_by_5g()<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213947085.png" alt="image-20241029192021650" style="zoom: 50%;" /><h2 id="5-4-注解"><a href="#5-4-注解" class="headerlink" title="5.4 注解"></a>5.4 注解</h2><h3 id="5-4-1-类型注解"><a href="#5-4-1-类型注解" class="headerlink" title="5.4.1 类型注解"></a>5.4.1 类型注解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：05_类型注解.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 19:37 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> json<br><span class="hljs-keyword">import</span> random<br><br><span class="hljs-comment"># 基础数据类型注解</span><br>var_1: <span class="hljs-built_in">int</span> = <span class="hljs-number">10</span><br>var_2: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;hello&quot;</span><br>var_3: <span class="hljs-built_in">float</span> = <span class="hljs-number">10.0</span><br>var_4: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span><br><br><br><span class="hljs-comment"># 类对象类型注解</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>:<br>    <span class="hljs-keyword">pass</span><br><br><br>stu: Student = Student()<br><span class="hljs-comment"># 基础容器类型注解</span><br>My_list: <span class="hljs-built_in">list</span> = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>my_tuple: <span class="hljs-built_in">tuple</span> = (<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>my_dict: <span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;alaskaboo&quot;</span>&#125;<br>my_set: <span class="hljs-built_in">set</span> = &#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-comment"># 容器类型注解即详细注解</span><br>my_list: <span class="hljs-built_in">list</span>[<span class="hljs-built_in">int</span>] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]<br>My_tuple: <span class="hljs-built_in">tuple</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>, <span class="hljs-built_in">bool</span>] = (<span class="hljs-number">1</span>, <span class="hljs-string">&quot;heima&quot;</span>, <span class="hljs-literal">True</span>)<br>My_dict: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>] = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-number">10</span>&#125;<br><br><span class="hljs-comment"># 在注释中进行类型注解</span><br>var_1 = random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">10</span>)  <span class="hljs-comment"># type: <span class="hljs-built_in">int</span></span><br>var_2 = json.loads(<span class="hljs-string">&#x27;&#123;&quot;name&quot;: &quot;alaskaboo&quot;&#125;&#x27;</span>)  <span class="hljs-comment"># type: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]</span><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>():<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">10</span><br><br>var_3 = func()  <span class="hljs-comment"># type: <span class="hljs-built_in">int</span></span><br></code></pre></td></tr></table></figure><p>类型注解主要功能在于:</p><p>帮助第三方IDE工具(如PyCharm)对代码导入类型推送，协助做代码提示</p><p>帮助开发者自身对变量进行类型注释（备注 ）</p><h3 id="5-4-2-形参注解"><a href="#5-4-2-形参注解" class="headerlink" title="5.4.2 形参注解"></a>5.4.2 形参注解</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">函数方法名</span>(<span class="hljs-params">形参名:类型, 形参名:类型</span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">add</span>(<span class="hljs-params">x:<span class="hljs-built_in">int</span>, y:<span class="hljs-built_in">int</span></span>):<br>    <span class="hljs-keyword">return</span> x + y<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">data: <span class="hljs-built_in">list</span></span>):<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h3 id="5-4-3-Union类型"><a href="#5-4-3-Union类型" class="headerlink" title="5.4.3 Union类型"></a>5.4.3 Union类型</h3><p>Union联合类型注解，在变量注解、函数(方法)形参和返回值注解中，均可使用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> typing <span class="hljs-keyword">import</span> <span class="hljs-type">Union</span><br><br>my_list: <span class="hljs-built_in">list</span>[<span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]] = [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-string">&quot;heima&quot;</span>, <span class="hljs-string">&quot;python&quot;</span>]<br>my_dict: <span class="hljs-built_in">dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]] = &#123;<span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;alaska&quot;</span>, <span class="hljs-string">&quot;age&quot;</span>: <span class="hljs-number">10</span>&#125;<br><br><br><span class="hljs-comment"># -&gt; Union[int, str]是返回值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">data: <span class="hljs-type">Union</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">int</span>]</span>) -&gt; <span class="hljs-type">Union</span>[<span class="hljs-built_in">int</span>, <span class="hljs-built_in">str</span>]:<br>    <span class="hljs-keyword">pass</span><br></code></pre></td></tr></table></figure><h2 id="5-5-多态"><a href="#5-5-多态" class="headerlink" title="5.5 多态"></a>5.5 多态</h2><p>概念：多种状态，即完成某个行为时，使用不同的对象会得到不同的状态</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213951212.png" alt="image-20241029201529213" style="zoom:50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：06_多态.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 20:16 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Animal</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">pass</span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Dog</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;wang wang&quot;</span>)<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Cat</span>(<span class="hljs-title class_ inherited__">Animal</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">speak</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;miao miao&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_noise</span>(<span class="hljs-params">animal: Animal</span>):<br>    animal.speak()<br><br>dog = Dog()<br>cat = Cat()<br>make_noise(dog)<br>make_noise(cat) <br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625213957457.png" alt="image-20241029201945720" style="zoom:50%;" /><p>空调例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 演示抽象类</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">AC</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;制冷&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;制热&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;左右摆风&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Midea_AC</span>(<span class="hljs-title class_ inherited__">AC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;制冷&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;midea cool&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;制热&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;midea hot&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;左右摆风&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;midea swing&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">GREE_AC</span>(<span class="hljs-title class_ inherited__">AC</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">cool_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;制冷&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gree cool&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">hot_wind</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;制热&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gree hot&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">swing_l_r</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-string">&quot;&quot;&quot;左右摆风&quot;&quot;&quot;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;gree swing&quot;</span>)<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">make_coll</span>(<span class="hljs-params">ac: AC</span>):<br>    ac.cool_wind()<br><br>Midea_AC = Midea_AC()<br>GREE_AC = GREE_AC()<br>make_coll(Midea_AC)<br>make_coll(GREE_AC)<br></code></pre></td></tr></table></figure><h2 id="综合案例"><a href="#综合案例" class="headerlink" title="综合案例"></a>综合案例</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214000200.png" alt="image-20241029203309792" style="zoom:50%;" /><p>data_define.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：定义数据类型</span><br><span class="hljs-string">@File    ：data_define.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 20:36 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Record</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, date, order_id, money, province</span>):<br>        <span class="hljs-comment"># 订单日期</span><br>        <span class="hljs-variable language_">self</span>.date = date<br>        <span class="hljs-comment"># 订单ID</span><br>        <span class="hljs-variable language_">self</span>.order_id = order_id<br>        <span class="hljs-comment"># 订单金额</span><br>        <span class="hljs-variable language_">self</span>.money = money<br>        <span class="hljs-comment"># 销售省份</span><br>        <span class="hljs-variable language_">self</span>.province = province<br><br><br>    <span class="hljs-comment"># 将内存地址输出为对应的字符串</span><br>    <span class="hljs-keyword">def</span>  <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.date&#125;</span>, <span class="hljs-subst">&#123;self.order_id&#125;</span>, <span class="hljs-subst">&#123;self.money&#125;</span>, <span class="hljs-subst">&#123;self.province&#125;</span>&quot;</span><br><br></code></pre></td></tr></table></figure><p>file_define.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：和文件相关的类定义</span><br><span class="hljs-string">@File    ：file_define.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 20:42 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">from</span> data_define <span class="hljs-keyword">import</span> Record<br><br><br><span class="hljs-comment"># 先定义一个抽象类用来做顶层设计，确定有那些功能需要实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span>:<br><br>    <span class="hljs-comment"># 抽象方法，需要子类实现</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>[Record]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        读取文件数据，将数据转换为Record对象，并将其list封装返回</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># 定义一个具体的子类，实现抽象类的抽象方法</span><br><span class="hljs-comment"># 这个子类是用来读取文本文件的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextFileReader</span>(<span class="hljs-title class_ inherited__">FileReader</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file_path</span>):<br>        <span class="hljs-comment"># 文件路径</span><br>        <span class="hljs-variable language_">self</span>.file_path = file_path<br><br>    <span class="hljs-comment"># 复写（实现抽象方法）父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>[Record]:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>        record_list: <span class="hljs-built_in">list</span>[Record] = []<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>            <span class="hljs-comment"># 消除数据中每一行的\n</span><br>            line = line.strip()<br>            data_list = line.split(<span class="hljs-string">&quot;,&quot;</span>)<br>            record = Record(data_list[<span class="hljs-number">0</span>], data_list[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(data_list[<span class="hljs-number">2</span>]), data_list[<span class="hljs-number">3</span>])<br>            record_list.append(record)<br><br>        f.close()<br>        <span class="hljs-keyword">return</span> record_list<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonTextFileReader</span>(<span class="hljs-title class_ inherited__">FileReader</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file_path</span>):<br>        <span class="hljs-comment"># 文件路径</span><br>        <span class="hljs-variable language_">self</span>.file_path = file_path<br><br>    <span class="hljs-comment"># 复写（实现抽象方法）父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>[Record]:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>        record_list: <span class="hljs-built_in">list</span>[Record] = []<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>            data_dict = json.loads(line)<br>            record = Record(data_dict[<span class="hljs-string">&#x27;date&#x27;</span>], data_dict[<span class="hljs-string">&#x27;order_id&#x27;</span>], <span class="hljs-built_in">int</span>(data_dict[<span class="hljs-string">&#x27;money&#x27;</span>]), data_dict[<span class="hljs-string">&#x27;province&#x27;</span>])<br>            record_list.append(record)<br><br>        f.close()<br>        <span class="hljs-keyword">return</span> record_list<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    text_file_reader = TextFileReader(<span class="hljs-string">&quot;utils/2011年1月销售数据.txt&quot;</span>)<br>    json_file_reader = JsonTextFileReader(<span class="hljs-string">&quot;utils/2011年2月销售数据JSON.txt&quot;</span>)<br>    list1 = text_file_reader.read_data()<br>    list2 = json_file_reader.read_data()<br><br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> list1:<br>        <span class="hljs-built_in">print</span>(l)<br><br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> list2:<br>        <span class="hljs-built_in">print</span>(l)<br></code></pre></td></tr></table></figure><p>main.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：面向对象，数据分析案例</span><br><span class="hljs-string">@File    ：main.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 20:35 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyecharts.options <span class="hljs-keyword">import</span> TitleOpts, LabelOpts<br><br><span class="hljs-keyword">from</span> file_define <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> data_define <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyecharts.charts <span class="hljs-keyword">import</span> Bar<br><span class="hljs-keyword">from</span> pyecharts <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pyecharts.<span class="hljs-built_in">globals</span> <span class="hljs-keyword">import</span> ChartType<br><br><span class="hljs-comment"># 1.设计一个类，可以完成数据的封装</span><br><span class="hljs-comment"># 2.设计一个抽象类，定义文件读取的相关功能，并使用子类实现具体功能</span><br><span class="hljs-comment"># 3.读取文件，生产数据对象</span><br><span class="hljs-comment"># 4.进行数据需求的逻辑计算(计算每一天的销售额)</span><br>text_file_reader = TextFileReader(<span class="hljs-string">&quot;utils/2011年1月销售数据.txt&quot;</span>)<br>json_file_reader = JsonTextFileReader(<span class="hljs-string">&quot;utils/2011年2月销售数据JSON.txt&quot;</span>)<br><br>jan_data: <span class="hljs-built_in">list</span>[Record] = text_file_reader.read_data()<br>feb_data: <span class="hljs-built_in">list</span>[Record] = json_file_reader.read_data()<br><br><span class="hljs-comment"># 将两个数据合二为一</span><br>all_data: <span class="hljs-built_in">list</span>[Record] = jan_data + feb_data<br><br>data_dict = &#123;&#125;<br><span class="hljs-comment"># 用字典数据计算</span><br><span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> all_data:<br>    <span class="hljs-keyword">if</span> record.date <span class="hljs-keyword">in</span> data_dict.keys():<br>        <span class="hljs-comment"># 如果已经存在，则进行累加</span><br>        data_dict[record.date] += record.money<br>    <span class="hljs-keyword">else</span>:<br><br>        data_dict[record.date] = record.money<br><span class="hljs-comment"># 5.通过PyEcharts进行图形绘制</span><br>bar = Bar()<br>bar.add_xaxis(<span class="hljs-built_in">list</span>(data_dict.keys()))<br>bar.add_yaxis(<span class="hljs-string">&quot;销售额&quot;</span>, <span class="hljs-built_in">list</span>(data_dict.values()), label_opts=LabelOpts(is_show=<span class="hljs-literal">False</span>))<br><br>bar.set_global_opts(<br>    title_opts=TitleOpts(title=<span class="hljs-string">&quot;2011年1月-2月每日销售额&quot;</span>),<br>)<br>bar.render(<span class="hljs-string">&quot;2011年1月-2月每日销售额.html&quot;</span>)<br><br></code></pre></td></tr></table></figure><h1 id="六-SQL"><a href="#六-SQL" class="headerlink" title="六 SQL"></a>六 SQL</h1><p>分组聚合</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214005595.png" alt="QQ_1730254829987" style="zoom:50%;" /><h2 id="6-1-数据库连接"><a href="#6-1-数据库连接" class="headerlink" title="6.1 数据库连接"></a>6.1 数据库连接</h2><p>1.Python中使用什么第三方库来操作MySQL？如何安装？</p><ul><li>使用第三方库为：pymysql</li><li>安装：pip install pymysql</li></ul><p>2.如何获取链接对象？</p><ul><li>from pymysqlimport Connection 导包</li><li>Connection(主机,端口,账户,密码)即可得到链接对象</li><li>链接对象.close()关闭和MySQL数据库的连接</li></ul><p>3.如何执行SQL查询</p><ul><li>通过连接对象调用cursor()方法，得到游标对象</li><li>游标对象.execute()执行SQL语句</li><li>游标对象.fetchall()得到全部的查询结果封装入元组内</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：01_pymysql入门.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/04 18:50 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">from</span> pymysql <span class="hljs-keyword">import</span> Connect<br><br>conn = Connect(<br>    host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    port=<span class="hljs-number">3306</span>,<br>    user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    password=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    charset=<span class="hljs-string">&#x27;utf8&#x27;</span><br>)<br><br><span class="hljs-comment"># 执行非查询性质SQL</span><br>cursor = conn.cursor()<br><span class="hljs-comment"># 选择数据库</span><br>conn.select_db(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># 执行SQL</span><br>cursor.execute(<span class="hljs-string">&#x27;SeLeCt * from student&#x27;</span>)<br><br><span class="hljs-comment"># 获取查询结果</span><br>result = cursor.fetchall()<br><span class="hljs-keyword">for</span> row <span class="hljs-keyword">in</span> result:<br>    <span class="hljs-built_in">print</span>(row)<br><span class="hljs-comment"># 关闭连接</span><br>cursor.close()<br>conn.close()<br><br></code></pre></td></tr></table></figure><h2 id="6-2-数据插入"><a href="#6-2-数据插入" class="headerlink" title="6.2 数据插入"></a>6.2 数据插入</h2><p>数据插入有两种方法：</p><p>方法一——使用conn.commit()方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：02_数据插入.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/04 19:22 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pymysql <span class="hljs-keyword">import</span> Connect<br><br>conn = Connect(<br>    host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    port=<span class="hljs-number">3306</span>,<br>    user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    password=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    charset=<span class="hljs-string">&#x27;utf8&#x27;</span><br>)<br><br><span class="hljs-comment"># 执行非查询性质SQL</span><br>cursor = conn.cursor()<br><span class="hljs-comment"># 选择数据库</span><br>conn.select_db(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># 执行SQL</span><br>cursor.execute(<span class="hljs-string">&#x27;insert into student(name,addr,age,gender) values(&quot;Alaska&quot;,&quot;上海&quot;,24,&quot;男&quot;)&#x27;</span>)<br>conn.commit()<br><br>cursor.close()<br>conn.close()<br></code></pre></td></tr></table></figure><p>方法二——直接设置autocommit&#x3D;True</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：02_数据插入.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/04 19:22 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pymysql <span class="hljs-keyword">import</span> Connect<br><br>conn = Connect(<br>    host=<span class="hljs-string">&#x27;localhost&#x27;</span>,<br>    port=<span class="hljs-number">3306</span>,<br>    user=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    password=<span class="hljs-string">&#x27;root&#x27;</span>,<br>    charset=<span class="hljs-string">&#x27;utf8&#x27;</span><br>    autocommit=<span class="hljs-literal">True</span><br>)<br><br><span class="hljs-comment"># 执行非查询性质SQL</span><br>cursor = conn.cursor()<br><span class="hljs-comment"># 选择数据库</span><br>conn.select_db(<span class="hljs-string">&quot;test&quot;</span>)<br><br><span class="hljs-comment"># 执行SQL</span><br>cursor.execute(<span class="hljs-string">&#x27;insert into student(name,addr,age,gender) values(&quot;Alaska&quot;,&quot;上海&quot;,24,&quot;男&quot;)&#x27;</span>)<br><br>cursor.close()<br>conn.close()<br></code></pre></td></tr></table></figure><h2 id="6-3-综合案例"><a href="#6-3-综合案例" class="headerlink" title="6.3 综合案例"></a>6.3 综合案例</h2><p>03_综合案例.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：03_综合案例.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/04 19:29 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> file_define <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> data_define <span class="hljs-keyword">import</span> *<br><span class="hljs-keyword">from</span> pymysql <span class="hljs-keyword">import</span> Connection<br><br><span class="hljs-comment"># 1.设计一个类，可以完成数据的封装</span><br><span class="hljs-comment"># 2.设计一个抽象类，定义文件读取的相关功能，并使用子类实现具体功能</span><br><span class="hljs-comment"># 3.读取文件，生产数据对象</span><br><span class="hljs-comment"># 4.进行数据需求的逻辑计算(计算每一天的销售额)</span><br>text_file_reader = TextFileReader(<span class="hljs-string">&quot;utils/2011年1月销售数据.txt&quot;</span>)<br>json_file_reader = JsonTextFileReader(<span class="hljs-string">&quot;utils/2011年2月销售数据JSON.txt&quot;</span>)<br><br>jan_data: <span class="hljs-built_in">list</span>[Record] = text_file_reader.read_data()<br>feb_data: <span class="hljs-built_in">list</span>[Record] = json_file_reader.read_data()<br><br><span class="hljs-comment"># 将两个数据合二为一</span><br>all_data: <span class="hljs-built_in">list</span>[Record] = jan_data + feb_data<br><br><span class="hljs-comment"># 构建mysql数据库连接</span><br>conn = Connection(<br>    host=<span class="hljs-string">&quot;localhost&quot;</span>,<br>    port=<span class="hljs-number">3306</span>,<br>    user=<span class="hljs-string">&quot;root&quot;</span>,<br>    password=<span class="hljs-string">&quot;root&quot;</span>,<br>    autocommit=<span class="hljs-literal">True</span><br>)<br><span class="hljs-comment"># 获取游标对象</span><br>cursor = conn.cursor()<br><span class="hljs-comment"># 选择数据库</span><br>conn.select_db(<span class="hljs-string">&quot;py_sql&quot;</span>)<br><span class="hljs-comment"># 组织sql语句</span><br><span class="hljs-keyword">for</span> record <span class="hljs-keyword">in</span> all_data:<br>    sql = (<span class="hljs-string">f&quot;insert into orders(order_id, order_date, order_price, order_province)&quot;</span><br>           <span class="hljs-string">f&quot; values(&#x27;<span class="hljs-subst">&#123;record.order_id&#125;</span>&#x27;,&#x27;<span class="hljs-subst">&#123;record.date&#125;</span>&#x27;, <span class="hljs-subst">&#123;record.money&#125;</span>, &#x27;<span class="hljs-subst">&#123;record.province&#125;</span>&#x27;)&quot;</span>)<br>    <span class="hljs-built_in">print</span>(sql)<br>    <span class="hljs-comment"># 执行sql语句</span><br><br><span class="hljs-comment"># 关闭连接对象</span><br>conn.close()<br><br></code></pre></td></tr></table></figure><p>data_define.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：定义数据类型</span><br><span class="hljs-string">@File    ：data_define.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 20:36 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Record</span>:<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, date, order_id, money, province</span>):<br>        <span class="hljs-comment"># 订单日期</span><br>        <span class="hljs-variable language_">self</span>.date = date<br>        <span class="hljs-comment"># 订单ID</span><br>        <span class="hljs-variable language_">self</span>.order_id = order_id<br>        <span class="hljs-comment"># 订单金额</span><br>        <span class="hljs-variable language_">self</span>.money = money<br>        <span class="hljs-comment"># 销售省份</span><br>        <span class="hljs-variable language_">self</span>.province = province<br><br><br>    <span class="hljs-comment"># 将内存地址输出为对应的字符串</span><br>    <span class="hljs-keyword">def</span>  <span class="hljs-title function_">__str__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.date&#125;</span>, <span class="hljs-subst">&#123;self.order_id&#125;</span>, <span class="hljs-subst">&#123;self.money&#125;</span>, <span class="hljs-subst">&#123;self.province&#125;</span>&quot;</span><br><br></code></pre></td></tr></table></figure><p>file_define.py</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：和文件相关的类定义</span><br><span class="hljs-string">@File    ：file_define.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/10/29 20:42 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> json<br><br><span class="hljs-keyword">from</span> data_define <span class="hljs-keyword">import</span> Record<br><br><br><span class="hljs-comment"># 先定义一个抽象类用来做顶层设计，确定有那些功能需要实现</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FileReader</span>:<br><br>    <span class="hljs-comment"># 抽象方法，需要子类实现</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>[Record]:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        读取文件数据，将数据转换为Record对象，并将其list封装返回</span><br><span class="hljs-string">        :return:</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-comment"># 定义一个具体的子类，实现抽象类的抽象方法</span><br><span class="hljs-comment"># 这个子类是用来读取文本文件的</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">TextFileReader</span>(<span class="hljs-title class_ inherited__">FileReader</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file_path</span>):<br>        <span class="hljs-comment"># 文件路径</span><br>        <span class="hljs-variable language_">self</span>.file_path = file_path<br><br>    <span class="hljs-comment"># 复写（实现抽象方法）父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>[Record]:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>        record_list: <span class="hljs-built_in">list</span>[Record] = []<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>            <span class="hljs-comment"># 消除数据中每一行的\n</span><br>            line = line.strip()<br>            data_list = line.split(<span class="hljs-string">&quot;,&quot;</span>)<br>            record = Record(data_list[<span class="hljs-number">0</span>], data_list[<span class="hljs-number">1</span>], <span class="hljs-built_in">int</span>(data_list[<span class="hljs-number">2</span>]), data_list[<span class="hljs-number">3</span>])<br>            record_list.append(record)<br><br>        f.close()<br>        <span class="hljs-keyword">return</span> record_list<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">JsonTextFileReader</span>(<span class="hljs-title class_ inherited__">FileReader</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self, file_path</span>):<br>        <span class="hljs-comment"># 文件路径</span><br>        <span class="hljs-variable language_">self</span>.file_path = file_path<br><br>    <span class="hljs-comment"># 复写（实现抽象方法）父类的方法</span><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">read_data</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-built_in">list</span>[Record]:<br>        f = <span class="hljs-built_in">open</span>(<span class="hljs-variable language_">self</span>.file_path, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>)<br><br>        record_list: <span class="hljs-built_in">list</span>[Record] = []<br>        <span class="hljs-keyword">for</span> line <span class="hljs-keyword">in</span> f.readlines():<br>            data_dict = json.loads(line)<br>            record = Record(data_dict[<span class="hljs-string">&#x27;date&#x27;</span>], data_dict[<span class="hljs-string">&#x27;order_id&#x27;</span>], <span class="hljs-built_in">int</span>(data_dict[<span class="hljs-string">&#x27;money&#x27;</span>]), data_dict[<span class="hljs-string">&#x27;province&#x27;</span>])<br>            record_list.append(record)<br><br>        f.close()<br>        <span class="hljs-keyword">return</span> record_list<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    text_file_reader = TextFileReader(<span class="hljs-string">&quot;utils/2011年1月销售数据.txt&quot;</span>)<br>    json_file_reader = JsonTextFileReader(<span class="hljs-string">&quot;utils/2011年2月销售数据JSON.txt&quot;</span>)<br>    list1 = text_file_reader.read_data()<br>    list2 = json_file_reader.read_data()<br><br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> list1:<br>        <span class="hljs-built_in">print</span>(l)<br><br>    <span class="hljs-keyword">for</span> l <span class="hljs-keyword">in</span> list2:<br>        <span class="hljs-built_in">print</span>(l)<br></code></pre></td></tr></table></figure><h1 id="七-PySpark实战"><a href="#七-PySpark实战" class="headerlink" title="七 PySpark实战"></a>七 PySpark实战</h1><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><p>定义：Apache Spark是用于大规模数据（large-scala data）处理的统一(unified)分析引擎。Spark是一款分布式的计算框架，用于调度成百上千的服务器集群，计算TB、PB乃至EB级别的海量数据。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214030081.png" alt="QQ_1730789118941" style="zoom: 33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214033173.png" alt="QQ_1730789168427" style="zoom:33%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：01_基础准备.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/04 21:18 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-comment"># 导包</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkConf, SparkContext<br><span class="hljs-comment"># 创建SparkConf类对象</span><br>conf = SparkConf().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;test_spark_app&quot;</span>)<br><span class="hljs-comment"># 创建SparkContext类对象</span><br>sc = SparkContext(conf=conf)<br><span class="hljs-comment"># 打印运行版本</span><br><span class="hljs-built_in">print</span>(sc.version)<br><span class="hljs-comment"># 停止SparkContext对象的运行</span><br>sc.stop()<br></code></pre></td></tr></table></figure><h2 id="7-2-RDD对象"><a href="#7-2-RDD对象" class="headerlink" title="7.2 RDD对象"></a>7.2 RDD对象</h2><p>如图可见，PySpark支持多种数据的输入，在输入完成后，都会得到一个：RDD类的对象</p><p>RDD全称为：弹性分布式数据集(ResilientDistributed Datasets)</p><p>PySpark针对数据的处理，都是以RDD对象作为载体，即：</p><ul><li>数据存储在RDD内</li><li>各类数据的计算方法，也都是RDD的成员方法</li><li>RDD的数据计算方法，返回值依旧是RDD对象</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：02_spark文件读取.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 15:02 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> *<br><br>conf = SparkConf().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;test_park&quot;</span>)<br><br>sc = SparkContext(conf=conf)<br><br><span class="hljs-built_in">print</span>(sc.textFile(<span class="hljs-string">&quot;utils/hello.txt&quot;</span>).collect())<br><br>sc.stop()<br></code></pre></td></tr></table></figure><h2 id="7-3-RDD算子"><a href="#7-3-RDD算子" class="headerlink" title="7.3 RDD算子"></a>7.3 RDD算子</h2><h3 id="7-3-1map和flatMap算子"><a href="#7-3-1map和flatMap算子" class="headerlink" title="7.3.1map和flatMap算子"></a>7.3.1map和flatMap算子</h3><p>功能：map算子，一条条处理（是将RDD的数据处理的逻辑 基于map算子中接收的处理函数），返回新的RDD</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：02_spark文件读取.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 15:02 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkConf, SparkContext<br><span class="hljs-keyword">import</span> os<br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br><br>conf = SparkConf().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;test_park&quot;</span>)<br><br>sparkContext  = SparkContext(conf=conf)<br><br><span class="hljs-comment"># 读取文件</span><br><span class="hljs-comment"># print(sc.textFile(&quot;utils/hello.txt&quot;).collect())</span><br><br><span class="hljs-comment"># 创建一个包含整数的 RDD</span><br>rdd = sparkContext.parallelize([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><br><span class="hljs-comment"># 为每个元素执行的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">func</span>(<span class="hljs-params">element</span>):<br>    <span class="hljs-keyword">return</span> element * <span class="hljs-number">10</span><br><br><span class="hljs-comment"># 应用 map 操作，将每个元素乘以 10,打印新的 RDD 中的内容</span><br><span class="hljs-built_in">print</span>(rdd.<span class="hljs-built_in">map</span>(func).collect())<br><br><span class="hljs-comment"># 停止 PySpark 程序</span><br>sparkContext.stop()<br></code></pre></td></tr></table></figure><p>改进lambda</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：02_spark文件读取.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 15:02 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkConf, SparkContext<br><span class="hljs-keyword">import</span> os<br><br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br><br>conf = SparkConf().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;test_park&quot;</span>)<br><br>sparkContext = SparkContext(conf=conf)<br><br><span class="hljs-comment"># 读取文件</span><br><span class="hljs-comment"># print(sc.textFile(&quot;utils/hello.txt&quot;).collect())</span><br><br><span class="hljs-comment"># 创建一个包含整数的 RDD</span><br>rdd = sparkContext.parallelize([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><br><span class="hljs-comment"># 应用 map 操作，将每个元素乘以 10,打印新的 RDD 中的内容</span><br><span class="hljs-built_in">print</span>(rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x * <span class="hljs-number">10</span>).<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x + <span class="hljs-number">5</span>).collect())<br><br><span class="hljs-comment"># 停止 PySpark 程序</span><br>sparkContext.stop()<br></code></pre></td></tr></table></figure><p>flatMap：唯一不同就是对结果接触嵌套</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：03_flatMap.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 16:09 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkConf, SparkContext<br><span class="hljs-keyword">import</span> os<br><br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br><br>conf = SparkConf().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;test_park&quot;</span>)<br><br>sparkContext = SparkContext(conf=conf)<br><br><span class="hljs-comment"># 创建一个包含整数的 RDD</span><br>rdd = sparkContext.parallelize([<span class="hljs-string">&quot;itheima itcast hello&quot;</span>, <span class="hljs-string">&quot;hello world&quot;</span>, <span class="hljs-string">&quot;hello itheima&quot;</span>])<br><br><span class="hljs-comment"># 应用 map 操作，将每个元素乘以 10,打印新的 RDD 中的内容</span><br><span class="hljs-built_in">print</span>(rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&quot; &quot;</span>)).collect())<br><span class="hljs-built_in">print</span>(rdd.flatMap(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&quot; &quot;</span>)).collect())<br><br><span class="hljs-comment"># 停止 PySpark 程序</span><br>sparkContext.stop()<br></code></pre></td></tr></table></figure><h3 id="7-3-2-reduceByKey"><a href="#7-3-2-reduceByKey" class="headerlink" title="7.3.2 reduceByKey"></a>7.3.2 reduceByKey</h3><p>功能：针对KV型RDD，自动按照key分组，然后根据你提供的聚合逻辑，完成组内数据（value）的聚合操作</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214040300.png" alt="QQ_1730803927941" style="zoom: 50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：04_reduceByKey.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 18:53 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkConf, SparkContext<br><span class="hljs-keyword">import</span> os<br><br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br><br>conf = SparkConf().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;test_park&quot;</span>)<br><br>sparkContext = SparkContext(conf=conf)<br><br><span class="hljs-comment"># 创建一个包含整数的 RDD</span><br>rdd = sparkContext.parallelize([(<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">88</span>), (<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">99</span>), (<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">77</span>), (<span class="hljs-string">&#x27;女&#x27;</span>, <span class="hljs-number">66</span>), (<span class="hljs-string">&#x27;男&#x27;</span>, <span class="hljs-number">87</span>)])<br><br><span class="hljs-built_in">print</span>(rdd.reduceByKey(<span class="hljs-keyword">lambda</span> x, y: x + y).collect())<br><br></code></pre></td></tr></table></figure><p>综合统计案例</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：05_综合案例.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 18:58 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 构建执行环境</span><br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br>conf = SparkConf().setMaster(<span class="hljs-string">&#x27;local[*]&#x27;</span>).setAppName(<span class="hljs-string">&#x27;account_spark&#x27;</span>)<br>sc = SparkContext(conf=conf)<br><br><span class="hljs-comment"># 读取数据文件</span><br>rdd = sc.textFile(<span class="hljs-string">&quot;utils/hello.txt&quot;</span>)<br><span class="hljs-comment"># 取出全部单词将所有单词都转化成二元元组，单词为Key，Value设置为1</span><br><span class="hljs-built_in">print</span>(rdd.flatMap(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&quot; &quot;</span>)).<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x, <span class="hljs-number">1</span>)).reduceByKey(<span class="hljs-keyword">lambda</span> x, y: x + y).collect())<br></code></pre></td></tr></table></figure><figure class="highlight txt"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs txt">itheima itheima itcast itheima<br>spark python spark python itheima<br>itheima itcast itcast itheima python<br>python python spark pyspark pyspark<br>itheima python pyspark itcast spark<br></code></pre></td></tr></table></figure><blockquote><p>输出结果：[(‘itcast’, 4), (‘python’, 6), (‘itheima’, 7), (‘spark’, 4), (‘pyspark’, 3)]</p></blockquote><h3 id="7-3-3-filter、distinct和sortBy"><a href="#7-3-3-filter、distinct和sortBy" class="headerlink" title="7.3.3 filter、distinct和sortBy"></a>7.3.3 filter、distinct和sortBy</h3><blockquote><p>filter：过滤掉不想要的，留下来的结果是想要的数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：06_filter.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 19:19 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkConf, SparkContext<br><span class="hljs-keyword">import</span> os<br><br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br>conf = SparkConf().setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>).setAppName(<span class="hljs-string">&quot;test_park&quot;</span>)<br>sparkContext = SparkContext(conf=conf)<br><br><span class="hljs-comment"># 创建一个包含整数的 RDD</span><br>rdd = sparkContext.parallelize([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>])<br><span class="hljs-comment"># 过滤掉奇数，留下来的结果是偶数</span><br><span class="hljs-built_in">print</span>(rdd.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).collect())<br></code></pre></td></tr></table></figure><blockquote><p>distinct：表示对RDD数据去重，返回新的RDD数据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 创建一个包含整数的 RDD</span><br>rdd = sparkContext.parallelize([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>, <span class="hljs-number">8</span>, <span class="hljs-number">1</span>, <span class="hljs-number">7</span>, <span class="hljs-number">5</span>])<br><span class="hljs-comment"># 过滤掉奇数，留下来的结果是偶数</span><br><span class="hljs-built_in">print</span>(rdd.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>).distinct().collect())<br></code></pre></td></tr></table></figure><blockquote><p>sortBy：对数据进行排序，基于拟定的排序依据</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python">rdd.sortBy(func, ascending=<span class="hljs-literal">False</span>, numPartitions=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># func:(T)→U  :告知按照rdd中的哪个数据进行排序，比如 lambda x:x[1] 表示按照rdd中的第二列元素进行排序</span><br><span class="hljs-comment"># ascending True升序 False 降序</span><br><span class="hljs-comment"># numPartitions:用多少分区排序</span><br></code></pre></td></tr></table></figure><p>综合案例2</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：07_综合案例2.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/05 19:42 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> *<br><br><span class="hljs-keyword">import</span> os, json<br><br><span class="hljs-comment"># 构建执行环境</span><br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br>conf = SparkConf().setMaster(<span class="hljs-string">&#x27;local[*]&#x27;</span>).setAppName(<span class="hljs-string">&#x27;account_spark&#x27;</span>)<br>sc = SparkContext(conf=conf)<br><br><span class="hljs-comment"># TODO 需求1：城市销售额排名</span><br><span class="hljs-comment"># 1.1 读取文件得到RDD</span><br>file_rdd = sc.textFile(<span class="hljs-string">&quot;utils/orders.txt&quot;</span>)<br><br><span class="hljs-comment"># 1.2取出一个个JSON字符串</span><br>json_rdd = file_rdd.flatMap(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&#x27;|&#x27;</span>))<br><br><span class="hljs-comment"># 1.3将一个个JSON字符串转换为字典</span><br>dict_rdd = json_rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: json.loads(x))<br><br><span class="hljs-comment"># 1.4取出城市和销售额数据</span><br>city_with_money_rdd = dict_rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x[<span class="hljs-string">&#x27;areaName&#x27;</span>], <span class="hljs-built_in">int</span>(x[<span class="hljs-string">&#x27;money&#x27;</span>])))<br><br><span class="hljs-comment"># 1.5按城市分组按销售额聚合,按销售额聚合结果进行排序</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;全国售卖商品销售额排序&quot;</span>, city_with_money_rdd.reduceByKey(<span class="hljs-keyword">lambda</span> x, y: x + y).sortBy(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], ascending=<span class="hljs-literal">False</span>).collect())<br><br><span class="hljs-comment"># TODO 需求2:全部城市有哪些商品类别在售卖</span><br><span class="hljs-comment"># 2.1 取出全部的商品类别</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;全部售卖商品类别&quot;</span>, dict_rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;category&#x27;</span>]).distinct().collect())<br><br><span class="hljs-comment"># TODO 需求3:北京市有哪些商品类别在售卖</span><br><span class="hljs-comment"># 3.1 取出北京市的商品类别</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;北京市售卖商品类别&quot;</span>, dict_rdd.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;areaName&#x27;</span>] == <span class="hljs-string">&#x27;北京&#x27;</span>).<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;category&#x27;</span>]).distinct().collect())<br></code></pre></td></tr></table></figure><p>7.3.4 take、reduce和count、</p><blockquote><p>reduce：按照传入的逻辑进行聚合</p><p>take：取出RDD的前N个元素，组成list返回</p><p>count：统计数据个数</p></blockquote><h2 id="7-4-算子写入文件"><a href="#7-4-算子写入文件" class="headerlink" title="7.4  算子写入文件"></a>7.4  算子写入文件</h2><p>hadoop设置分区为1的两种方式：</p><blockquote><p>方式1，SparkConf对象设置属性全局并行度为1</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">conf = SparkConf().setMaster(<span class="hljs-string">&#x27;local[*]&#x27;</span>).setAppName(<span class="hljs-string">&#x27;account_spark&#x27;</span>)<br>conf.<span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;spark.default.parallelism&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>sc = SparkContext(conf=conf)<br></code></pre></td></tr></table></figure><blockquote><p>方式2，创建RDD的时候设置(parallelize方法传入numSlices参数为1)</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 准备RDD1</span><br>rdd1 = sc.parallelize([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>, <span class="hljs-number">10</span>], numSlices=<span class="hljs-number">1</span>)<br><span class="hljs-comment"># 准备RDD2</span><br>rdd2 = sc.parallelize([(<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-number">3</span>), (<span class="hljs-string">&quot;Spark&quot;</span>, <span class="hljs-number">5</span>), (<span class="hljs-string">&quot;Hi&quot;</span>, <span class="hljs-number">7</span>)], <span class="hljs-number">1</span>)<br><span class="hljs-comment"># 准备RDD3</span><br>rdd3 = sc.parallelize([[<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>], [<span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">9</span>], [<span class="hljs-number">11</span>, <span class="hljs-number">13</span>, <span class="hljs-number">11</span>]], <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure><blockquote><p>综合案例</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：09_综合案例3.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/06 08:39 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> pyspark <span class="hljs-keyword">import</span> SparkContext, SparkConf<br><span class="hljs-keyword">import</span> os, json<br><br>os.environ[<span class="hljs-string">&quot;PYSPARK_PYTHON&quot;</span>] = <span class="hljs-string">&#x27;E:/Environment/python/python3.10.11/python.exe&#x27;</span><br>os.environ[<span class="hljs-string">&#x27;HADOOP_HOME&#x27;</span>] = <span class="hljs-string">&#x27;E:\Environment\hadoop-3.4.0&#x27;</span><br>conf = SparkConf(). \<br>    setAppName(<span class="hljs-string">&quot;hotSearch&quot;</span>). \<br>    setMaster(<span class="hljs-string">&quot;local[*]&quot;</span>). \<br>    <span class="hljs-built_in">set</span>(<span class="hljs-string">&quot;spark.default.parallelism&quot;</span>, <span class="hljs-string">&quot;1&quot;</span>)<br>sc = SparkContext(conf=conf)<br><br><span class="hljs-comment"># 读取文件转换成RDD</span><br>rdd = sc.textFile(<span class="hljs-string">&quot;utils/search_log.txt&quot;</span>)<br><span class="hljs-comment"># TODO 需求1: 热门搜索时间段Top3(小时精度)</span><br><span class="hljs-comment"># 1.1 取出全部的时间并转换为小时</span><br><span class="hljs-comment"># 1.2 转换为(小时，1)的二元元组</span><br><span class="hljs-comment"># 1.3 Key分组聚合Value</span><br><span class="hljs-comment"># 1.4 排序(降序)</span><br><span class="hljs-comment"># 1.5 取前3</span><br>result_rdd = rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>][:<span class="hljs-number">2</span>], <span class="hljs-number">1</span>)). \<br>    reduceByKey(<span class="hljs-keyword">lambda</span> x, y: x + y). \<br>    sortBy(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], ascending=<span class="hljs-literal">False</span>, numPartitions=<span class="hljs-number">1</span>). \<br>    take(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;需求1的结果是：&quot;</span>, result_rdd)<br><br><span class="hljs-comment"># TODO 需求2:热门搜索词Top3</span><br><span class="hljs-comment"># 2.1 取出全部的搜索词</span><br><span class="hljs-comment"># 2.2 (词，1)二元元组</span><br><span class="hljs-comment"># 2.3 分组聚合</span><br><span class="hljs-comment"># 2.4 排序</span><br><span class="hljs-comment"># 2.5 Top3</span><br>search_rdd = rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">2</span>], <span class="hljs-number">1</span>)). \<br>    reduceByKey(<span class="hljs-keyword">lambda</span> x, y: x + y). \<br>    sortBy(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], ascending=<span class="hljs-literal">False</span>, numPartitions=<span class="hljs-number">1</span>). \<br>    take(<span class="hljs-number">3</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;需求2的结果是：&quot;</span>, search_rdd)<br><span class="hljs-comment"># TODO 需求3:统计黑马程序员关键字在什么时段被搜索的最多</span><br><span class="hljs-comment"># 3.1 过滤内容，只保留黑马程序员关键词</span><br><span class="hljs-comment"># 3.2 转换为(小时，1)的二元元组</span><br><span class="hljs-comment"># 3.3 Key分组聚合Value</span><br><span class="hljs-comment"># 3.4 排序(降序)</span><br><span class="hljs-comment"># 3.5 取前1</span><br>key_max_in_time_rdd = rdd.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: <span class="hljs-string">&quot;黑马程序员&quot;</span> <span class="hljs-keyword">in</span> x). \<br>    <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: (x.split(<span class="hljs-string">&quot;\t&quot;</span>)[<span class="hljs-number">0</span>][:<span class="hljs-number">2</span>], <span class="hljs-number">1</span>)). \<br>    reduceByKey(<span class="hljs-keyword">lambda</span> x, y: x + y). \<br>    sortBy(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-number">1</span>], ascending=<span class="hljs-literal">False</span>, numPartitions=<span class="hljs-number">1</span>). \<br>    take(<span class="hljs-number">1</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;需求3的结果是：&quot;</span>, key_max_in_time_rdd)<br><br><span class="hljs-comment"># TODO 需求4:将数据转化为JSON格式，写到文件中</span><br><span class="hljs-comment"># 4.1 转化为JSON格式的RDD</span><br><span class="hljs-comment"># 4.2 写为文件</span><br>rdd.<span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: x.split(<span class="hljs-string">&quot;\t&quot;</span>)). \<br>    <span class="hljs-built_in">map</span>(<span class="hljs-keyword">lambda</span> x: &#123;<span class="hljs-string">&quot;Time&quot;</span>: x[<span class="hljs-number">0</span>], <span class="hljs-string">&quot;User_id&quot;</span>: x[<span class="hljs-number">1</span>], <span class="hljs-string">&quot;Search_word&quot;</span>: x[<span class="hljs-number">2</span>],<br>                   <span class="hljs-string">&quot;Search_count&quot;</span>: x[<span class="hljs-number">3</span>], <span class="hljs-string">&quot;Clicks_count&quot;</span>: x[<span class="hljs-number">4</span>], <span class="hljs-string">&quot;Search_URL&quot;</span>: x[<span class="hljs-number">5</span>]&#125;). \<br>    saveAsTextFile(<span class="hljs-string">&quot;search_log_json&quot;</span>)<br><br></code></pre></td></tr></table></figure><h1 id="八-高阶学习"><a href="#八-高阶学习" class="headerlink" title="八 高阶学习"></a>八 高阶学习</h1><h2 id="8-1-闭包"><a href="#8-1-闭包" class="headerlink" title="8.1 闭包"></a>8.1 闭包</h2><p>概念：为了改变全局变量有被修改的风险，在函数嵌套的前提下，内部函数使用了外部函数的变量，并且外部函数返回了内部函数，我们把这个使用外部函数变量的内部函数称为闭包。</p><blockquote><p>优点，使用闭包可以让我们得到：</p></blockquote><ul><li>无需定义全局变量即可实现通过函数，持续的访问、修改某个值</li><li>闭包使用的变量的所用于在函数内，难以被错误的调用修改</li></ul><blockquote><p>缺点：</p></blockquote><ul><li>由于内部函数持续引用外部函数的值，所以会导致这一部分内存空间不被释放一直占用内存</li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 简单闭包</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_logo_printer</span>(<span class="hljs-params">logo: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-built_in">callable</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    创建一个打印带有logo的消息的函数</span><br><span class="hljs-string">    :param logo: logo文本</span><br><span class="hljs-string">    :return: 一个打印带有logo的消息的函数logo_printer</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">logo_printer</span>(<span class="hljs-params">msg: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-literal">None</span>:<br>        <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">        打印带有logo的消息</span><br><span class="hljs-string">        :param msg: 消息文本</span><br><span class="hljs-string">        :return: None</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;&lt;<span class="hljs-subst">&#123;logo&#125;</span>&gt;<span class="hljs-subst">&#123;msg&#125;</span>&lt;<span class="hljs-subst">&#123;logo&#125;</span>&gt;&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> logo_printer<br><br><br>fn1 = create_logo_printer(<span class="hljs-string">&quot;中国&quot;</span>)<br>fn1(<span class="hljs-string">&quot;重庆&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p><strong>使用nonlocal关键字修改外部函数的值</strong></p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用nonlocal关键字修改外部函数的值</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_accumulator</span>(<span class="hljs-params">initial_value: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">callable</span>:<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    Creates an accumulator function that adds a given increment to the initial value.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Args:</span><br><span class="hljs-string">        initial_value: The initial value of the accumulator.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Returns:</span><br><span class="hljs-string">        A function that takes an increment and returns the updated accumulator value.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">accumulator</span>(<span class="hljs-params">increment: <span class="hljs-built_in">int</span></span>) -&gt; <span class="hljs-built_in">int</span>:<br>        <span class="hljs-keyword">nonlocal</span> initial_value<br>        initial_value += increment<br>        <span class="hljs-built_in">print</span>(initial_value)<br><br>    <span class="hljs-keyword">return</span> accumulator<br><br><br>fn = create_accumulator(<span class="hljs-number">10</span>)<br>fn(<span class="hljs-number">23</span>)<br></code></pre></td></tr></table></figure><blockquote><p>ATM小案例</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># ATM小案例</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">create_account</span>(<span class="hljs-params">initial_amount=<span class="hljs-number">0</span></span>):<br>    balance = initial_amount<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">transaction</span>(<span class="hljs-params">amount, deposit=<span class="hljs-literal">True</span></span>):<br>        <span class="hljs-keyword">nonlocal</span> balance<br>        <span class="hljs-keyword">if</span> deposit:<br>            balance += amount<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;存款：+<span class="hljs-subst">&#123;amount&#125;</span>, 余额：<span class="hljs-subst">&#123;balance&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> balance &gt;= amount:<br>                balance -= amount<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;取款：-<span class="hljs-subst">&#123;amount&#125;</span>, 余额：<span class="hljs-subst">&#123;balance&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;余额不足&quot;</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_balance</span>():<br>        <span class="hljs-keyword">return</span> balance<br><br>    <span class="hljs-keyword">return</span> transaction, get_balance<br>account, get_balance = create_account(<span class="hljs-number">1000</span>)<br>account(<span class="hljs-number">500</span>, deposit=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 存款 500</span><br>account(<span class="hljs-number">200</span>, deposit=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 取款 200</span><br><span class="hljs-built_in">print</span>(get_balance())  <span class="hljs-comment"># 获取当前余额</span><br><br></code></pre></td></tr></table></figure><h2 id="8-2-装饰器"><a href="#8-2-装饰器" class="headerlink" title="8.2 装饰器"></a>8.2 装饰器</h2><blockquote><p>普通写法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装饰器一般写法（闭包）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>():<br>    <span class="hljs-keyword">import</span> random<br>    <span class="hljs-keyword">import</span> time<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sleeping...&quot;</span>)<br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I want to sleep&quot;</span>)<br>sleep()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I have slept&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>装饰器一般写法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装饰器一般写法（闭包）</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I want to sleep&quot;</span>)<br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I have slept&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>():<br>    <span class="hljs-keyword">import</span> random<br>    <span class="hljs-keyword">import</span> time<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sleeping...&quot;</span>)<br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<br><br><span class="hljs-comment"># 使用`decorator`装饰器包装原函数`sleep`，并调用包装后的函数。</span><br>decorator(sleep)()<br></code></pre></td></tr></table></figure><blockquote><p>语法糖写法</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 装饰器的快捷写法</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">decorator</span>(<span class="hljs-params">func</span>):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">wrapper</span>():<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I want to sleep&quot;</span>)<br>        func()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I have slept&quot;</span>)<br><br>    <span class="hljs-keyword">return</span> wrapper<br><br><span class="hljs-meta">@decorator</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sleep</span>():<br>    <span class="hljs-keyword">import</span> random<br>    <span class="hljs-keyword">import</span> time<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;sleeping...&quot;</span>)<br>    time.sleep(random.randint(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>))<br><br>sleep()<br></code></pre></td></tr></table></figure><h2 id="8-3-设计模式"><a href="#8-3-设计模式" class="headerlink" title="8.3 设计模式"></a>8.3 设计模式</h2><h3 id="8-3-1-单例模式"><a href="#8-3-1-单例模式" class="headerlink" title="8.3.1 单例模式"></a>8.3.1 单例模式</h3><p>概念：单例模式(Singleton Pattern)是一种常用的软件设计模式,该模式的主要目的是确保某一个类只有一个实例存在。在整个系统中，某个类只能出现一个实例时，单例对象就能派上用场。</p><p>定义：保证一个类只有一个实例，并提供一个访问它的全局访问点</p><p>适用场景：当一个类只能有一个实例，而客户可以从一个众所周知的访问点访问它时。</p><blockquote><p>单例模式_strTools.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：单例模式_strTools.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/07 20:17 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">from</span> 单例模式_strTools  <span class="hljs-keyword">import</span> str_tools<br><br>t1 = str_tools<br>t2 = str_tools<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(t1))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(t2))<br></code></pre></td></tr></table></figure><blockquote><p>单例模式_strTools.py</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：单例模式_strTools.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/07 20:17 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">StrTools</span>:<br>    <span class="hljs-keyword">pass</span><br><br>str_tools =  StrTools()<br></code></pre></td></tr></table></figure><p><font color='red'>输出结果：相当于使用的一个实例化对象~</font></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-number">2199380285360</span><br><span class="hljs-number">2199380285360</span><br><br>进程已结束，退出代码为 <span class="hljs-number">0</span><br></code></pre></td></tr></table></figure><h3 id="8-3-2-工厂模式"><a href="#8-3-2-工厂模式" class="headerlink" title="8.3.2 工厂模式"></a>8.3.2 工厂模式</h3><p>概念：当需要大量创建一个类的实例的时候，可以使用工厂模式。即，从原生的使用类的构造去创建对象的形式迁移到，基于工厂提供的方法去创建对象的形式。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214055645.png" alt="QQ_1730982484566" style="zoom: 50%;" /><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：05_工厂模式.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/07 20:28 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Person</span>:<br>    <span class="hljs-keyword">pass</span><br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am a worker&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Student</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am a student&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Teacher</span>(<span class="hljs-title class_ inherited__">Person</span>):<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am a teacher&quot;</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Factory</span>:<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">get_person</span>(<span class="hljs-params">self, person_type</span>):<br>        <span class="hljs-keyword">if</span> person_type == <span class="hljs-string">&#x27;worker&#x27;</span>:<br>            <span class="hljs-keyword">return</span> Worker()<br>        <span class="hljs-keyword">elif</span> person_type == <span class="hljs-string">&#x27;student&#x27;</span>:<br>            <span class="hljs-keyword">return</span> Student()<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">return</span> Teacher()<br><br><br>factory = Factory()<br><span class="hljs-built_in">print</span>(factory.get_person(<span class="hljs-string">&#x27;worker&#x27;</span>))<br><span class="hljs-built_in">print</span>(factory.get_person(<span class="hljs-string">&#x27;student&#x27;</span>))<br><span class="hljs-built_in">print</span>(factory.get_person(<span class="hljs-string">&#x27;teacher&#x27;</span>))<br></code></pre></td></tr></table></figure><h2 id="8-4-多线程"><a href="#8-4-多线程" class="headerlink" title="8.4 多线程"></a>8.4 多线程</h2><h3 id="8-4-1-进程、线程和并行执行"><a href="#8-4-1-进程、线程和并行执行" class="headerlink" title="8.4.1 进程、线程和并行执行"></a>8.4.1 进程、线程和并行执行</h3><p>进程：就是一个程序,运行在系统之上，那么便称之这个程序为一个运行进程，并分配进程ID方便系统管理。<br>线程：线程是归属于进程的，一个进程可以开启多个线程，执行不同的工作，是进程的实际工作最小单位。</p><p>并行执行：同一时间做不同的工作。</p><p>进程之间就是并行执行的，操作系统可以同时运行好多程序，这些程序都是在并行执行。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214059451.png" alt="QQ_1730983615518" style="zoom:67%;" /><blockquote><p>进程之间是内存隔离的，即不同的进程拥有各自的内存空间。这就类似于不同的公司拥有不同的办公场所。</p><p>线程之间是内存共享的，线程是属于进程的，一个进程内的多个线程之间是共享这个进程所拥有的内存空间的，</p><p>这就好比，公司员工之间是共享公司的办公场所。</p></blockquote><h3 id="8-4-2-多线程编程"><a href="#8-4-2-多线程编程" class="headerlink" title="8.4.2 多线程编程"></a>8.4.2 多线程编程</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214103457.png" alt="QQ_1730986269110" style="zoom:50%;" /><p>单线程示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am singing....&quot;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dance</span>():<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;I am dancing....&quot;</span>)<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    sing()<br>    dance()<br></code></pre></td></tr></table></figure><p>多线程：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：06_多线程.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/07 21:33 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> time, threading<br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">sing</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(msg)<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">dance</span>(<span class="hljs-params">msg</span>):<br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        <span class="hljs-built_in">print</span>(msg)<br>        time.sleep(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建一个唱歌的进程，并传入参数args=(&#x27;我在唱歌&#x27;,)，一定要带括号才是元组形式</span><br>    sing_thread = threading.Thread(target=sing, args=(<span class="hljs-string">&#x27;我在唱歌&#x27;</span>,))<br><br>    <span class="hljs-comment"># 创建一个跳舞的进程</span><br>    dance_thread = threading.Thread(target=dance,kwargs=&#123;<span class="hljs-string">&#x27;msg&#x27;</span>:<span class="hljs-string">&#x27;我在跳舞&#x27;</span>&#125;)<br>    sing_thread.start()<br>    dance_thread.start()<br></code></pre></td></tr></table></figure><h2 id="8-5-网络编程"><a href="#8-5-网络编程" class="headerlink" title="8.5 网络编程"></a>8.5 网络编程</h2><p>socket(简称 套接字)是进程之间通信一个工具，好比现实生活中的插座，所有的家用电器要想工作都是基于插座进行，<font color='red'>进程之间想要进行网络通信需要socket</font>。<br>Socket负责进程之间的网络数据传输，好比数据的搬运工。</p><h3 id="8-5-1-服务端编程"><a href="#8-5-1-服务端编程" class="headerlink" title="8.5.1 服务端编程"></a>8.5.1 服务端编程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：07_socket_服务端开发.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/08 18:33 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> socket<br><br><span class="hljs-comment"># 创建Socket对象</span><br>socket_server = socket.socket()<br><span class="hljs-comment"># 绑定ip地址和端口</span><br>socket_server.bind((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>))<br><span class="hljs-comment"># 监听端口，括号内的是服务器监听数量</span><br>socket_server.listen(<span class="hljs-number">5</span>)<br><span class="hljs-comment"># 等待客户端连接</span><br><span class="hljs-comment"># result: tuple = socket_server.accept()</span><br><span class="hljs-comment"># conn = result[0]</span><br><span class="hljs-comment"># address = result[1]</span><br>conn, address = socket_server.accept()<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;接收到了客户端的连接，客户端的信息是：<span class="hljs-subst">&#123;address&#125;</span>&quot;</span>)<br><br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 接受客户端信息recv是缓冲区的大小，一般给定1024即可</span><br>    data: <span class="hljs-built_in">str</span> = conn.recv(<span class="hljs-number">1024</span>).decode(<span class="hljs-string">&quot;utf-8&quot;</span>)<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;客户端发来的消息是:<span class="hljs-subst">&#123;data&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 发送回复消息</span><br>    msg = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你要和客户端回复的消息：&quot;</span>)<br>    <span class="hljs-keyword">if</span> msg == <span class="hljs-string">&quot;exit&quot;</span>:<br>        <span class="hljs-keyword">break</span><br>    conn.send(msg.encode(<span class="hljs-string">&quot;utf-8&quot;</span>))<br><br><span class="hljs-comment"># 关闭链接</span><br>conn.close()<br>socket_server.close()<br></code></pre></td></tr></table></figure><h3 id="8-5-2-客户端编程"><a href="#8-5-2-客户端编程" class="headerlink" title="8.5.2 客户端编程"></a>8.5.2 客户端编程</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：08_socket_客户端开发.py.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：AlaskaBoo</span><br><span class="hljs-string">@Date    ：2024/11/08 19:08 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br><span class="hljs-keyword">import</span> socket<br><span class="hljs-comment"># 创建socket对象</span><br>socket_client = socket.socket()<br><span class="hljs-comment"># 连接到服务端</span><br>socket_client.connect((<span class="hljs-string">&#x27;127.0.0.1&#x27;</span>, <span class="hljs-number">8888</span>))<br><span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>    <span class="hljs-comment"># 发送消息</span><br>    msg = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入要给服务器发送的消息:&quot;</span>)<br>    <span class="hljs-keyword">if</span> msg == <span class="hljs-string">&#x27;exit&#x27;</span>:<br>       <span class="hljs-keyword">break</span><br>    socket_client.send(msg.encode(<span class="hljs-string">&#x27;utf-8&#x27;</span>))<br>    <span class="hljs-comment"># 接收返回消息</span><br>    receive_data = socket_client.recv(<span class="hljs-number">1024</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;服务端回复的消息是：<span class="hljs-subst">&#123;receive_data.decode(<span class="hljs-string">&#x27;utf-8&#x27;</span>)&#125;</span>&quot;</span>)<br><span class="hljs-comment"># 关闭链接</span><br>socket_client.close()<br></code></pre></td></tr></table></figure><h2 id="8-6-正则表达式"><a href="#8-6-正则表达式" class="headerlink" title="8.6 正则表达式"></a>8.6 正则表达式</h2><h3 id="8-6-1-基本概念"><a href="#8-6-1-基本概念" class="headerlink" title="8.6.1 基本概念"></a>8.6.1 基本概念</h3><p>正则表达式，又称规则表达式(Regular Expression)，是使用单个字符串来描述、匹配某个句法规则的字符串，常被用来检索、替换那些符合某个模式(规则)的文本。即字符串定义规则，并通过规则去验证字符串是否匹配。</p><blockquote><p>比如，验证一个字符串是否是符合条件的电子邮箱地址，只需要配置好正则规则，即可匹配任意邮箱。</p><p>比如通过正则规则：(^[\w-]+(\.[\w-]+)*@[\w-]+(\.[\w-]+)+$)即可匹配一个字符串是否是标准邮箱格式</p><p>但如果不使用正则，使用ifelse来对字符串做判断就非常困难了</p></blockquote><p>Python正则表达式，使用re模块，并基于re模块中三个基础方法来做正则匹配。</p><p>分别是：match、search、findall 三个基础方法</p><blockquote><p>re.match(匹配规则，被匹配字符串)</p><p>从被匹配字符串开头进行匹配，匹配成功返回匹配对象(包含匹配的信息)，匹配不成功返回空</p></blockquote><p>低阶使用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：09_正则表达式.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：AlaskaBoo</span><br><span class="hljs-string">@Date    ：2024/11/08 19:53 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> re<br><br>s = <span class="hljs-string">&#x27;python itheima itcast python python itheima&#x27;</span><br><span class="hljs-comment"># match 从头匹配</span><br>result = re.<span class="hljs-keyword">match</span>(<span class="hljs-string">&quot;python&quot;</span>, s)<br><span class="hljs-built_in">print</span>(result)<br><br><span class="hljs-comment"># search 从头开始搜索，找到第一个匹配项</span><br>result = re.search(<span class="hljs-string">&quot;itcast&quot;</span>, s)<br><span class="hljs-built_in">print</span>(result)<br><br><span class="hljs-comment"># findall 返回所有匹配项的列表</span><br>result = re.findall(<span class="hljs-string">&quot;python&quot;</span>, s)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h3 id="8-6-2-元字符匹配"><a href="#8-6-2-元字符匹配" class="headerlink" title="8.6.2 元字符匹配"></a>8.6.2 元字符匹配</h3><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>.</td><td>匹配任意一个字符（除了\n），\.匹配点本身</td></tr><tr><td>[]</td><td>匹配[]中列举的字符</td></tr><tr><td>\d</td><td>匹配数字，即0-9</td></tr><tr><td>\D</td><td>匹配非数字</td></tr><tr><td>\s</td><td>匹配空白，即空格、tab键</td></tr><tr><td>\S</td><td>匹配非空白</td></tr><tr><td>\w</td><td>匹配单词字符，即a-z、A-Z、0-9、_</td></tr><tr><td>\W</td><td>匹配非单词字符</td></tr></tbody></table><p>数量匹配：</p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>*</td><td>匹配前一个规则的字符出现0至无数次</td></tr><tr><td>+</td><td>匹配前一个规则的字符出现1至无数次</td></tr><tr><td>?</td><td>匹配前一个规则的字符出现出现0次或1次</td></tr><tr><td>{m}</td><td>匹配前一个规则的字符出现出现m次</td></tr><tr><td>{m,}</td><td>匹配前一个规则的字符出现至少出现m次</td></tr><tr><td>{m,n}</td><td>匹配前一个规则的字符出现m到n次</td></tr></tbody></table><p>边界匹配：</p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>^</td><td>匹配字符串开头</td></tr><tr><td>$</td><td>匹配字符串结尾</td></tr><tr><td>\b</td><td>匹配一个单词的边界</td></tr><tr><td>\B</td><td>匹配非单词边界</td></tr></tbody></table><p>分组匹配：</p><table><thead><tr><th>字符</th><th>功能</th></tr></thead><tbody><tr><td>|</td><td>匹配左右任意一个表达式</td></tr><tr><td>()</td><td>将括号中字符作为一个分组</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：09_正则表达式_元字符匹配.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：AlaskaBoo</span><br><span class="hljs-string">@Date    ：2024/11/08 20:21 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> re<br><br>s = <span class="hljs-string">&quot;itcast1 @@python131￥%R#$%^&amp;*() ！！ 666 ##itheima3&quot;</span><br><br>result = re.findall(<span class="hljs-string">r&quot;[a-zA-Z0-9]&quot;</span>, s)<br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-comment"># 匹配账号，只能由字母和数字组成，长度限制6到10位</span><br>r = <span class="hljs-string">&quot;^[a-zA-Z0-9]&#123;6,10&#125;$&quot;</span><br>s = <span class="hljs-string">&quot;itcast1&quot;</span><br>s1 = <span class="hljs-string">&#x27;123456789990&#x27;</span><br><span class="hljs-built_in">print</span>(re.findall(r, s))<br><span class="hljs-built_in">print</span>(re.findall(r, s1))<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;-----------------------&quot;</span>)<br><span class="hljs-comment"># 匹配QQ号，要求纯数字，长度5-11，第一位不为0</span><br>r = <span class="hljs-string">&quot;^[1-9][0-9]&#123;4,10&#125;$&quot;</span><br>s = <span class="hljs-string">&quot;123456789&quot;</span><br>s1 = <span class="hljs-string">&#x27;123456789990&#x27;</span><br><span class="hljs-built_in">print</span>(re.findall(r, s))<br><span class="hljs-built_in">print</span>(re.findall(r, s1))<br><br><br><span class="hljs-comment"># 匹配邮箱地址，只允许qq、163、gmail这三种邮箱地址</span><br>r = <span class="hljs-string">r&quot;(^[\w-]+(\.[\w-]+)*@(163|qq|gmail)(\.[\w-]+)+$)&quot;</span><br>s = <span class="hljs-string">&quot;upchh@example.com&quot;</span><br>s1 = <span class="hljs-string">&#x27;anpch@126.com&#x27;</span><br>s2 = <span class="hljs-string">&#x27;envkt@163.com&#x27;</span><br>s3 = <span class="hljs-string">&#x27;envkt@qq.com&#x27;</span><br>s4 = <span class="hljs-string">&#x27;envkt@gmail.com&#x27;</span><br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(r, s))<br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(r, s1))<br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(r, s2))<br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(r, s3))<br><span class="hljs-built_in">print</span>(re.<span class="hljs-keyword">match</span>(r, s4))<br></code></pre></td></tr></table></figure><h2 id="8-7-递归"><a href="#8-7-递归" class="headerlink" title="8.7 递归"></a>8.7 递归</h2><ol><li><p>概念：在满足条件的情况下，函数自己调用自己的一种特殊编程</p></li><li><p>技巧递归需要注意什么？</p><ul><li><p>注意退出的条件，否则容易变成无限递归</p></li><li><p>注意返回值的传递，确保从最内层，层层传递到最外层</p></li></ul></li><li><p>os模块的3个方法</p><ul><li>os.listdir，列出指定目录下的内容</li><li>os.path.isdir，判断给定路径是否是文件夹，是返回True，否返回False</li><li>os.path.exists，判断给定路径是否存在，存在返回True，否则返回False</li></ul></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: UTF-8 -*-</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">@Project ：pythonProject </span><br><span class="hljs-string">@File    ：10_递归.py</span><br><span class="hljs-string">@IDE     ：PyCharm </span><br><span class="hljs-string">@Author  ：Alaskaboo</span><br><span class="hljs-string">@Date    ：2024/11/08 21:05 </span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-keyword">import</span> os<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">test_os</span>():<br>    <span class="hljs-comment"># 列出路径下的内容</span><br>    <span class="hljs-comment"># print(os.listdir(&quot;E:\Markdown&quot;))</span><br>    <span class="hljs-comment"># 判断指定路径是不是文件夹</span><br>    <span class="hljs-comment"># print(os.path.isdir(&quot;E:\Markdown&quot;))</span><br>    <span class="hljs-comment"># 判断指定路径是不是存在</span><br>    <span class="hljs-built_in">print</span>(os.path.exists(<span class="hljs-string">&quot;E:\Markdown&quot;</span>))<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_files_recursion_from_dir</span>(<span class="hljs-params">path</span>):<br>    <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    从指定的文件夹中使用递归的方式,获取全部的文件列表</span><br><span class="hljs-string">    :param path: 被判断的文件夹</span><br><span class="hljs-string">    :return: list,包含全部的文件,如果目录不存在或者无文件就返回一个空list</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;当前调用的路径是:<span class="hljs-subst">&#123;path&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># 初始化一个空list</span><br>    file_list = []<br>    <span class="hljs-keyword">if</span> os.path.exists(path):<br>        <span class="hljs-keyword">for</span> f <span class="hljs-keyword">in</span> os.listdir(path):<br>            new_path = path + <span class="hljs-string">&#x27;/&#x27;</span> + f<br>            <span class="hljs-comment"># 如果是文件夹,就递归调用</span><br>            <span class="hljs-keyword">if</span> os.path.isdir(new_path):<br>                file_list += get_files_recursion_from_dir(new_path)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 如果是文件,就添加到列表中</span><br>                file_list.append(new_path)<br><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;指定文件目录<span class="hljs-subst">&#123;path&#125;</span>,不存在&quot;</span>)<br>        <span class="hljs-keyword">return</span> []<br>    <span class="hljs-keyword">return</span> file_list<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test_os()<br>    <span class="hljs-built_in">print</span>(get_files_recursion_from_dir(<span class="hljs-string">r&quot;D:\上工程文件&quot;</span>))<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>机器学习</category>
      
    </categories>
    
    
    <tags>
      
      <tag>python</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Java数据结构</title>
    <link href="/2024/06/25/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    <url>/2024/06/25/Java%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<h1 id="一、队列"><a href="#一、队列" class="headerlink" title="一、队列"></a>一、队列</h1><h2 id="1-多项式相关"><a href="#1-多项式相关" class="headerlink" title="1.多项式相关"></a>1.多项式相关</h2><p>加法运算实现</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c">Polynomial <span class="hljs-title function_">PolyAdd</span> <span class="hljs-params">(Polynomial P1, Polynomial P2)</span>&#123;<br>    Polynomial front, rear, temp;<br>    <span class="hljs-type">int</span> sum;<br>    rear=(Polynomial) <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<span class="hljs-comment">/*由front记录结果多项式链表头结点*/</span><br>    front = rear;<br>    <span class="hljs-keyword">while</span>(P1 &amp;&amp; P2)<span class="hljs-comment">/*当两个多项式都有非零项待处理时*/</span><br>        <span class="hljs-keyword">switch</span> (Compare(P1-&gt;expon, P2-&gt;expon))&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>                Attach( P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>                P1 = P1-&gt;link;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">-1</span>:<br>                Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);<br>                P2 = P2-&gt;link;<span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>                sum =P1-&gt;coef + P2-&gt;coef;<br>                <span class="hljs-keyword">if</span> ( sum )Attach(sum, P1-&gt;expon, &amp;rear);<br>                P1 = P1-&gt;link;<br>                P2 = P2-&gt;link;<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br><span class="hljs-comment">/*将未处理完的另一个多项式的所有节点依次复制到结果多项式中去*/</span><br>    <span class="hljs-keyword">for</span>( ; P1; P1=P1-&gt;link)Attach(P1-&gt;coef, P1-&gt;expon, &amp;rear);<br>    <span class="hljs-keyword">for</span>( ; P2; P2 = P2-&gt;link)Attach(P2-&gt;coef, P2-&gt;expon, &amp;rear);<br>    rear-&gt;link = <span class="hljs-literal">NULL</span>;<br>    temp = front;<br>    front=front-&gt;link;<span class="hljs-comment">/*令front指向结果多项式第一个非零项*/</span><br>    <span class="hljs-built_in">free</span>(temp);<span class="hljs-comment">/*释放临时空表头结点*/</span><br>    <span class="hljs-keyword">return</span> front;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Attach</span><span class="hljs-params">( <span class="hljs-type">int</span> c, <span class="hljs-type">int</span> e, Polynomial *pRear )</span><br>&#123;<br>    Polynomial P;<br>    P=(Polynomial)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<br>    P-&gt;coef=c;<span class="hljs-comment">/*对新结点赋值*/</span><br>    P-&gt;expon = e;<br>    P-&gt;link = <span class="hljs-literal">NULL</span>;<br>    (*pRear)-&gt;link= P;<br>    *pRear = P;<span class="hljs-comment">/*修改pRear值 */</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-多项式练习题"><a href="#2-多项式练习题" class="headerlink" title="2.多项式练习题"></a>2.多项式练习题</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182533322.png" alt="image-20240918110651700" style="zoom:33%;" /><p>方法一：</p><p><strong>数组</strong>：编程简单、调试容易；事先确定数组大小</p><p><strong>链表</strong>：动态性强；编程略微复杂、调试比较困难</p><p>数据结构设计</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span> *<span class="hljs-title">Polynomial</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">PolyNode</span>&#123;</span><br>    <span class="hljs-type">int</span> coef;<br>    <span class="hljs-type">int</span> expon;<br>    Polynomial link;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182537561.png" alt="image-20240918111725133" style="zoom: 33%;" /><p><strong>程序框架</strong>：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182539614.png" alt="image-20240918111924526" style="zoom:33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c">读入程序：<br>Polynomial <span class="hljs-title function_">ReadPoly</span><span class="hljs-params">()</span><br>&#123;<br>   Polynomial P, Rear, t;<br>    <span class="hljs-type">int</span> c, e, N;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    P=(Polynomial)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<span class="hljs-comment">/*链表头空结点 */</span><br>    P-&gt;link = <span class="hljs-literal">NULL</span>;<br>    Rear = P;<br>    <span class="hljs-keyword">while</span>(N--)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;c, &amp;e);<br>        Attach(c, e, &amp;Rear);<span class="hljs-comment">/*将当前项插入多项式尾部*/</span><br>    &#125;<br>    t=P;P=P-&gt;link; <span class="hljs-built_in">free</span>(t);<span class="hljs-comment">/*删除临时生成的头结点*/</span><br>    <span class="hljs-keyword">return</span> P; <br>&#125;<br><br><span class="hljs-type">void</span>  lynomial *pRear )<br>&#123;<br>    Polynomial P;<br>    P=(Polynomial)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> PolyNode));<br>    P-&gt;coef=c;<span class="hljs-comment">/*对新结点赋值*/</span><br>    P-&gt;expon = e;<br>    P-&gt;link = <span class="hljs-literal">NULL</span>;<br>    (*pRear)-&gt;link= P;<br>    *pRear = P;<span class="hljs-comment">/*修改pRear值 */</span><br>&#125;<br></code></pre></td></tr></table></figure><hr><h1 id="二、树"><a href="#二、树" class="headerlink" title="二、树"></a>二、树</h1><h2 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 <strong>基本概念</strong></h2><p>定义：n(n≥0)个结点构成的有限集合。当n&#x3D;0时，称为空树；对于任一棵非空树(n&gt;0)，它具备以下性质:</p><blockquote><ul><li>树中有一个称为 “根(Root)” 的特殊结点，用r表示;</li><li>其余结点可分为m(m&gt;0)个互不相交的有限集T1，T2…. ，Tm，其中每个集合本身又是一棵树，称为原来树的“<strong>子树(Sub Tree</strong>)”</li></ul></blockquote><p><strong>作用</strong>：用于查找。查找又分为静态和动态.</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182544901.png" alt="image-20240921173434959" style="zoom: 33%;" /><p><strong>特点</strong>：</p><blockquote><ul><li><p>子树是不相交的；</p></li><li><p>除了根节点外，每个结点有且仅有一个父节点</p></li><li><p>一棵树<strong>N</strong>个结点的树有<strong>N-1</strong>条边</p></li></ul></blockquote><p>树的基本术语</p><blockquote><ol><li><p>结点的度(Degree)：结点的子树个数；</p></li><li><p>树的度：树的所有结点中最大的度数树的度；</p></li><li><p>叶结点(Leaf)：度为0的结点；</p></li><li><p>父结点(Parent)：有子树的结点是其子树的根结点的父结点；</p></li><li><p>子结点(Child)：若A结点是B结点的父结点，则称B结点是A结点的子结点；子结点也称孩子结点；</p></li><li><p>兄弟结点(Sibling)：具有同一父结点的各结点彼此是兄弟结点；</p></li><li><p>路径和路径长度：从结点n1到nk的路径为一个结点序列n1，n2，…，nk，ni是 ni+1的父结点。路径所包含边的个数为路径的长度。</p></li><li><p>祖先结点(Ancestor)：沿树根到某一结点路径上的所有结点都是这个结点的祖先结点。</p></li><li><p>子孙结点(Descendant):：某一结点的子树中的所有结点是这个结点的子孙。</p></li><li><p>11.结点的层次(Level):规定根结点在1层其它任一结点的层数是其父结点的层数加1.12.树的深度(Depth):树中所有结点中的最大层次是这棵树的深度。</p></li></ol></blockquote><hr><h2 id="2-二叉树"><a href="#2-二叉树" class="headerlink" title="2 二叉树"></a>2 二叉树</h2><h3 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><h4 id="2-1-1-二叉树定义"><a href="#2-1-1-二叉树定义" class="headerlink" title="2.1.1 二叉树定义"></a><strong>2.1.1 二叉树定义</strong></h4><blockquote><p>一个又穷的结点集合。这个集合可以为空，若不为空，则它是由根节点和称为其左子树T˪和右子树Tᵣ的两个不相交的二叉树组成</p></blockquote><p>几个重要性质</p><blockquote><ul><li>一个二叉树第i层的最大结点数为：2ⁱ⁻¹，i≥1。</li><li>深度为k的二叉树有最大结点总数为：2ᵏ-1，k≥1</li><li>对任何非空二叉树T，若n₀表示叶结点的个数、n₂是度为2的非叶结点个数，那么两者满足关系n₀&#x3D;n₂+1</li></ul></blockquote><h4 id="2-1-2-抽象数据定义"><a href="#2-1-2-抽象数据定义" class="headerlink" title="2.1.2 抽象数据定义"></a><strong>2.1.2 抽象数据定义</strong></h4><blockquote><p>数据对象集：一个有穷的结点集合。若不为空，则由根结点和其左、右二叉子树组成。<br>操作集：BT∈BinTree，ltem∈ElementType，重要操作有:</p><ol><li>Boolean lsEmpty ( BinTree BT)：判别BT是否为空；</li><li>void Traversal ( BinTree BT)：遍历，按某顺序访问每个结点；</li><li>BinTree CreatBinTree( )：创建一个二叉树。</li></ol></blockquote><h4 id="2-1-3-五种基本形式"><a href="#2-1-3-五种基本形式" class="headerlink" title="2.1.3 五种基本形式"></a><strong>2.1.3 五种基本形式</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182549178.png" alt="image-20240921205440389" style="zoom:50%;" /><h4 id="2-1-4-子树左右顺序之分"><a href="#2-1-4-子树左右顺序之分" class="headerlink" title="2.1.4 子树左右顺序之分"></a><strong>2.1.4 子树左右顺序之分</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182621849.png" alt="image-20240921205549032" style="zoom:50%;" /><h3 id="2-2-特殊二叉树"><a href="#2-2-特殊二叉树" class="headerlink" title="2.2 特殊二叉树"></a><strong>2.2 特殊二叉树</strong></h3><h4 id="2-2-1-斜二叉树"><a href="#2-2-1-斜二叉树" class="headerlink" title="2.2.1 斜二叉树"></a>2.2.1 <strong>斜二叉树</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182624700.png" alt="image-20240921210107666" style="zoom: 50%;" /><h4 id="2-2-2-完美二叉树（满二叉树）"><a href="#2-2-2-完美二叉树（满二叉树）" class="headerlink" title="2.2.2 完美二叉树（满二叉树）"></a>2.2.2 <strong>完美二叉树（满二叉树）</strong></h4><p>​</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182627334.png" alt="image-20240921210411046" style="zoom:50%;" /><h4 id="2-2-3-完全二叉树"><a href="#2-2-3-完全二叉树" class="headerlink" title="2.2.3 完全二叉树"></a>2.2.3 <strong>完全二叉树</strong></h4><p>跟满二叉树相似，但是不同点是完全二叉树可以比满二叉树少后面连续的几个度。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182629852.png" alt="image-20240921210815710" style="zoom: 50%;" /><hr><h3 id="2-3-存储结构"><a href="#2-3-存储结构" class="headerlink" title="2.3 存储结构"></a>2.3 存储结构</h3><h4 id="2-3-1-顺序存储"><a href="#2-3-1-顺序存储" class="headerlink" title="2.3.1 顺序存储"></a>2.3.1 顺序存储</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182632350.png" alt="image-20240921213837317" style="zoom: 50%;" /><blockquote><p>注：一般二叉树也可实现这种方法，但是必须造成空间额外的开销</p></blockquote><h4 id="2-3-2-链表存储"><a href="#2-3-2-链表存储" class="headerlink" title="2.3.2 链表存储"></a>2.3.2 链表存储</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182635532.png" alt="image-20240921214256797" style="zoom:25%;" /><hr><h3 id="2-4-常用的遍历"><a href="#2-4-常用的遍历" class="headerlink" title="2.4 常用的遍历"></a>2.4 常用的遍历</h3><h4 id="2-4-1-先序遍历"><a href="#2-4-1-先序遍历" class="headerlink" title="2.4.1 先序遍历"></a>2.4.1 先序遍历</h4><p>遍历过程（根、左子树、右子树）：①访问根结点；②先序遍历其左子树；③先序遍历其右子树</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Preordertraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>   <span class="hljs-keyword">if</span>( BT )&#123;<br>       <span class="hljs-built_in">printf</span>(“d<span class="hljs-string">&quot;, BT-&gt;Data);</span><br><span class="hljs-string">       PreOrderTraversal( BT -&gt; Left );</span><br><span class="hljs-string">       PreOrderTraversal( BT -&gt; Right );</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>例：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182639361.png" alt="image-20240921215940230" style="zoom:33%;" /><blockquote><p>先序遍历 &#x3D;&gt; <strong>A (B D F E) (C G H I)</strong></p></blockquote><hr><p>先序非递归遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    BinTree T=BT;<br>    Stack S = Creatstack(MaxSize);   <span class="hljs-comment">/*创建并初始化堆栈S*/</span><br>    <span class="hljs-keyword">while</span>( T || !IsEmpty(S) )&#123;<br>        <span class="hljs-keyword">while</span>( T )&#123; <span class="hljs-comment">/*一直向左并将沿途结点压入堆栈*/</span><br>            Push( S, T);<br>            <span class="hljs-built_in">printf</span>(“%<span class="hljs-number">5</span>d”, T-&gt;Data);     <span class="hljs-comment">/*(访问)打印结点*/</span><br>            T = T -&gt; Left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( !IsEmpty(S) ) &#123;<br>            T=Pop(S);<span class="hljs-comment">/*结点弹出堆栈*/</span><br>            T=T-&gt;Right;<span class="hljs-comment">/*转向右子树*/</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-2-中序遍历"><a href="#2-4-2-中序遍历" class="headerlink" title="2.4.2 中序遍历"></a>2.4.2 中序遍历</h4><p>遍历过程（左子树、根、右子树）：①先序遍历其左子树；②访问根结点；③先序遍历其右子树；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Preordertraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>   <span class="hljs-keyword">if</span>( BT )&#123;<br>       PreOrderTraversal( BT -&gt; Left );<br>       <span class="hljs-built_in">printf</span>(“d<span class="hljs-string">&quot;, BT-&gt;Data);</span><br><span class="hljs-string">       PreOrderTraversal( BT -&gt; Right );</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>例：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182645148.png" alt="image-20240922101547651" style="zoom:33%;" /><blockquote><p>中序遍历&#x3D;&gt; ( D B E F ) A ( G H C I)</p></blockquote><hr><p>中序也可以用递归来实现：</p><ul><li>遇到一个结点，就把它压栈，并去遍历它的左子树；</li><li>当左子树遍历结束后，从栈顶弹出这个结点并访问它；</li><li>然后按其右指针再去中序遍历该结点的右子树。</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    BinTree T=BT;<br>    Stack S = Creatstack(MaxSize);   <span class="hljs-comment">/*创建并初始化堆栈S*/</span><br>    <span class="hljs-keyword">while</span>( T || !IsEmpty(S) )&#123;<br>        <span class="hljs-keyword">while</span>( T )&#123; <span class="hljs-comment">/*一直向左并将沿途结点压入堆栈*/</span><br>            Push( S, T);<br>            T = T -&gt; Left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( !IsEmpty(S) ) &#123;<br>            T=Pop(S);<span class="hljs-comment">/*结点弹出堆栈*/</span><br>            <span class="hljs-built_in">printf</span>(“%<span class="hljs-number">5</span>d”, T-&gt;Data);     <span class="hljs-comment">/*(访问)打印结点*/</span><br>            T=T-&gt;Right;<span class="hljs-comment">/*转向右子树*/</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-3-后序遍历"><a href="#2-4-3-后序遍历" class="headerlink" title="2.4.3 后序遍历"></a>2.4.3 后序遍历</h4><p>遍历过程（左子树、右子树、根）：①先序遍历其左子树；②先序遍历其右子树③访问根结点；</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Preordertraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>   <span class="hljs-keyword">if</span>( BT )&#123;<br>       PreOrderTraversal( BT -&gt; Left );<br>       PreOrderTraversal( BT -&gt; Right );<br>       <span class="hljs-built_in">printf</span>(“d<span class="hljs-string">&quot;, BT-&gt;Data);</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><p>例：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182648267.png" alt="image-20240922102258463" style="zoom:33%;" /><blockquote><p>后序遍历&#x3D;&gt; (D E F B) (H G I C) A</p></blockquote><hr><p>后续非递归遍历：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InOrderTraversal</span><span class="hljs-params">( BinTree BT )</span><br>&#123;<br>    BinTree T=BT;<br>    Stack S = Creatstack(MaxSize);   <span class="hljs-comment">/*创建并初始化堆栈S*/</span><br>    <span class="hljs-keyword">while</span>( T || !IsEmpty(S) )&#123;<br>        <span class="hljs-keyword">while</span>( T )&#123; <span class="hljs-comment">/*一直向左并将沿途结点压入堆栈*/</span><br>            Push( S, T);<br>            T = T -&gt; Left;<br>        &#125;<br>        <span class="hljs-keyword">if</span>( !IsEmpty(S) ) &#123;<br>            T=Pop(S);<span class="hljs-comment">/*结点弹出堆栈*/</span><br>            T=T-&gt;Right;<span class="hljs-comment">/*转向右子树*/</span><br>            <span class="hljs-built_in">printf</span>(“%<span class="hljs-number">5</span>d”, T-&gt;Data);     <span class="hljs-comment">/*(访问)打印结点*/</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h4 id="2-4-4-层次遍历"><a href="#2-4-4-层次遍历" class="headerlink" title="2.4.4 层次遍历"></a>2.4.4 层次遍历</h4><p>层次遍历过程：从上到下、从左到右。</p><p>**队列实现：**遍历从根结点开始，首先将根结点入队，然后开始执行循环：（结点出队、访问该结点、其左右儿子入队）</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182651345.png" alt="image-20240922105423876" style="zoom: 33%;" /><p>实现思路：</p><blockquote><p>先放入A，抛出A。 再依次放入左右儿子B C，再抛出B。再放入B的左右儿子D F，抛出C。放入C的左右孩子G I，抛出D。由于D没有左右孩子，抛出F。放入E，抛出G。放入 H，抛出I，最后抛出E H。</p></blockquote><hr><blockquote><p>A B C D F G I E H</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">LevelOrderTraversal</span><span class="hljs-params">(BinTree BT)</span><br>&#123;<br>    Queue Q;<br>    BinTree T;<span class="hljs-comment">/*若是空树则直接返回*/</span><br>    <span class="hljs-keyword">if</span>( !BT ) <span class="hljs-keyword">return</span>;<br>    Q = CreatQueue( Maxsize );<span class="hljs-comment">/*创建并初始化队列Q*/</span><br>    AddQ(Q, BT);<br>    <span class="hljs-keyword">while</span>(!IsEmptyQ( Q ))&#123;<br>        T = DeleteQ( Q );<br>        <span class="hljs-built_in">printf</span>(“%d\n”, T-&gt;Data);<span class="hljs-comment">/*访间取出队列的结点*/</span><br>        <span class="hljs-keyword">if</span>( T -&gt; Left)    AddQ( Q, T-&gt;Left);<br>        <span class="hljs-keyword">if</span>( T -&gt; Right)   AddQ( Q, T-&gt;Right);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><hr><h3 id="2-5-二叉树的应用"><a href="#2-5-二叉树的应用" class="headerlink" title="2.5 二叉树的应用"></a>2.5 二叉树的应用</h3><h4 id="2-5-1-输出二叉树中的叶子结点"><a href="#2-5-1-输出二叉树中的叶子结点" class="headerlink" title="2.5.1 输出二叉树中的叶子结点"></a>2.5.1 输出二叉树中的叶子结点</h4><p>再二叉树的遍历算法中增加检测结点的“左右子树是否都为空”。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-type">void</span> <span class="hljs-title function_">PrerderPrintLeaves</span><span class="hljs-params">(BinTree B)</span>&#123;<br>    <span class="hljs-keyword">if</span>(BT )&#123;<br>        <span class="hljs-keyword">if</span>( !BT -&gt; Left &amp;&amp; !BT -&gt; Right )&#123;<br>            <span class="hljs-built_in">printf</span>(“%d<span class="hljs-string">&quot;, BT-&gt;Data );</span><br><span class="hljs-string">        PreOrderPrintLeaves(BT -&gt; Left);</span><br><span class="hljs-string">        PreOrderPrintLeaves(BT -&gt; Right); </span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">&#125;</span><br></code></pre></td></tr></table></figure><h4 id="2-5-2-二叉树的高度"><a href="#2-5-2-二叉树的高度" class="headerlink" title="2.5.2 二叉树的高度"></a>2.5.2 二叉树的高度</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182654822.png" alt="image-20240922112411335" style="zoom:33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">PostorderGetHeight( Bintree BT )<br>&#123;<br>    <span class="hljs-type">int</span> HL, HR, MaxH;<br>    <span class="hljs-keyword">if</span>(BT )&#123;<br>        HL = PostOrderGetHeight(BT -&gt; Left);<span class="hljs-comment">/*求左子树的深度*/</span><br>        HR = PostorderGetHeight(BT -&gt; Right);<span class="hljs-comment">/*求右子树的深度*/</span><br>        MaxH=(HL &gt; HR) ? HL : HR;<span class="hljs-comment">/*取左右子树较大的深度*/</span><br>        <span class="hljs-keyword">return</span>(MaxH + <span class="hljs-number">1</span>);<span class="hljs-comment">/*返回树的深度*/</span><br>    &#125;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">/*空树深度为0*/</span><br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：查找的效率与树的高度有关</p></blockquote><h4 id="2-5-3-二元运算表达式树及其遍历"><a href="#2-5-3-二元运算表达式树及其遍历" class="headerlink" title="2.5.3 二元运算表达式树及其遍历"></a>2.5.3 二元运算表达式树及其遍历</h4><p>例：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182657858.png" alt="image-20240922113444039" style="zoom: 33%;" /><p>三种不同的访问结果：</p><blockquote><p>先序：++ a * b c * + * d e f g</p><p>中序：a + b * c + d * e + f * g (中序可能带来符号的问题，解决办法可添加符号进行运算)</p><p>后序：a b c * +  d e * f + g * +</p></blockquote><hr><h4 id="2-5-4-由两种遍历序列确定二叉树"><a href="#2-5-4-由两种遍历序列确定二叉树" class="headerlink" title="2.5.4 由两种遍历序列确定二叉树"></a>2.5.4 由两种遍历序列确定二叉树</h4><p>必须要有两个中序遍历才行。因为必须确定根节点</p><blockquote><p>先序序列：a b c d e f g h i j<br>中序序列：c b e d a h g i j f</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182700842.png" alt="QQ_1726990340381" style="zoom: 33%;" /><h4 id="2-5-5-同构树判断"><a href="#2-5-5-同构树判断" class="headerlink" title="2.5.5 同构树判断"></a>2.5.5 同构树判断</h4><blockquote><p>给定两棵树T1和T2。如果T1可以通过若干次左右孩子互换就变成T2，则我们称两棵树是“同构”的。</p></blockquote><p>输入给出2棵二叉树的信息：</p><ul><li>先在一行中给出该树的结点数，随后N行</li><li>第i行对应编号第i个结点，给出该结点中存储的字母、其左孩子结点的编号、右孩子结点的编号。</li><li>如果孩子结点为空，则在相应位置上给出“-”</li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182705544.png" alt="QQ_1726991131325" style="zoom:25%;" /><p>求解思路：</p><ol><li>二叉树表示</li><li>建二叉树</li><li>同构判别</li></ol><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MaxTree 10</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ElementType char</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Tree int</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> Null -1</span><br><br><span class="hljs-comment">/*定义数据结构*/</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span></span><br><span class="hljs-class">&#123;</span><br>    ElementType Element;<br>    Tree Left;<br>    Tree Right;<br>&#125;T1[MaxTree], T2[MaxTree];<br>  <br><span class="hljs-comment">/*程序框架*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    Tree R1, R2;<br>    R1 = BuildTree(T1);<br>    R2 = BuildTree(T2);<br>    <span class="hljs-keyword">if</span>(Isomorphic(R1, R2)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span><br>&#125;<br><br>Tree BuildTree( <span class="hljs-keyword">struct</span> TreeNode T[] )&#123;<br>    ......<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d\n&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">if</span> (N)&#123;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++) check[i]= <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c %c %c\n&quot;</span>, &amp;T[i].Element, &amp;cl, &amp;cr);<br>            <span class="hljs-keyword">if</span> (cl != <span class="hljs-string">&#x27;-&#x27;</span>)&#123;<br>                T[i].Left = cl-<span class="hljs-string">&#x27;0&#x27;</span>;  <span class="hljs-comment">/*将字符转化为数字*/</span><br>                check[T[i].Left]=<span class="hljs-number">1</span>;<br>            &#125;<br>            <span class="hljs-keyword">else</span> T[i].Left = Null;<br>            ......<span class="hljs-comment">/*对cr的对应处理*/</span><br>        &#125;<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;N; i++)<br>            <span class="hljs-keyword">if</span> (!check[i]) <span class="hljs-keyword">break</span>;<br>        Root =i;<br>    &#125;<br>    <span class="hljs-keyword">return</span> Root;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Isomorphic</span> <span class="hljs-params">( Tree R1, Tree R2 )</span>&#123;<br>    <span class="hljs-keyword">if</span>((R1 == Null) &amp;&amp; (R2 == Null) )<span class="hljs-comment">/* both empty */</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">if</span>(( (R1==Null) &amp;&amp; (R2 != Null) )|| ( (R1!=Null) &amp;&amp; (R2==Null) ))<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<span class="hljs-comment">/* one of them is empty */</span><br>    <span class="hljs-keyword">if</span>(T1[R1].Element != T2[R2].Element)<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>; <span class="hljs-comment">/* roots are different */</span><br>    <span class="hljs-keyword">if</span>((T1[R1].Left ==Null) &amp;&amp; (T2[R2].Left == Null))<br>        <span class="hljs-comment">/* both have no left subtree */</span><br>        <span class="hljs-keyword">return</span> Isomorphic( T1[R1].Right, T2[R2].Right );<br>    <span class="hljs-keyword">if</span>(( (T1[R1].Left!=Nul) &amp;&amp; (T2[R2].Left!=Null)) &amp;&amp; <br>       ((T1[T1[R1].Left].Element) == (T2[T2[R2].Left].Element)))<br>        <span class="hljs-comment">/* no need to swap the left and the right */</span><br>        <span class="hljs-keyword">return</span>(lsomorphic( T1[R1].Left, T2[R2].Left )&amp;&amp;<br>               Isomorphic( T1[R1].Right, T2[R2].Right ));<br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/* need to swap the left and the right */</span><br>        <span class="hljs-keyword">return</span> ( lsomorphic( T1[R1].Left, T2[R2].Right) &amp;&amp;<br>                Isomorphic(T1[R1].Right, T2[R2].Left ));<br>&#125;<br><br></code></pre></td></tr></table></figure><hr><h2 id="3-二叉搜索树"><a href="#3-二叉搜索树" class="headerlink" title="3 二叉搜索树"></a>3 二叉搜索树</h2><p>二叉搜索树(BST，Binary Search Tree)，也称二叉排序树或二叉查找树<br>二叉搜索树：一棵二叉树，可以为空；如果不为空，满足以下性质:</p><blockquote><ol><li>非空左子树的所有键值小于其根结点的键值。</li><li>非空右子树的所有键值大于其根结点的键值。</li><li>左、右子树都是二叉搜索树</li></ol></blockquote><h3 id="3-1-查找操作Find"><a href="#3-1-查找操作Find" class="headerlink" title="3.1 查找操作Find"></a>3.1 查找操作Find</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*查找普通元素*/</span><br>Position <span class="hljs-title function_">Find</span><span class="hljs-params">( ElementType X, BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( !BST ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;<span class="hljs-comment">/*查找失败*/</span><br>    <span class="hljs-keyword">if</span>( X &gt; BST-&gt;Data)<br>        <span class="hljs-keyword">return</span> Find(X, BST -&gt; Right );<span class="hljs-comment">/*在右子树中继续查找*/</span><br>    Else <span class="hljs-title function_">if</span><span class="hljs-params">( X &lt; BST-&gt;Data )</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(X, BST -&gt; Left)</span>;<span class="hljs-comment">/*在左子树中继续查找*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-comment">/*X == BST -&gt; Data */</span><br>        <span class="hljs-keyword">return</span> BST;<span class="hljs-comment">/*查找成功，返回结点的找到结点的地址*/</span><br>&#125;<br><br><span class="hljs-comment">/*查找最大元素*/</span><br>Position <span class="hljs-title function_">FindMin</span><span class="hljs-params">( BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( !BST ) <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>; <span class="hljs-comment">/*空的二叉搜索树，返回NULL*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !BST -&gt; Left )<br>        <span class="hljs-keyword">return</span> BST;   <span class="hljs-comment">/*找到最左叶结点井返回*/</span><br>    <span class="hljs-keyword">else</span><br>        <span class="hljs-keyword">return</span> FindMin(BST -&gt; Left);<span class="hljs-comment">/*沿左分支维续查找</span><br><span class="hljs-comment">&#125;</span><br><span class="hljs-comment"></span><br><span class="hljs-comment">/*查找最小元素*/</span><br>Position <span class="hljs-title function_">FindMax</span><span class="hljs-params">( BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( BST )<br>        <span class="hljs-comment">/*沿右分支继续查找，直到最右叶结点*/</span><br>        <span class="hljs-keyword">while</span>(BST -&gt; Right) BST = BST -&gt; Right;<br>    <span class="hljs-keyword">return</span> BsT;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-2-插入操作Insert"><a href="#3-2-插入操作Insert" class="headerlink" title="3.2 插入操作Insert"></a>3.2 插入操作Insert</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Insert</span><span class="hljs-params">( ElementType X, BinTree BST)</span>&#123;<br>    <span class="hljs-keyword">if</span>( !BST )&#123;<br>        <span class="hljs-comment">/*若原树为空，生成并返回一个结点的二叉搜索树*/</span><br>        BST = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>        BST -&gt; Data = X;<br>        BST -&gt; Left = BST -&gt; Right = <span class="hljs-literal">NULL</span>;<br>    &#125;<span class="hljs-keyword">else</span><br>        <span class="hljs-comment">/*开始找要插入元素的位置*/</span><br>        <span class="hljs-keyword">if</span>(X&lt;BST-&gt;Data )<br>            <span class="hljs-comment">/*递归插入左子树*/</span><br>            BST -&gt; Left = Insert(X, BST -&gt; Left);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(X&gt;BST-&gt;Data)<br>            <span class="hljs-comment">/*递归插入右子树*/</span><br>            BST -&gt; Right = Insert(X, BST -&gt; Right);<br>    <span class="hljs-comment">/*else X已经存在，什么都不做*/</span><br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-3-删除操作"><a href="#3-3-删除操作" class="headerlink" title="3.3 删除操作"></a>3.3 删除操作</h3><p> 要考虑的三种情况：</p><ul><li><strong>要删除的是叶结点</strong>：直接删除，并再修改其父结点指针设置为NULL</li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182711860.png" alt="QQ_1726999640984" style="zoom: 25%;" /><ul><li>要删除的结点只有一个孩子结点：将其父结点的指针指向要删除结点的孩子结点</li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182713950.png" alt="QQ_1726999712814" style="zoom: 33%;" /><ul><li>要删除的结点有<strong>左、右两棵子树</strong>：用另一结点替代被删除结点，即<strong>右子树的最小元素</strong>或<strong>者左子树的最大元素</strong></li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182716394.png" alt="QQ_1726999848223" style="zoom:33%;" /><p>取<strong>右子树中的最小元素</strong>替代：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182718754.png" alt="QQ_1726999898448" style="zoom:33%;" /><p>取<strong>左子树中的最大元素</strong>替代：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182720736.png" alt="QQ_1726999926936" style="zoom:33%;" /><p>程序代码：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs c">BinTree <span class="hljs-title function_">Delete</span><span class="hljs-params">(ElementType X, BinTree BST)</span>&#123;<br>    Position Tmp;<br>    <span class="hljs-keyword">if</span>( !BST ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;要删除的元素未找到&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &lt; BST -&gt; Data )<br>        BST -&gt; Left = Delete( X, BST -&gt; Left );<span class="hljs-comment">/*左子树递归删除*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( X &gt; BST -&gt; Data )<br>        BST -&gt; Right = Delete( X，BS -&gt; Right );<span class="hljs-comment">/*右子树递归删除*/</span><br>    <span class="hljs-keyword">else</span> <br>        <span class="hljs-comment">/*找到要删除的结点*/</span><br>        <span class="hljs-comment">/*被删除结点有左右两个子结点 */</span><br>        <span class="hljs-keyword">if</span>( BST -&gt; Left &amp;&amp; BST -&gt; Right)&#123;<br>            <span class="hljs-comment">/*在右子树中找最小的元素填充删除结点*/</span><br>            Tmp = FindMin(BST -&gt; Right);<br>            BST -&gt; Data = Tmp -&gt; Data;<br>            <span class="hljs-comment">/*在删除结点的右子树中删除最小元素*/</span><br>            BST -&gt; Right = Delete( BST -&gt; Data, BST -&gt; Right);<br>        &#125;<span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">/*被删除结点有一个或无子结点*/</span><br>            Tmp = BST;<br>            <span class="hljs-comment">/*有右孩子或无子结点，下面的语句是左边是空*/</span><br>            <span class="hljs-keyword">if</span>( !BST -&gt; Left)<br>                BST = BST -&gt; Right;<br>            <span class="hljs-comment">/*有左孩子或无子结点*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( !BsT -&gt; Right)<br>                BST = BST -&gt; Left;<br>            <span class="hljs-built_in">free</span>( Tmp );<br>        &#125;<br>    <span class="hljs-keyword">return</span> BST;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-4-判别是否同一搜索树"><a href="#3-4-判别是否同一搜索树" class="headerlink" title="3.4 判别是否同一搜索树"></a>3.4 判别是否同一搜索树</h3><p>求解思路</p><blockquote><ol><li>分别建两棵搜索树的判别方法</li><li>不建树的判别方法</li><li>建一棵树，再判别其他序列是否与该树一致</li></ol></blockquote><p>选择第3种进行设计</p><blockquote><ol><li>搜索树表示</li><li>建搜索树T</li><li>判别一序列是否与搜索树T一致</li></ol></blockquote><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*搜索树表示*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">Tree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> &#123;</span><br>    <span class="hljs-type">int</span> v;<br>    Tree Left, Right;<br>    <span class="hljs-type">int</span> flag;<br>&#125;;<br><br><span class="hljs-comment">/*主函数*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> N, L, i;<br>    Tree T;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;N);<br>    <span class="hljs-keyword">while</span> (N) &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;L);<br>        T = MakeTree(N);<br>        <span class="hljs-keyword">for</span> (i=<span class="hljs-number">0</span>; i&lt;L; i++)&#123;<br>            <span class="hljs-keyword">if</span> (Judge(T, N)) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Yes\n&quot;</span>);<br>            <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>            <span class="hljs-comment">/*清除T中的标记flag*/</span><br>            ResetT(T);<br>        &#125;<br>        FreeTree(T);<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;N);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><span class="hljs-comment">/*如何建搜索树*/</span><br>Tree <span class="hljs-title function_">MakeTree</span><span class="hljs-params">( <span class="hljs-type">int</span> N )</span>&#123;<br>    Tree T;<br>    <span class="hljs-type">int</span> i, V;<br>    <br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>    <span class="hljs-comment">/*申请一个树节点空间函数*/</span><br>    T = NewNode(V);<br>    <span class="hljs-keyword">for</span> (i=<span class="hljs-number">1</span>; i&lt;N; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>,&amp;V);<br>        T =Insert(T, V);<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-comment">/*申请一个树节点空间具体实现*/</span><br>Tree <span class="hljs-title function_">NewNode</span><span class="hljs-params">( <span class="hljs-type">int</span> V )</span>&#123;<br>    TreeT = (Tree)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>    T -&gt; v = V;<br>    T -&gt; Left = T -&gt; Right = <span class="hljs-literal">NULL</span>;<br>    T -&gt; flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br>Tree <span class="hljs-title function_">insert</span><span class="hljs-params">( Tree T, <span class="hljs-type">int</span> V )</span>&#123;<br>    <span class="hljs-keyword">if</span> ( !T ) T = NewNode(V);<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>( V &gt; T -&gt; v )<br>            T-&gt;Right = Insert( T-&gt;Right, V );<br>        <span class="hljs-keyword">else</span><br>            T-&gt;Left = Insert( T-&gt;Left, V );<br>    &#125;<br>    <span class="hljs-keyword">return</span> T;<br>&#125;<br><br><span class="hljs-comment">/*判别搜索树*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">check</span> <span class="hljs-params">( Tree T, <span class="hljs-type">int</span> V )</span>&#123;<br>    <span class="hljs-keyword">if</span> ( T -&gt; flag )&#123;<br>        <span class="hljs-keyword">if</span> ( V &lt; T -&gt; v ) <span class="hljs-keyword">return</span> check( T -&gt; Left, V);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ( V &gt; T -&gt; v ) <span class="hljs-keyword">return</span> check( T -&gt; Right, V);<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>    <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span>( V == T -&gt; v )&#123;<br>            T -&gt; flag =<span class="hljs-number">1</span>;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">Judge</span><span class="hljs-params">( Tree T, <span class="hljs-type">int</span> N )</span>&#123;<br>    <span class="hljs-comment">/*flag:0代表目前还一致，1代表已经不一致*/</span><br>    <span class="hljs-type">int</span> i, V, flag = <span class="hljs-number">0</span>;<br>    <span class="hljs-built_in">scanf</span>( <span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>    <span class="hljs-keyword">if</span>( V != T-&gt;v ) flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">else</span> T -&gt; flag = <span class="hljs-number">1</span>;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">1</span>; i &lt; N; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;V);<br>        <span class="hljs-keyword">if</span> ( (!flag) &amp;&amp; (!check(T, V))) flag = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">if</span> (flag) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-comment">/*清除T中各结点的flag标记*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">ResetT</span><span class="hljs-params">(TreeT)</span>&#123;<br>    <span class="hljs-keyword">if</span> ( T -&gt; Left) ResetT( T -&gt; Left);<br>    <span class="hljs-keyword">if</span> (T -&gt; Right) ResetT( T -&gt; Right);<br>    T -&gt; flag = <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-comment">/*释放T的空间*/</span><br><span class="hljs-type">void</span> <span class="hljs-title function_">FreeTree</span><span class="hljs-params">(TreeT)</span>&#123;<br>    <span class="hljs-keyword">if</span> (T -&gt; Left) FreeTree(T -&gt; Left);<br>    <span class="hljs-keyword">if</span> (T -&gt; Right) FreeTree(T -&gt; Right);<br>    <span class="hljs-built_in">free</span>(T);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-平衡二叉树"><a href="#4-平衡二叉树" class="headerlink" title="4 平衡二叉树"></a>4 平衡二叉树</h2><h3 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h3><blockquote><p><strong>平衡二叉树(Balanced Binary Tree) (AVL树)</strong>：空树，或者任一结点左、右子树高度差的绝对值不超过1，即**|BF(T)|≤1**</p><p><strong>平衡因子(Balance Factor，简称BF)</strong>：BF(T)&#x3D; h˪-hᵣ其中h˪和hᵣ分别为T的左、右子树的高度。</p><p><em><strong>给定结点数为 n 的 AVL 树的最大高度为 O(log₂n)</strong></em></p></blockquote><p>搜索树节点不同的插入次序，将导致不同的深度和平均查找长度ASL</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182725817.png" alt="QQ_1727001784741" style="zoom: 25%;" /><h3 id="4-2-调平"><a href="#4-2-调平" class="headerlink" title="4.2 调平"></a>4.2 调平</h3><blockquote><p>RR旋转</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182727840.png" alt="QQ_1727003471268" style="zoom: 25%;" /><blockquote><p>LL旋转</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182729666.png" alt="QQ_1727003551389" style="zoom: 25%;" /><blockquote><p>LR旋转</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182731560.png" alt="QQ_1727003602596" style="zoom:25%;" /><blockquote><p>RL旋转</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182733530.png" alt="QQ_1727003754869" style="zoom:25%;" /> <hr><h2 id="5-静态查找"><a href="#5-静态查找" class="headerlink" title="5 静态查找"></a>5 静态查找</h2><h3 id="5-1-顺序查找"><a href="#5-1-顺序查找" class="headerlink" title="5.1 顺序查找"></a>5.1 顺序查找</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182735850.png" alt="image-20240921165803220" style="zoom: 25%;" /><h3 id="5-2-二分查找（Binary-Search）"><a href="#5-2-二分查找（Binary-Search）" class="headerlink" title="5.2 二分查找（Binary Search）"></a>5.2 二分查找（Binary Search）</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182738121.png" alt="image-20240921170753507" style="zoom: 25%;" /><p>实现算法</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">BinarySearch</span> <span class="hljs-params">( List Tbl, ElementType K)</span><br>&#123;<span class="hljs-comment">/*在表Tbl中查找关键字为K的数据元素*/</span><br>    <span class="hljs-type">int</span> left, right, mid, NoFound=<span class="hljs-number">-1</span>;<br><br>    left = <span class="hljs-number">1</span>;<span class="hljs-comment">/*初始左边界*/</span><br>    right = Tbl-&gt;Length;<span class="hljs-comment">/*初始右边界*/</span><br>    <span class="hljs-keyword">while</span> ( left &lt;= right )<br>    &#123;<br>        mid =(left+right)/<span class="hljs-number">2</span>;<span class="hljs-comment">/*计算中间元素坐标*/</span><br>        <span class="hljs-keyword">if</span>( K &lt; Tbl-&gt;Element[mid])           right = mid<span class="hljs-number">-1</span>；<span class="hljs-comment">/*调整右边界*/</span><br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>( K &gt;Tbl-&gt;Element[mid])   left = mid+<span class="hljs-number">1</span>;  <span class="hljs-comment">/*调整左边界*/</span><br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> mid;   <span class="hljs-comment">/*查找成功，返回数据元素的下标*/</span><br>    &#125;<br>    <span class="hljs-keyword">return</span> NotFound;<span class="hljs-comment">/*查找不成功，返回-1*/</span><br>&#125;<br></code></pre></td></tr></table></figure><p>生成判断树</p><ul><li><p>判定树上每个结点需要的查找次数刚好为该结点所在的层数;</p></li><li><p>查找成功时查找次数不会超过判定树的深度</p><blockquote><p>n个结点的判定树的深度为[log₂n]+1</p></blockquote></li></ul><hr><h1 id="三、堆"><a href="#三、堆" class="headerlink" title="三、堆"></a>三、堆</h1><h2 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><p>优先队列（Priority Queue）：特殊的“<strong>队列</strong>”，取出元素的顺序是依照元素的优先权（关键字）大小，而不是元素进入队列的先后顺序。</p><p>堆的两个特性：</p><blockquote><ul><li>结构性：用数组表示的完全二叉树；</li><li>有序性：任一结点的关键字是其子树所有结点的最大值(或最小值)<ul><li>最大堆(MaxHeap)，也称“大顶堆“，最大值</li><li>最小堆(MinHeap)，也称“小顶堆”，最小值</li></ul></li></ul></blockquote><h2 id="2-堆的操作"><a href="#2-堆的操作" class="headerlink" title="2 堆的操作"></a>2 堆的操作</h2><blockquote><p>堆的数据结构</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapStruct</span> *<span class="hljs-title">MaxHeap</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">HeapStruct</span> &#123;</span><br>    <span class="hljs-comment">/*存储堆元素的数组*/</span><br>    ElementType *Elements;<br>    <span class="hljs-comment">/*堆的当前元素个数*/</span><br>    <span class="hljs-type">int</span> Size;<br>    <span class="hljs-comment">/*堆的最大容量 */</span><br>    <span class="hljs-type">int</span> Capacity;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-1-堆的创建"><a href="#2-1-堆的创建" class="headerlink" title="2.1 堆的创建"></a>2.1 堆的创建</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c">MaxHeap <span class="hljs-title function_">Create</span><span class="hljs-params">(<span class="hljs-type">int</span> MaxSize)</span>&#123;<br>    <span class="hljs-comment">/*创建容量为MaxSize的空的最大堆*/</span><br>    MaxHeap H = <span class="hljs-built_in">malloc</span>( <span class="hljs-keyword">sizeof</span>( <span class="hljs-keyword">struct</span> Heapstruct ) );<br>    <span class="hljs-comment">/*MaxSize + 1代表我们是从下标为1的元素开始存放，一般下表为0不存放元素*/</span><br>    H -&gt; Elements = <span class="hljs-built_in">malloc</span>((MaxSize + <span class="hljs-number">1</span>) * <span class="hljs-keyword">sizeof</span>(ElementType));<br>    H -&gt; Size = <span class="hljs-number">0</span>;<br>    H -&gt; Capacity = MaxSize;<br>    H -&gt; Elements[<span class="hljs-number">0</span>] = MaxData;<br>    <span class="hljs-comment">/*定义“哨兵”为大于堆中所有可能元素的值，便于以后更快操作*/</span><br>    <span class="hljs-keyword">return</span> H;<br>&#125;<br></code></pre></td></tr></table></figure><p>建立最大堆：将已经存在的N个元素按最大堆的要求存放在个一维数组中</p><ul><li>方法1：通过插入操作，将N个元素一个个相继插入到一个初始为空的堆中去，其时间代价最大为0(N log N)。</li><li>方法2：在线性时间复杂度下建立最大堆。<ul><li>(1)将N个元素按输入顺序存入，先满足完全二叉树的结构特性</li><li>(2)调整各结点位置，以满足最大堆的有序特性</li></ul></li></ul><h3 id="2-2-堆的插入"><a href="#2-2-堆的插入" class="headerlink" title="2.2 堆的插入"></a>2.2 堆的插入</h3><p>将新增结点插入到从其父结点到根结点的有序序列中 ，<strong>时间复杂度：T(N) &#x3D; O(log N)</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insert</span><span class="hljs-params">(MaxHeap H, ElementType item)</span>&#123;<br>    <span class="hljs-comment">/*将元素item 插入最大堆H，其中H-&gt;Elements[0]已经定义为哨兵*/</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">if</span>(IsFu11(H))&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已满&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/*i指向插入后堆中的最后一个元素的位置*/</span><br>    i = ++H -&gt; Size;<br>    <span class="hljs-keyword">for</span>(;H-&gt;Elements[i/<span class="hljs-number">2</span>]&lt;item;i/=<span class="hljs-number">2</span>)<br>        <span class="hljs-comment">/*向下过滤结点 */</span><br>        H -&gt; Elements[i] = H-&gt;Elements[i/<span class="hljs-number">2</span>];<br>    <span class="hljs-comment">/*将item 插入*/</span><br>    H-&gt;Elements[il= item;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-3-堆的删除"><a href="#2-3-堆的删除" class="headerlink" title="2.3 堆的删除"></a>2.3 堆的删除</h3><p>时间复杂度：T(N) &#x3D; O (log N)</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182744065.png" alt="QQ_1727011390447" style="zoom: 33%;" /><p>删除下标最大的元素</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182746146.png" alt="QQ_1727012016153" style="zoom: 33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><br>ElementType <span class="hljs-title function_">DeleteMax</span><span class="hljs-params">( MaxHeap H )</span>&#123;<br>    <span class="hljs-comment">/*从最大堆H中取出键值为最大的元素，并删除一个结点*/</span><br>    <span class="hljs-type">int</span> Parent, Child;<br>    ElementType MaxItem, temp;<br>    <span class="hljs-keyword">if</span>( IsEmpty(H) )&#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;最大堆已为空&quot;</span>);<br>        <span class="hljs-keyword">return</span>;<br>    &#125;<br>    <span class="hljs-comment">/*取出根结点最大值*/</span><br>    MaxItem = H -&gt; Elements[<span class="hljs-number">1</span>];<br>    <span class="hljs-comment">/*用最大堆中最后一个元素从根结点开始向上过滤下层结点*/</span><br>    temp = H -&gt; Elements[ H -&gt; Size--];<br>    <span class="hljs-comment">/* Parent * 2 &lt;= H -&gt; Size判别是否有左儿子*/</span><br>    <span class="hljs-keyword">for</span>( Parent = <span class="hljs-number">1</span>; Parent * <span class="hljs-number">2</span> &lt;= H -&gt; Size; Parent =Child )&#123;<br>        Child = Parent * <span class="hljs-number">2</span>;<br>        <span class="hljs-comment">/*child指向左右子结点的较大者，Child!= H-&gt;Size是否有右儿子*/</span> <br>        <span class="hljs-keyword">if</span>((Child!= H-&gt;Size) &amp;&amp; (H -&gt; Elements[Child] &lt; H -&gt; Elements[Child+<span class="hljs-number">1</span>]))<br>            Child++;<br>        <span class="hljs-keyword">if</span>(temp &gt;= H -&gt; Elements[Child]) <span class="hljs-keyword">break</span>;<br>        <span class="hljs-comment">/*移动temp元素到下一层*/</span><br>        <span class="hljs-keyword">else</span><br>            H -&gt; Elements[Parent] = H-&gt;Elements[Child];<br>    &#125;<br>    H -&gt; Elements[Parent] = temp;<br>    <span class="hljs-keyword">return</span> MaxItem;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="3-哈夫曼树与哈夫曼编码"><a href="#3-哈夫曼树与哈夫曼编码" class="headerlink" title="3 哈夫曼树与哈夫曼编码"></a>3 哈夫曼树与哈夫曼编码</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><p><strong>定义：</strong></p><blockquote><p>带权路径长度(WPL)：设二叉树有n个叶子结点，每个叶子结点带有权值Wₖ，从根结点到每个叶子结点的长度为Iₖ ，则每个叶子结点的带权路径长度之和就是：</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182748730.png" alt="QQ_1727057924307" style="zoom:33%;" /><blockquote><p>最优二叉树或哈夫曼树：WPL最小的二叉树</p><p>时间复杂度：O(N log N)</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span> *<span class="hljs-title">HuffmanTree</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">TreeNode</span>&#123;</span><br>    <span class="hljs-type">int</span> weight;<br>    HuffmanTree Left, Right;<br>&#125;<br>HuffmanTree <span class="hljs-title function_">Huffman</span><span class="hljs-params">( MinHeap H)</span>&#123;<br>    <span class="hljs-comment">/*假设H-&gt;size个权值已经存在H-&gt;Elements[]-&gt;weight里*/</span><br>    <span class="hljs-type">int</span> i;<br>    HuffmanTree T;<br>    <span class="hljs-comment">/*将H-&gt;Elements[]按权值调整为最小堆*/</span><br>    BuildMinHeap(H);<br>    <span class="hljs-comment">/*做H-&gt;Size-1次合并*/</span><br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">1</span>; i &lt; H -&gt; Size; i++)&#123;<br>        <span class="hljs-comment">/*建立新结点*/</span><br>        T = <span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> TreeNode));<br>        <span class="hljs-comment">/*从最小堆中删除一个结点，作为新的左子结点*/</span><br>        T -&gt; Left = DeleteMin(H);<br>        <span class="hljs-comment">/*从最小堆中删除一个结点，作为新的右子结点*/</span><br>        T -&gt; Right = DeleteMin(H);<br>        <span class="hljs-comment">/*计算新权值*/</span><br>        T -&gt; Weight = T -&gt; Left -&gt; Weight + T -&gt; Right -&gt; Weight;<br>        <span class="hljs-comment">/*将新T插入最小堆*/</span><br>        Insert(H, T);<br>    &#125;<br>        T = DeleteMin(H);<br>        <span class="hljs-keyword">return</span> T;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>特点：</strong></p><blockquote><p>没有度为1的结点；<br>n个叶子结点的哈夫曼树共有2n-1个结点；<br>哈夫曼树的任意非叶节点的左右子树交换后仍是哈夫曼树；</p></blockquote><p>权值WPL相同，但是构造出来的树不同：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182751506.png" alt="QQ_1727058807533" style="zoom:33%;" /><p><strong>用途：<strong>它可以用来</strong>生成文本的索引、单词频率统计和特征向量表示</strong>等任务。 哈夫曼编码在各种需要对数据进行高效压缩和编码表示的应用中具有重要作用，能够显著减小数据的大小，提高数据传输和存储的效率。</p><p>例子：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182753677.png" alt="QQ_1727059775006" style="zoom:25%;" /><h2 id="4-集合运算"><a href="#4-集合运算" class="headerlink" title="4 集合运算"></a>4 集合运算</h2><blockquote><p>集合运算：交、并、补、差，判定一个元素是否属于某一集合</p></blockquote><p>例子：</p><p>​有10台电脑{1，2，3，…，9，10}，已知下列电脑之间已经实现了连接：1和2、2和4、3和5、4和7、5和8、6和9、6和10</p><p>问：</p><p>​2和7之间，5和9之间是否是连通的?</p><p>解决思路</p><ul><li>(1)将10台电脑看成10个集合{1}，{2}，{3}，…，{9}，{10}；</li><li>(2)已知一种连接“x和y”，就将x和y对应的集合合并;</li><li>(3)查询“x和y是否是连通的”就是判别x和y是否属于同集合。</li></ul><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182756271.png" alt="QQ_1727060754223" style="zoom:25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182758620.png" alt="QQ_1727060773106" style="zoom: 33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*数据结构构造*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> &#123;</span><br>    ElementType Data;<br>    <span class="hljs-type">int</span> Parent;<br>&#125;SetType;<br></code></pre></td></tr></table></figure><h3 id="4-1-集合查找"><a href="#4-1-集合查找" class="headerlink" title="4.1 集合查找"></a>4.1 集合查找</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*查找某个元素所在的集合*/</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">Find</span><span class="hljs-params">(SetType S[], ElementType X)</span>&#123;<br>    <span class="hljs-comment">/*在数组s中查找值为x的元素所属的集合*/</span><br>    <span class="hljs-comment">/*Maxsize是全局变量，为数组S的最大长度*/</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span>( i = <span class="hljs-number">0</span>; i &lt; MaxSize &amp;&amp; S[i].Data != X; i++);<br>    <span class="hljs-comment">/* 未找到X，返回-1 */</span><br>    <span class="hljs-keyword">if</span>( i &gt;= MaxSize ) <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    <span class="hljs-keyword">for</span>( ; S[il.Parent &gt;= <span class="hljs-number">0</span>; i = S[i].Parent);<br>    <span class="hljs-comment">/*找到x所属集合，返回树根结点在数组s中的下标*/</span><br>    <span class="hljs-keyword">return</span> i;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-集合的并运算"><a href="#4-2-集合的并运算" class="headerlink" title="4.2 集合的并运算"></a>4.2 集合的并运算</h3><blockquote><p>分别找到X1和X2两个元素所在集合树的根结点;</p><p>如果它们不同根，则将其中一个根结点的父结点指针设置成另一个根结点的数组下标。</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType s[ ], ElementType X1, ElementType X2)</span>&#123;<br>    <span class="hljs-type">int</span> Rootl,Root2;<br>    Root1 = Find(s, X1);<br>    Root2 = Find(s, x2);<br>    <span class="hljs-keyword">if</span>(Root1 != Root2 ) S[Root2].Parent = Root1;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182801626.png" alt="QQ_1727061814019" style="zoom: 25%;" /><blockquote><p>简化：</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">/*默认元素可以用非负整数表示*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Elementrype;<br><span class="hljs-comment">/*默认用根结点的下标作为集合名称*/</span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> setName;<br><span class="hljs-keyword">typedef</span> ElementType SetType[Maxsize];<br><br>SetName <span class="hljs-title function_">Find</span><span class="hljs-params">(SetType S, ElementType X )</span><br>&#123;<br>    <span class="hljs-comment">/*默认集合元素全部初始化为-1*/</span><br>    <span class="hljs-keyword">for</span>( ; S[X] &gt;= <span class="hljs-number">0</span>; X = S[X]);<br>    <span class="hljs-keyword">return</span> X;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType S, SetName Root1,SetName Root2 )</span>&#123;<br>    <span class="hljs-comment">/*这里默认Root1和Root2是不同集合的根结点 */</span><br>    S[Root2]= Root1;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5-堆中的路径"><a href="#5-堆中的路径" class="headerlink" title="5 堆中的路径"></a>5 堆中的路径</h2><h3 id="5-1-程序设计题"><a href="#5-1-程序设计题" class="headerlink" title="5.1 程序设计题"></a>5.1 程序设计题</h3><p>将一系列给定数字插入一个初始为空的小顶堆H。随后对任意给定的下标“ i ”，打印从H[i]到根结点的路径。</p><blockquote><p>输入样例:</p><p>5 3</p><p>46 23 26 24 10</p><p>5 4 3</p><p>输出样例:</p><p>24 23 10</p><p>46 23 10</p><p>26 10</p></blockquote><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182804572.png" alt="QQ_1727062119957" style="zoom:33%;" /><p>程序设计：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> MAXN 1001</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> MINH -10001</span><br><br><span class="hljs-type">int</span> H[MAXN], size;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Create</span><span class="hljs-params">()</span>&#123;<br>    size = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*设置“岗哨”*/</span><br>    H[<span class="hljs-number">0</span>] = MINH;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">insert</span><span class="hljs-params">(<span class="hljs-type">int</span> X)</span>&#123;<br>    <span class="hljs-comment">/*将X插入H。这里省略检查堆是否已满的代码*/</span><br>    <span class="hljs-type">int</span> i;<br>    <span class="hljs-keyword">for</span> (i = ++size; H[i/<span class="hljs-number">2</span>] &gt; X; i /= <span class="hljs-number">2</span>)<br>        H[i] = H[i/<span class="hljs-number">2</span>];<br>    H[i] = X;<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">int</span> n, m, x, i, j;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d&quot;</span>, &amp;n, &amp;m);<br>    <span class="hljs-comment">/*堆初始化*/</span><br>    Create();<br>    <span class="hljs-comment">/*以逐个插入方式建堆*/</span><br>    <span class="hljs-keyword">for</span> ( i = <span class="hljs-number">0</span>; i &lt; n; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;x);<br>        Insert(x);<br>    &#125;<br>    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;j);<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d&quot;</span>,H[j]);<br>        <span class="hljs-keyword">while</span> ( j &gt; <span class="hljs-number">1</span>)&#123; <br>            <span class="hljs-comment">/*沿根方向输出各结点*/</span><br>            j /= <span class="hljs-number">2</span>;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot; %d&quot;</span>, H[j]);<br>        &#125;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>例：判断系统是否连通</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182806784.png" alt="QQ_1727071326730" style="zoom:33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123; <br>    SetType S;<br>    <span class="hljs-type">int</span> n;<br>    <span class="hljs-type">char</span> in;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;d\n&quot;</span>, &amp;n);<br>    Initialization(S, n);<br>    <span class="hljs-keyword">do</span> &#123;<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;in);<br>        <span class="hljs-keyword">switch</span>(in)&#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;I&#x27;</span>: Input <span class="hljs-title function_">connection</span><span class="hljs-params">(S)</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;c&#x27;</span>: Check <span class="hljs-title function_">connection</span><span class="hljs-params">(S)</span>; <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&#x27;S&#x27;</span>: Check <span class="hljs-title function_">network</span><span class="hljs-params">(S, n)</span>; <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125; <span class="hljs-keyword">while</span>(in != <span class="hljs-string">&#x27;S&#x27;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Input_connection</span><span class="hljs-params">( SetType S)</span>&#123;<br>    ElementType u, v;<br>    SetName Root1, Root2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, &amp;u, &amp;v);<br>    Root1 =Find(S，u<span class="hljs-number">-1</span>);<br>    Root2 =Find(S，v<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(Rootl != Root2 )<br>        Union(S，Root1，Root2);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Check_connection</span><span class="hljs-params">( SetType S)</span>&#123;<br>    ElementType u, v;<br>    SetName Root1, Root2;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, &amp;u, &amp;v);<br>    Root1 =Find(S，u<span class="hljs-number">-1</span>);<br>    Root2 =Find(S，v<span class="hljs-number">-1</span>);<br>    <span class="hljs-keyword">if</span>(Rootl == Root2 )<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;yes\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;No\n&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-2-按秩归并（优化Union）"><a href="#5-2-按秩归并（优化Union）" class="headerlink" title="5.2 按秩归并（优化Union）"></a>5.2 按秩归并（优化Union）</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182809719.png" alt="QQ_1727073444387" style="zoom: 25%;" /><blockquote><p>另一种做法：比规模，即把小树贴到大树上。S[Root]&#x3D; -元素个数；</p></blockquote><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Union</span><span class="hljs-params">( SetType S, SetName Root1, SetName Root2)</span>&#123;<br>    <span class="hljs-keyword">if</span>(S[Root2] &lt; S[Root1])&#123;<br>        S[Root2] += S[Root1];<br>        S[Root1] = Root2;<br>    &#125;<br>    <span class="hljs-keyword">else</span>&#123;<br>        S[Root1] += S[Root2];<br>        S[Root2] = Root1; <br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="5-3-路径压缩（优化Find）"><a href="#5-3-路径压缩（优化Find）" class="headerlink" title="5.3 路径压缩（优化Find）"></a>5.3 路径压缩（优化Find）</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">SetName <span class="hljs-title function_">Find</span><span class="hljs-params">( SetType S, ElementType X)</span>&#123;<br>    <span class="hljs-comment">/*找到集合的根 */</span><br>    <span class="hljs-keyword">if</span> ( S[X]&lt;<span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> X;<br>    <span class="hljs-comment">/*先找到根；把根变成x的父结点；再返回根*/</span><br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">return</span> S[X]=Find(S，S[X]);<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="四、图"><a href="#四、图" class="headerlink" title="四、图"></a>四、图</h1><h2 id="1-基本概念-2"><a href="#1-基本概念-2" class="headerlink" title="1 基本概念"></a>1 基本概念</h2><h3 id="1-1-抽象数据类型"><a href="#1-1-抽象数据类型" class="headerlink" title="1.1 抽象数据类型"></a>1.1 抽象数据类型</h3><p>类型名称：图（Graph）</p><p>数据对象集：G(V, E)由一个非空的有限顶点集合V和一个有限边集合E组成。</p><p>特点：</p><blockquote><ul><li>表示“多对多”的关系</li><li>包含<ul><li>一组顶点：通常用V(Vertex)表示顶点集合</li><li>一组边：通常用E(Edge)表示边的集合<ul><li>边是顶点对：(v,w)∈E，其中v,w∈V  <img src="E:\Markdown\img\QQ_1727076050087.png" alt="QQ_1727076050087" style="zoom:25%;" /></li><li>有向边&lt; v, w &gt;表示从v指向w的边（单行线）<img src="E:\Markdown\img\QQ_1727076062498.png" alt="QQ_1727076062498" style="zoom:25%;" /></li><li>不考虑重边和自回路</li></ul></li></ul></li></ul></blockquote><h3 id="1-2-邻接矩阵"><a href="#1-2-邻接矩阵" class="headerlink" title="1.2 邻接矩阵"></a><font color="red">1.2 邻接矩阵</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs c">优点<br>- 直观、简单、好理解<br>- 方便检查任意一对顶点间是否存在边<br>- 方便找任一顶点的所有<span class="hljs-string">&quot;邻接点&quot;</span>(有边直接相连的顶点)<br>- 方便计算任一顶点的<span class="hljs-string">&quot;度&quot;</span>(从该点发出的边数为<span class="hljs-string">&quot;出度&quot;</span>指向该点的边数为“入度”)<br>无向图:对应行(或列)非<span class="hljs-number">0</span>元素的个数<br>有向图:对应行非<span class="hljs-number">0</span>元素的个数是“出度”;对应列非<span class="hljs-number">0</span>元素的个数是<span class="hljs-string">&quot;入度&quot;</span><br><br>缺点：<br>- 浪费空间、浪费时间<br></code></pre></td></tr></table></figure><h3 id="1-3-邻接表"><a href="#1-3-邻接表" class="headerlink" title="1.3 邻接表"></a><font color='red'>1.3 邻接表</font></h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c">- 方便找任一顶点的所有“邻接点”<br>- 节约稀疏图的空间：需要N个头指针+<span class="hljs-number">2</span>E个结点(每个结点至少<span class="hljs-number">2</span>个域)<br>- 方便计算任一顶点的“度”？<br>对无向图:是的<br>对有向图:只能计算“出度”;需要构造“逆邻接表”(存指向自己的边)来方便计算“入度”<br>- 不方便检查任意一对顶点间是否存在边<br></code></pre></td></tr></table></figure><h2 id="2-图的遍历"><a href="#2-图的遍历" class="headerlink" title="2 图的遍历"></a>2 图的遍历</h2><h3 id="2-1-深度优先搜索"><a href="#2-1-深度优先搜索" class="headerlink" title="2.1 深度优先搜索"></a>2.1 深度优先搜索</h3><p>DFS:Depth First Search</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">DFS</span><span class="hljs-params">(Vertexy)</span>&#123;<br>    visited[V]= <span class="hljs-literal">true</span>;<br>    <span class="hljs-keyword">for</span>( V的每个邻接点W )<br>        <span class="hljs-keyword">if</span>( !visited[w] )<br>            DES( W ); <br>&#125;<br></code></pre></td></tr></table></figure><p>若有N个顶点、E条边，时间复杂度是</p><ul><li><p>用邻接表存储图，有O(N+E);</p></li><li><p>用邻接矩阵存储图，有O(N²);</p></li></ul><hr><h3 id="2-2-广度优先搜索"><a href="#2-2-广度优先搜索" class="headerlink" title="2.2 广度优先搜索"></a>2.2 广度优先搜索</h3><p>BFS: Breadth First Search</p><p>伪码描述</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">BFs</span><span class="hljs-params">(VertexV)</span>&#123;<br>    visited[V]= <span class="hljs-literal">true</span>;<br>    Enqueue(V, Q);<br>    <span class="hljs-keyword">while</span>(!IsEmpty(Q))&#123;<br>        V = Dequeue(Q);<br>        <span class="hljs-keyword">for</span>(V的每个邻接点W)<br>            <span class="hljs-keyword">if</span>(!visited[w])&#123;<br>                visited[w]= <span class="hljs-literal">true</span>;<br>                Enqueue(W，Q);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>若有N个顶点、E条边，时间复杂度是</p><ul><li><p>用邻接表存储图，有O(N+E);</p></li><li><p>用邻接矩阵存储图，有O(N²);</p></li></ul><hr><h2 id="3-图的表示"><a href="#3-图的表示" class="headerlink" title="3 图的表示"></a>3 图的表示</h2><h3 id="3-1-邻接矩阵表示"><a href="#3-1-邻接矩阵表示" class="headerlink" title="3.1 邻接矩阵表示"></a>3.1 邻接矩阵表示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-type">int</span> Nv;<span class="hljs-comment">/*顶点数*/</span><br>    <span class="hljs-type">int</span> Ne;<span class="hljs-comment">/*边数 */</span><br>    WeightType G[MaxVertexNum][MaxVertexNum];<br>    DataType Data[MaxVertexNum];<span class="hljs-comment">/*存顶点的数据*/</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToGNode MGraph;<span class="hljs-comment">/*以邻接矩阵存储的图类型*/</span><br></code></pre></td></tr></table></figure><p>初始化一个有VertexNum个顶点但没有边图</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;<span class="hljs-comment">/*用顶点下标表示顶点,为整型*/</span><br>MGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> VertexNum)</span>&#123;<br>    Vertex V, W;<br>    MGraph Graph;<br>    <br>    Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/*注意:这里默认顶点编号从0开始，到(Graph-&gt;Nv-1)*/</span><br>    <span class="hljs-keyword">for</span>(V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)<br>        <span class="hljs-keyword">for</span>(W=<span class="hljs-number">0</span>; W&lt;Graph-&gt;Nv; W++)<br>            Graph-&gt;G[V][W] = <span class="hljs-number">0</span>;<span class="hljs-comment">/*或INFINITY */</span><br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></td></tr></table></figure><p>向MGraph中插入边</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span> *<span class="hljs-title">PtrToENode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ENode</span>&#123;</span><br>    Vertex V1，V2;       <span class="hljs-comment">/*有向边&lt;V1，V2&gt; */</span><br>    WeightType Weight;   <span class="hljs-comment">/*权重*/</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToENode Edge;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">(MGraph Graph, Edge E)</span>&#123;<br>    <span class="hljs-comment">/*插入边 &lt;V1，V2&gt;*/</span><br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;<br>    <span class="hljs-comment">/*若是无向图，还要插入边&lt;V2，V1&gt;*/</span><br>    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;<br>&#125;<br></code></pre></td></tr></table></figure><p>完整建立MGraph</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs c">MGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span>&#123;<br>    MGraph Graph;<br>    Edge E;<br>    Vertex V;<br>    <span class="hljs-type">int</span> Nv, i;<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;d&quot;</span>, &amp;Nv);<br>    Graph = CreateGraph(Nv);<br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;d&quot;</span>, &amp;(Graph-&gt;Ne));<br>    <span class="hljs-keyword">if</span>( Graph-&gt;Ne != <span class="hljs-number">0</span>)&#123;<br>        E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode));<br>        <span class="hljs-keyword">for</span>(i=<span class="hljs-number">0</span>; i&lt;Graph-&gt;Ne; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, <br>                  &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);<br>            InsertEdge(Graph，E);<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*如果顶点有数据的话，读入数据*/</span><br>    <span class="hljs-keyword">for</span>(V=<span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;&amp;c&quot;</span>，&amp;(Graph-&gt;Data[V]));<br>    <br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-2-邻接表表示"><a href="#3-2-邻接表表示" class="headerlink" title="3.2 邻接表表示"></a>3.2 邻接表表示</h3><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span> *<span class="hljs-title">PtrToGNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">GNode</span>&#123;</span><br>    <span class="hljs-type">int</span> Nv;   <span class="hljs-comment">/*顶点数*/</span><br>    <span class="hljs-type">int</span> Ne;   <span class="hljs-comment">/*边数 */</span><br>    ADjList G; <span class="hljs-comment">/*邻接表*/</span><br>&#125;;<br><span class="hljs-keyword">typedef</span> PtrToGNode LGraph;<span class="hljs-comment">/*以邻接矩阵存储的图类型*/</span><br><br><span class="hljs-keyword">typedef</span> struat Vnode &#123;<br>    PtrToAdjVNode FirstEdge;<br>    DataType Data;<span class="hljs-comment">/*存顶点的数据*/</span><br>&#125;AdjList[MaxVertexNum];<span class="hljs-comment">/*AdjList是邻接表类型 */</span><br>    <br><span class="hljs-keyword">typedef</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span> *<span class="hljs-title">PtrToAdjVNode</span>;</span><br><span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">AdjVNode</span>&#123;</span><br>    Vertex AdjV;<span class="hljs-comment">/*邻接点下标*/</span><br>    WeightType Weight;<span class="hljs-comment">/*边权重*/</span><br>    PtrToAdjVNode Next;<br>&#125;;<br></code></pre></td></tr></table></figure><p>LGraph初始化：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Vertex;<span class="hljs-comment">/* 用顶点下标表示顶点,为整型 */</span><br>LGraph <span class="hljs-title function_">CreateGraph</span><span class="hljs-params">(<span class="hljs-type">int</span> VertexNum)</span>&#123;<br>    Vertex V，W;<br>    LGraph Graph;<br>    <br>    Graph = (Graph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(structGNode));<br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br>    <br>    <span class="hljs-comment">/*注意:这里默认顶点编号从0开始，到(Graph-&gt;Nv - 1)*/</span><br>    <span class="hljs-keyword">for</span>(V=<span class="hljs-number">0</span>:V&lt;Graph-&gt;Nv;V++)<br>        Graph-&gt;G[V].FirstEdge =<span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br></code></pre></td></tr></table></figure><p>LGraph插入边：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">(LGraph Graph，EdgeE)</span>&#123;<br>    PtrToAdjVNode NewNode;<br>    <br>    <span class="hljs-comment">/*************&lt;V1,V2&gt; ***************/</span><br>    <span class="hljs-comment">/*为V2建立新的邻接点 */</span><br>    NewNode =(PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V2;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">/*将v2插入V1的表头*/</span><br>    NewNode-&gt;Next = Graph-&gt;G[E-&gt;V1].FirstEdge;<br>    Graph-&gt;G[E-&gt;V1].FirstEdge = NewNode;<br>    <br>    <span class="hljs-comment">/********** 若是无向图，还要插入边 &lt;V2,V1&gt; **********/</span><br>    <span class="hljs-comment">/*为V1建立新的邻接点*/</span><br>    NewNode = (PtrToAdjVNode)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> AdjVNode));<br>    NewNode-&gt;AdjV = E-&gt;V1;<br>    NewNode-&gt;Weight = E-&gt;Weight;<br>    <span class="hljs-comment">/*将V1插入V2的表头*/</span><br>    NewNode-&gt;Next= Graph-&gt;G[E-&gt;V2].FirstEdge;<br>    Graph-&gt;G[E-&gt;V2].FirstEdge = NewNode;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-图的最短路径"><a href="#4-图的最短路径" class="headerlink" title="4 图的最短路径"></a>4 图的最短路径</h2><h3 id="4-1-单源最短路径"><a href="#4-1-单源最短路径" class="headerlink" title="4.1 单源最短路径"></a>4.1 单源最短路径</h3><p> 无权单源最短</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Unweighted</span><span class="hljs-params">(Vertex S)</span><br>&#123;<br>    Enqueue(S, Q);<br>    <span class="hljs-keyword">while</span>( !IsEmpty(Q) )&#123;<br>        V = Dequeue(Q);<br>        <span class="hljs-keyword">for</span>( V的每个邻接点W )<br>            <span class="hljs-keyword">if</span>( dist[w]==<span class="hljs-number">-1</span> )&#123;<br>                dist[w] = dist[V]+<span class="hljs-number">1</span>;<br>                path[w] = V;<br>                Enqueue(W, Q);<br>            &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>有无权单源最短</p><h4 id="4-1-1-Dijkstra算法"><a href="#4-1-1-Dijkstra算法" class="headerlink" title="4.1.1 Dijkstra算法"></a>4.1.1 Dijkstra算法</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182820828.png" alt="QQ_1728121505274" style="zoom: 33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182822636.png" alt="QQ_1728121555895" style="zoom:33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182825015.png" alt="QQ_1728121581571" style="zoom:33%;" /><p>其他类似问题</p><ul><li><p>要求数最短路径有多少条</p><ul><li>count[s]&#x3D;1;</li><li>如果找到更短路：count[w] &#x3D; count[V];</li><li>如果找到等长路：count[w] +&#x3D; count[V];</li></ul></li><li><p>要求边数最少的最短路</p><ul><li>count[s]&#x3D;0</li><li>如果找到更短路：count[w] &#x3D; count[V] + 1;</li><li>如果找到等长路：count[w] &#x3D; count[V] + 1;</li></ul></li></ul><h4 id="练习-旅游问题"><a href="#练习-旅游问题" class="headerlink" title="练习 旅游问题"></a>练习 旅游问题</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182828346.png" alt="QQ_1728223116469" style="zoom:33%;" /><p>核心算法：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Dijkstra</span><span class="hljs-params">(Vertex s)</span>&#123;<br>    <span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>        V = 未收录顶点中dist最小者;<br>        <span class="hljs-keyword">if</span>(这样的V不存在)<br>            <span class="hljs-keyword">break</span>;<br>        collected[V] = <span class="hljs-literal">true</span>;<br>        <span class="hljs-keyword">for</span>(V 的每个邻接点 W)<br>            <span class="hljs-keyword">if</span>(collected[W] == <span class="hljs-literal">false</span> )<br>                <span class="hljs-keyword">if</span>(dist[V] + E&lt;v,w&gt; &lt; dist[W])&#123;<br>                    dist[W] = dist[V] + E&lt;v,w&gt;;<br>                    path[W] = V;<br>                    cost[W] = cost[V] + C&lt;v,w&gt;;<br>                &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>((dist[V] + E&lt;v,w&gt; == dist[W])&amp;&amp;(cost[V] + C&lt;v,w&gt; &lt;cost[W]))&#123;<br>            cost[W] = cost[V] + C&lt;v,w&gt;;<br>            path[W] = V;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-2-多源最短路径"><a href="#4-2-多源最短路径" class="headerlink" title="4.2 多源最短路径"></a>4.2 多源最短路径</h3><p>Floyd算法(时间复杂度V³)：</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182831733.png" alt="QQ_1728121877358" style="zoom:33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Floyd</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)&#123;<br>            D[i][j] = G[i][j];<br>        &#125;<br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; N; k++)<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>                <span class="hljs-keyword">if</span>(D[i][k] + D[k][j] &lt; D[i][j])&#123;<br>                    D[i][j] = D[i][k]+ D[k][j];<br>                    path[i][j] = k;<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-3-练习"><a href="#4-3-练习" class="headerlink" title="4.3 练习"></a>4.3 练习</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182835323.png" alt="QQ_1728126972840" style="zoom:33%;" /><p>程序设计：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">FindAnimal</span><span class="hljs-params">(MGraph Graph)</span>&#123;<br>    WeightType D[MaxVertexNum][MaxVertexNum], MaxDist, MinDist;<br>    Vertex Animal, i;<br>    Floyd( Graph, D);<br>    MinDist = INFINITY;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i&lt; Graph-&gt;Nv; i++)&#123;<br>        MaxDist = FindMaxDist(D, i, Graph-&gt;Nv);<br>        <span class="hljs-comment">/*说明有从i无法变出的动物 */</span><br>        <span class="hljs-keyword">if</span>(MaxDist == INFINITY)&#123;<br>            <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;0\n&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">/*找到最长距离更小的动物 */</span><br>        <span class="hljs-keyword">if</span>(MinDist &gt; MaxDist)&#123;<br>            <span class="hljs-comment">/*更新距离，记录编号 */</span><br>            MinDist = MaxDist;<br>            Animal=i+<span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%d %d\n&quot;</span>, Animal, MinDist);<br>&#125;<br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    MGraph G = BuildGraph();<br>    FindAnimal(G);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>WeightType <span class="hljs-title function_">FindMaxDist</span><span class="hljs-params">( WeightType D[][MaxVertexNum], Vertex i, <span class="hljs-type">int</span> N)</span>&#123;<br>    WeightType MaxDist;<br>    Vertex j;<br>    <br>    MaxDist = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*找出i到其他动物j的最长距离 */</span><br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>        <span class="hljs-keyword">if</span>(i != j &amp;&amp; D[i][j] &gt; MaxDist )<br>            MaxDist = D[i][j];<br>    <span class="hljs-keyword">return</span> MaxDist<br>&#125;<br><br>MGraph CreateGraph(<span class="hljs-type">int</span> VertexNum)&#123;<br>    <span class="hljs-comment">/*初始化一个有vertexNu个顶点但没有边的图 */</span><br>    Vertex V, W;<br>    MGraph Graph;<br>    Graph = (MGraph)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> GNode));<span class="hljs-comment">/*建立图*/</span><br>    Graph-&gt;Nv = VertexNum;<br>    Graph-&gt;Ne = <span class="hljs-number">0</span>;<br>    <span class="hljs-comment">/*初始化邻接矩阵 */</span><br>    <span class="hljs-comment">/*注意:这里默认顶点编号从0开始，到(Graph-&gt;Nv-1)*/</span><br>    <span class="hljs-keyword">for</span>(V = <span class="hljs-number">0</span>; V &lt; Graph-&gt;Nv; V++)<br>        <span class="hljs-keyword">for</span>(W = <span class="hljs-number">0</span>; W &lt; Graph-&gt;Nv; W++)<br>            Graph-&gt;G[V][W] = INFINITY;<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">InsertEdge</span><span class="hljs-params">( MGraph Graph, Edge E)</span>&#123;<br>    <span class="hljs-comment">/*插入边 &lt;v1，y2&gt;*/</span><br>    Graph-&gt;G[E-&gt;V1][E-&gt;V2] = E-&gt;Weight;<br>    <span class="hljs-comment">/*若是无向图，还要插入边&lt;V2，Vl&gt; */</span><br>    Graph-&gt;G[E-&gt;V2][E-&gt;V1] = E-&gt;Weight;<br>&#125;<br><br>MGraph <span class="hljs-title function_">BuildGraph</span><span class="hljs-params">()</span>&#123;<br>    MGraph Graph;<br>    Edge E;<br>    Vertex V;<br>    <span class="hljs-type">int</span> Nv, i;<br>    <span class="hljs-comment">/*读入顶点个数 */</span><br>    <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d&quot;</span>, &amp;Nv);<br>    <span class="hljs-comment">/*初始化有v个顶点但没有边的图*/</span><br>    Graph=createGraph(Nv);<br>    <br>    <span class="hljs-comment">/*读入边数 */</span><br>    scan£(<span class="hljs-string">&quot;名d&quot;</span>, &amp;(Graph-&gt;Ne));<br>    <span class="hljs-keyword">if</span>(Graph-&gt;Ne != <span class="hljs-number">0</span>)&#123;<br>        <span class="hljs-comment">/*如果有边 */</span><br>        E = (Edge)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-keyword">struct</span> ENode)):<span class="hljs-comment">/*建立边结点*</span><br><span class="hljs-comment">        /*读入边，格式为&quot;起点 终点 权重&quot;，插入邻接矩阵 */</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; Graph-&gt;Ne; i++)&#123;<br>            <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%d %d %d&quot;</span>, &amp;E-&gt;V1, &amp;E-&gt;V2, &amp;E-&gt;Weight);<br>            <span class="hljs-comment">/*注意:如果权重不是整型，weight的读入格式要改*/</span><br>            InsertEdge(Graph,E);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">/*如果顶点有数据的话，读入数据*/</span><br>    <span class="hljs-keyword">for</span>(V = <span class="hljs-number">0</span>; V&lt;Graph-&gt;Nv; V++)<br>        <span class="hljs-built_in">scanf</span>(<span class="hljs-string">&quot;%c&quot;</span>, &amp;(Graph-&gt;Data[V]));<br>    <span class="hljs-keyword">return</span> Graph;<br>&#125;<br><br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Floyd</span><span class="hljs-params">(MGraph Graph, WeightTypr D[][MaxVertexNum])</span>&#123;<br>    Vertex i, j, k;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>        <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)&#123;<br>            D[i][j] = G[i][j];<br>        &#125;<br>    <br>    <span class="hljs-keyword">for</span>(k = <span class="hljs-number">0</span>; k &lt; N; k++)<br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; N; i++)<br>            <span class="hljs-keyword">for</span>(j = <span class="hljs-number">0</span>; j &lt; N; j++)<br>                <span class="hljs-keyword">if</span>(D[i][k] + D[k][j] &lt; D[i][j])&#123;<br>                    D[i][j] = D[i][k]+ D[k][j];<br>                    <span class="hljs-keyword">if</span>( i == j &amp;&amp; D[i][j] &lt; <span class="hljs-number">0</span>)<br>                        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>                &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="五-相应算法"><a href="#五-相应算法" class="headerlink" title="五 相应算法"></a>五 相应算法</h1><h2 id="1-贪心算法"><a href="#1-贪心算法" class="headerlink" title="1 贪心算法"></a>1 贪心算法</h2><p>概念：每一步都要权重最小的边</p><p>约束：</p><ul><li>只能用图里面有的边</li><li>只能正好用掉n-1条边</li><li>不能有回路</li></ul><h3 id="1-1-Prim算法（稠密图）"><a href="#1-1-Prim算法（稠密图）" class="headerlink" title="1.1 Prim算法（稠密图）"></a>1.1 Prim算法（稠密图）</h3><p>最小生成树——让一棵小树长大：</p><ul><li>一棵树<ul><li>无回路</li><li>n个顶点一定要有n-1条边</li></ul></li><li>是生成树<ul><li>包含全部顶点</li><li>n-1条边都在图里</li></ul></li><li>边的权重和最小</li></ul><p><font color='red'>向生成树中加一条边都一定构成回路，最小生成树存在&lt;-&gt;图连通</font></p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182840204.png" alt="QQ_1728218590969" style="zoom:33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Prim</span><span class="hljs-params">()</span>&#123;<br>    MST = &#123;s&#125;;<br>    <span class="hljs-keyword">while</span>( <span class="hljs-number">1</span> )&#123;<br>        V = 未收录顶点中dist最小者;<span class="hljs-comment">/* 稠密图时间复杂度——|V|² */</span><br>        <span class="hljs-keyword">if</span>(这样的V不存在)<br>            <span class="hljs-keyword">break</span>;<br>        将V收录进MST: dist[V] = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">for</span>( V 的每个邻接点 W )<br>            <span class="hljs-keyword">if</span>(dist[W] != <span class="hljs-number">0</span>)<br>                <span class="hljs-keyword">if</span>(E(v,w) &lt; dist[W])&#123;<br>                    dist[W] = E(v,w);<br>                    parent[W] = V;<br>                &#125;<br>    &#125;<br>    <span class="hljs-keyword">if</span>(MST中收的顶点不到|V|个)<br>        Error(“生成树不存在”);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="1-2-Kruskal算法"><a href="#1-2-Kruskal算法" class="headerlink" title="1.2 Kruskal算法"></a>1.2 Kruskal算法</h3><p>稀疏图——时间复杂度：|E|log|E|</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Kruskal</span><span class="hljs-params">( Graph G )</span>&#123;<br>    MST=&#123; &#125;;<br>    <span class="hljs-keyword">while</span>( MST中不到|V|<span class="hljs-number">-1</span>条边 &amp;&amp; E中还有边)&#123;<br>        从中取一条权重最小的边E(v,w);   <span class="hljs-comment">/*最小堆 */</span><br>        将 E(v,w)从 E 中删除;<br>        <span class="hljs-keyword">if</span>(E(v,w)不在 MST 中构成回路)<br>            将 E(v,w)加入 MST;       <span class="hljs-comment">/*并査集 */</span><br>        <span class="hljs-keyword">else</span><br>            彻底无视E(v,w);<br>    &#125;<br>    <span class="hljs-keyword">if</span> (MST中不到IV!<span class="hljs-number">-1</span>条边)<br>        Error(“生成树不存在”);<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2-拓扑排序"><a href="#2-拓扑排序" class="headerlink" title="2 拓扑排序"></a>2 拓扑排序</h2><ul><li>拓扑序：如果图中从v到w有一条有向路径则V一定排在W之前。满足此条件的顶点序列称为一个拓扑序</li><li>获得一个拓扑序的过程就是拓扑排序</li><li>AOV(Activity On Vertex)如果有合理的拓扑序，则必定是有向无环图(Directed Acyclic Graph，DAG)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Topsort</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-keyword">for</span>( 图中每个顶点V )<br>        <span class="hljs-keyword">if</span>(Indegree[V] == <span class="hljs-number">0</span>)<br>            Enqueue(V, Q);<br>    <span class="hljs-keyword">while</span>( !IsEmpty(Q) )&#123;<br>        V=Dequeue(Q);<br>        输出V, 或者记录V的输出序号;<br>        cnt++;<br>        <span class="hljs-keyword">for</span>( V的每个邻接点W )<br>            <span class="hljs-keyword">if</span>(--Indegree[w] == <span class="hljs-number">0</span>)<br>                Enqueue(W, Q);<br>    &#125;<br>    <span class="hljs-keyword">if</span>(cnt != |V|)<br>        Error(“图中有回路”);<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="3-关键路径问题"><a href="#3-关键路径问题" class="headerlink" title="3 关键路径问题"></a>3 关键路径问题</h2><p>AOE(Activity On Edge)网络：一般用于安排项目的工序</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182845869.png" alt="QQ_1728222801310" style="zoom:33%;" /><h2 id="4-KMP算法"><a href="#4-KMP算法" class="headerlink" title="4 KMP算法"></a>4 KMP算法</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182848201.png" alt="QQ_1728480304490" style="zoom:33%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><span class="hljs-keyword">typedef</span> <span class="hljs-type">int</span> Position;<br><span class="hljs-meta">#<span class="hljs-keyword">define</span> NotFound -1</span><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span>&#123;<br>    <span class="hljs-type">char</span> <span class="hljs-built_in">string</span>[] = <span class="hljs-string">&quot;This is a simple example.&quot;</span>;<br>    <span class="hljs-type">char</span> pattern[] = <span class="hljs-string">&quot;simple&quot;</span>;<br>    Position p = KMP(<span class="hljs-built_in">string</span>, pattern);<br>    <span class="hljs-keyword">if</span>( p == NotFound ) <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Not Found.\n&quot;</span>);<br>    <span class="hljs-keyword">else</span> <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;%s\n&quot;</span>, <span class="hljs-built_in">string</span> + p);<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br><br>Position <span class="hljs-title function_">KMP</span><span class="hljs-params">(<span class="hljs-type">char</span> *<span class="hljs-built_in">string</span>, <span class="hljs-type">char</span> *pattern)</span>&#123;  <br>    <span class="hljs-type">int</span> n = <span class="hljs-built_in">strlen</span>(<span class="hljs-built_in">string</span>);<br>    <span class="hljs-type">int</span> m = <span class="hljs-built_in">strlen</span>(pattern);<br>    <span class="hljs-type">int</span> s, p, *match;<br>    <br>    <span class="hljs-keyword">if</span>(n &lt; m) <span class="hljs-keyword">return</span> NotFound;<br>    match = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>) *m);<br>    BuildMatch(pattern,match);<br>    s = p = <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">while</span>( s &lt; n &amp;&amp; p &lt; m)&#123;<br>        <span class="hljs-keyword">if</span>(<span class="hljs-built_in">string</span>[s] == pattern[p])&#123;<br>            s++;<br>            p++;<br>        &#125;<br>        <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span>(p &gt; <span class="hljs-number">0</span>) p = match[p<span class="hljs-number">-1</span>] + <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> s++;<br>    &#125;<br>    <span class="hljs-keyword">return</span>( p = m) ? (s - m) : NotFound;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">BuildMatch</span><span class="hljs-params">(<span class="hljs-type">char</span> *pattern, <span class="hljs-type">int</span> *match)</span>&#123;<br>    <span class="hljs-type">int</span> i, j;<br>    <span class="hljs-type">int</span> m = <span class="hljs-built_in">strlen</span>(pattern);<br>    match[<span class="hljs-number">0</span>] = <span class="hljs-number">-1</span>;<br>    <br>    <span class="hljs-keyword">for</span>(j = <span class="hljs-number">1</span>; j &lt; m; j++)&#123;<br>        i = match[j<span class="hljs-number">-1</span>];<br>        <span class="hljs-keyword">while</span>((i &gt;= <span class="hljs-number">0</span>) &amp;&amp; (pattern[i+<span class="hljs-number">1</span>] != pattern[j]))<br>            i = match[i];<br>        <span class="hljs-keyword">if</span> (pattern[i+<span class="hljs-number">1</span>] == pattern[j])<br>            match[j] = i+<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">else</span> match[j] = <span class="hljs-number">-1</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h1 id="六、排序"><a href="#六、排序" class="headerlink" title="六、排序"></a>六、排序</h1><p>没有一种排序是任何情况下都表现最好的</p><h2 id="6-1-冒泡排序"><a href="#6-1-冒泡排序" class="headerlink" title="6.1 冒泡排序"></a>6.1 冒泡排序</h2><p>优点：</p><ul><li>在链表中排序性能比较好</li><li>在两个元素相等时候不做交换，一定程度上保证了稳定性</li></ul><p>时间复杂度：</p><ul><li>最好情况：顺序T&#x3D;O(N)</li><li>最坏情况：逆序T&#x3D;O(N²)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Bubble_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">for</span>(P=N<span class="hljs-number">-1</span>;P&gt;=<span class="hljs-number">0</span>;P--)&#123;<br>        flag =<span class="hljs-number">0</span>;<br>        <span class="hljs-comment">/*一趟冒泡*/</span><br>        <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; P; i++)&#123;<br>            <span class="hljs-keyword">if</span>(A[i] &gt; A[i+<span class="hljs-number">1</span>])&#123;<br>                Swap(A[i], A[i+<span class="hljs-number">1</span>]);<br>                <span class="hljs-comment">/*标识发生了交换*/</span><br>                flag =<span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">/*全程无交换*/</span><br>        <span class="hljs-keyword">if</span>(flag==<span class="hljs-number">0</span>) <span class="hljs-keyword">break</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-2-插入排序"><a href="#6-2-插入排序" class="headerlink" title="6.2 插入排序"></a>6.2 插入排序</h2><p>时间复杂度：</p><ul><li>最好情况：顺序T&#x3D;O(N)</li><li>最坏情况：逆序T&#x3D;O(N²)</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Insertion_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">for</span>(P = <span class="hljs-number">1</span>; P &lt; N; P++)&#123;<br>        <span class="hljs-comment">/* 摸下一张牌 */</span><br>        Tmp = A[P];<br>        <span class="hljs-keyword">for</span>(i = P; i &gt; <span class="hljs-number">0</span> &amp;&amp; A[i<span class="hljs-number">-1</span>] &gt; Tmp; i--)<br>            A[i] = A[i<span class="hljs-number">-1</span>];<span class="hljs-comment">/* 移出空位 */</span><br>        A[i]= Tmp;<span class="hljs-comment">/* 新牌落位 */</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-3-希尔排序"><a href="#6-3-希尔排序" class="headerlink" title="6.3 希尔排序"></a>6.3 希尔排序</h2><p>最坏：T&#x3D;O(N²)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">shell_sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-comment">/*希尔增量序列*/</span><br>    <span class="hljs-keyword">for</span>(D = N / <span class="hljs-number">2</span>; D &gt; <span class="hljs-number">0</span>; D /= <span class="hljs-number">2</span>)&#123;<br>        <span class="hljs-comment">/*插入排序*/</span><br>        <span class="hljs-keyword">for</span>(P = D; P &lt; N; P++)&#123;<br>            Tmp = A[P];<br>            <span class="hljs-keyword">for</span>(i = P; i &gt;= D &amp;&amp; A[i-D] &gt; Tmp;i-=D)<br>                A[i] = A[i-D];<br>            A[i] = Tmp;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-4-堆排序"><a href="#6-4-堆排序" class="headerlink" title="6.4 堆排序"></a>6.4 堆排序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Heap_Sort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">for</span>(i = N/<span class="hljs-number">2</span>; i &gt;= <span class="hljs-number">0</span>; i--)<span class="hljs-comment">/*BuildHeap */</span><br>        PercDown(A, i, N);<br>    <span class="hljs-keyword">for</span>(i = N<span class="hljs-number">-1</span>; i &gt; <span class="hljs-number">0</span>; i--)&#123;<br>        Swap(&amp;A[<span class="hljs-number">0</span>], &amp;A[i]);<span class="hljs-comment">/*DeleteMax*/</span><br>        PercDown(A, <span class="hljs-number">0</span>, i);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h2 id="6-5-快速排序"><a href="#6-5-快速排序" class="headerlink" title="6.5 快速排序"></a>6.5 快速排序</h2><p>分而治之</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182856620.png" alt="QQ_1728305453057" style="zoom:33%;" /><p>伪码描述：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Quicksort</span><span class="hljs-params">(ElementType A[], <span class="hljs-type">int</span> N)</span>&#123;<br>    <span class="hljs-keyword">if</span> (N &lt; <span class="hljs-number">2</span>) <span class="hljs-keyword">return</span>; <br>    pivot = 从A[]中选一个主元;<br>    将s=&#123; A[] \pivot &#125;分成<span class="hljs-number">2</span>个独立子集:<br>    A1 = &#123;a∈s | a ≤ pivot &#125;和<br>        A2 = &#123;a∈s | a ≥ pivot &#125;;<br>    A[] = Quicksort( A1, N1) ∪ &#123;pivot&#125; ∪ Quicksort(A2, N2);<br>&#125;<br></code></pre></td></tr></table></figure><p><font color='red'>当递归的数据规模充分小，则停止递归，直接调用简单排序（例如插入排序）</font></p><p>代码实现：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Quicksort</span><span class="hljs-params">( ElementType A[], <span class="hljs-type">int</span> Left, <span class="hljs-type">int</span> Right )</span>&#123;<br>    <span class="hljs-keyword">if</span>(Cutoff &lt;= Right - Left)&#123;<br>        Pivot = Median3(A, Left, Right);<br>        i = Left; j= Right - <span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">for</span>( ; ; )&#123;<br>            <span class="hljs-keyword">while</span>(A[++i] &lt; Pivot)&#123;&#125;<br>            <span class="hljs-keyword">while</span>(A[--j] &gt; Pivot)&#123;&#125;<br>            <span class="hljs-keyword">if</span>(i&lt;j)<br>                Swap(&amp;A[i], &amp;A[j]);<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">break</span>;<br>        &#125;<br>        Swap( &amp;A[i], &amp;A[ Right<span class="hljs-number">-1</span> ]);<br>        Quicksort(A, Left, i<span class="hljs-number">-1</span>);<br>        Quicksort(A, i+<span class="hljs-number">1</span>, Right);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>        Insertion_Sort( A + Left, Right - Left + <span class="hljs-number">1</span>);<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">Quick_sort</span><span class="hljs-params">(ElementType A[],<span class="hljs-type">int</span> N)</span>&#123;<br>    Quicksort(A, <span class="hljs-number">0</span>, N<span class="hljs-number">-1</span>);<br>&#125;<br><br>ElementType <span class="hljs-title function_">Median3</span><span class="hljs-params">( ElementType A[], <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> Right )</span>&#123;<br>    <span class="hljs-type">int</span> Center = (Left + Right) / <span class="hljs-number">2</span>;<br>    <span class="hljs-keyword">if</span>(A[ Left ] &gt; A[ Center ])<br>        Swap( &amp;A[ Left ], &amp;A[ Center ]);<br>    <span class="hljs-keyword">if</span>(A[ Left ] &gt; A[ Right ])<br>        Swap( &amp;A[ Left ], &amp;A[ Right ]);<br>    <span class="hljs-keyword">if</span>( A[Center] &gt; A[ Right] )<br>        Swap( &amp;A[ Center ]，&amp;A[ Right ]);<br>    <span class="hljs-comment">/*A[ Left ] &lt;= A[ Center ] &lt;= A[ Right ]*/</span><br>    <span class="hljs-comment">/*将pivot藏到右边 */</span><br>    Swap(&amp;A[ Center ], &amp;A[ Right<span class="hljs-number">-1</span> ]);<br>    <span class="hljs-comment">/*只需要考虑 A[ Left+1 ]...A[ Right-2 ]*/</span><br>    <span class="hljs-comment">/*返回 pivot */</span><br>    <span class="hljs-keyword">return</span> A[ Right<span class="hljs-number">-1</span> ];<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-6-表排序"><a href="#6-6-表排序" class="headerlink" title="6.6 表排序"></a>6.6 表排序</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182859444.png" alt="QQ_1728354510647" style="zoom:33%;" /><p>最好情况：初始即有序<br>最坏情况：</p><ul><li>有⌊N&#x2F;2⌋个环，每个环包含2个元素</li><li>需要⌊3N&#x2F;2⌋次元素移动</li></ul><p>T&#x3D;O(m*N)，m是每个A元素的复制时间。</p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182905524.png" alt="QQ_1728454658628" style="zoom:33%;" /><h2 id="6-7-桶排序"><a href="#6-7-桶排序" class="headerlink" title="6.7 桶排序"></a>6.7 桶排序</h2><p>假设我们有N个学生，他们的成绩是0到100之间的整数(于是有M&#x3D;101个不同的成绩值)。如何在线性时间内将学生按成绩排序?</p><p>思想：将成绩分成101个桶，然后不停的插入学生成绩，并将其放入不同的桶中，用链表连接起来。</p><p>时间复杂度：T(N,M) &#x3D; O(M+N)</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">void</span> <span class="hljs-title function_">Bucket_Sort</span><span class="hljs-params">(ElementType A[],<span class="hljs-type">int</span> N)</span>&#123;<br>        count[]初始化;<br>    <span class="hljs-keyword">while</span>(读入<span class="hljs-number">1</span>个学生成绩grade)<br>        将该生插入count[grade]链表;<br>    <span class="hljs-keyword">for</span>(i = <span class="hljs-number">0</span>; i &lt; M; i++)&#123;<br>        <span class="hljs-keyword">if</span>( count[i])<br>            输出整个count[i]链表;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="6-8-基数排序"><a href="#6-8-基数排序" class="headerlink" title="6.8 基数排序"></a>6.8 基数排序</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182908617.png" alt="QQ_1728356135762" style="zoom:33%;" /><h2 id="6-9-多关键字排序"><a href="#6-9-多关键字排序" class="headerlink" title="6.9 多关键字排序"></a>6.9 多关键字排序</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182911138.png" alt="QQ_1728357158788" style="zoom:33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182913409.png" alt="QQ_1728357195960" style="zoom:33%;" /><p>问题：LSD任何时候都比MSD快吗？</p><p>不一定。极端情况下，当主位可以一次性把元素都直接分开、而次位办不到的时候，显然MSD更好。一般情况下，如果主位的基数比次位大（例如扑克牌如果先按面值、同一面值内部按花色排序的话），则主位更有可能把元素分开，这时候用MSD就可能比LSD快。</p><h2 id="6-10-排序算法的比较"><a href="#6-10-排序算法的比较" class="headerlink" title="6.10 排序算法的比较"></a>6.10 排序算法的比较</h2><table><thead><tr><th align="center">排序方法</th><th align="center">平均时间复杂度</th><th align="center">最坏情况下时间复杂度</th><th align="center">额外空间复杂度</th><th align="center">稳定性</th></tr></thead><tbody><tr><td align="center">简单选择排序</td><td align="center">O(N²)</td><td align="center">O(N²)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">冒泡排序</td><td align="center">O(N²)</td><td align="center">O(N²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">直接插入排序</td><td align="center">O(N²)</td><td align="center">O(N²)</td><td align="center">O(1)</td><td align="center">稳定</td></tr><tr><td align="center">希尔排序</td><td align="center">O(Nᵈ)</td><td align="center">O(N²)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">堆排序</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(1)</td><td align="center">不稳定</td></tr><tr><td align="center">快速排序</td><td align="center">O(NlogN)</td><td align="center">O(N²)</td><td align="center">O(logN)</td><td align="center">不稳定</td></tr><tr><td align="center">归并排序</td><td align="center">O(NlogN)</td><td align="center">O(NlogN)</td><td align="center">O(N)</td><td align="center">稳定</td></tr><tr><td align="center">基数排序</td><td align="center">O(P(N+B))</td><td align="center">O(P(N+B))</td><td align="center">O(N+B)</td><td align="center">稳定</td></tr></tbody></table><h1 id="七、散列表"><a href="#七、散列表" class="headerlink" title="七、散列表"></a>七、散列表</h1><p>【问题】如何快速搜索到需要的关键词？如果关键词不方便比较怎么办？</p><p>查找的本质：已知对象找位置</p><ul><li>有序安排对象:全序、半序</li><li>直接“算出”对象位置：散列</li></ul><p>散列查找法的两项基本工作：</p><ul><li>计算位置：构造散列函数确定关键词存储位置；</li><li>解决冲突：应用某种策略解决多个关键词位置相同的问题</li></ul><p><font color="red">时间复杂度几乎是常量：O(1)，</font>即查找时间与间题规模无关！</p><h2 id="7-1-基本概念"><a href="#7-1-基本概念" class="headerlink" title="7.1 基本概念"></a>7.1 基本概念</h2><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182918157.png" alt="QQ_1728455929633" style="zoom:33%;" /><p><font color='red'>“散列函数”的基本思想：</font></p><p>(1)以关键字key为自变量，通过一个确定的函数h(散列函数)计算出对应的函数值h(key)，作为数据对象的存储地址。</p><p>(2)可能不同的关键字会映射到同一个散列地址上，即h(keyi)&#x3D; h(keyj)(当key¡≠keyj)，称为“冲突(Collision)”</p><p>—需要某种冲突解决策略</p><p><font color='red'><strong>好的散列函数需要考虑两个因素</strong></font></p><ol><li>计算简单，以便提高转换速度；</li><li>关键词对应的地址空间分布均匀，以尽量减少冲突。</li></ol><figure class="highlight scss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs scss">选择合适的<span class="hljs-built_in">h</span>(key)，散列法的查找效率期望是常数<span class="hljs-number">0</span>(<span class="hljs-number">1</span>)，它几乎与关键字的空间的大小n无关！也适合于关键字直接比较计算量大的问题。<br><br>它是以较小的<span class="hljs-selector-tag">a</span>为前提。因此，散列方法是一个以空间换时间<br><br>散列方法的存储对关键字是随机的，不便于顺序查找关键字，也不适合于范围查找，或最大值最小值查找。<br></code></pre></td></tr></table></figure><h2 id="7-2-数字关键词的散列函数构造"><a href="#7-2-数字关键词的散列函数构造" class="headerlink" title="7.2 数字关键词的散列函数构造"></a>7.2 数字关键词的散列函数构造</h2><ol><li><p>直接地址法</p><p>取关键词的某个线性函数值为散列地址，即：<font color='purple'>h(key) &#x3D; a * key + b </font></p></li><li><p>除留余数法</p><p>散列函数为：h(key) &#x3D; key mod p</p></li><li><p>数字分析法<br>分析数字关键字在各位上的变化情况，取比较随机的位作为散列地址</p><p>比如:取11位手机号码key的后4位作为地址：<br>散列函数为：h(key)&#x3D; atoi(key + 7)(char * key)</p></li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182921146.png" alt="QQ_1728465472650" style="zoom:33%;" /><ol start="4"><li>折叠法<br>把关键词分割成位数相同的几个部分，然后叠加</li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182923141.png" alt="QQ_1728465814502" style="zoom:33%;" /><ol start="5"><li>平方取中法</li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182925212.png" alt="QQ_1728465873003" style="zoom:33%;" /><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">总结：<br></code></pre></td></tr></table></figure><ol><li><p>一个简单的散列函数——ASCII码加和法</p><p>对字符型关键词key定义散列函数如下<br>h(key)&#x3D; (Σkey[i]) mod TableSize</p></li><li><p>简单的改进——前3个字符移位法<br>h(key)&#x3D;(key[0]x27² + key[1]x27 + key[2]) mod TableSize</p></li><li><p>好的散列函数——移位法</p><p>涉及关键词所有n个字符，并且分布得很好:</p></li></ol><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625182927959.png" alt="QQ_1728466320250" style="zoom:33%;" /><h2 id="7-3-冲突处理方法"><a href="#7-3-冲突处理方法" class="headerlink" title="7.3 冲突处理方法"></a>7.3 冲突处理方法</h2><p>常用处理冲突的思路：</p><ul><li>换个位置:开放地址法</li><li>同一位置的冲突对象组织在一起：链地址法</li></ul><h3 id="7-3-1-开放定址法-OpenAddressing"><a href="#7-3-1-开放定址法-OpenAddressing" class="headerlink" title="7.3.1 开放定址法(OpenAddressing)"></a>7.3.1 开放定址法(OpenAddressing)</h3><p>一旦产生了冲突（该地址已有其它元素），就按某种规则去寻找另一空地址</p><ul><li><p>若发生了第i次冲突，试探的下一个地址将增加d，基本公式是：</p><p>hᵢ(key) &#x3D; (h(key)+dᵢ)  mod TableSize (1&lt; i &lt; TableSize)</p></li><li><p>dᵢ决定了不同的解决冲突方案：<font color='red'>线性探测、平方探测、双散列</font></p></li></ul><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs markdown">优点：<br><span class="hljs-code">散列表是一个数组，存储效率高，随机查找</span><br><span class="hljs-code"></span><br>缺点：<br><span class="hljs-code">散列表有“聚集”现象</span><br></code></pre></td></tr></table></figure><h3 id="7-3-2-分离链接法-Separate-Chaining"><a href="#7-3-2-分离链接法-Separate-Chaining" class="headerlink" title="7.3.2 分离链接法(Separate Chaining)"></a>7.3.2 分离链接法(Separate Chaining)</h3><p>将相应位置上冲突的所有关键词储存在同一个单链表中，将其相应的都串起来</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">散列表是顺序存储和链式存储的结合，链表部分的存储效率和查找效率都比较低。<br><br>关键字删除不需要“懒惰删除”法，从而没有存储“垃圾”<br><br>太小的<span class="hljs-selector-tag">a</span>可能导致空间浪费，大的<span class="hljs-selector-tag">a</span>又将付出更多的时间代价。不均匀的链表长度导致时间效率的严重下降。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>数据结构</category>
      
    </categories>
    
    
    <tags>
      
      <tag>数据结构</tag>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/01/24/hello-world/"/>
    <url>/2022/01/24/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span><br>hexo clean &amp; hexo s<br>hexo g -d<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo server<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo generate<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ hexo deploy<br></code></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
