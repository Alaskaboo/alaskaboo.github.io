

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/fluid.png">
  <link rel="icon" href="/img/fluid.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="Alaskaboo">
  <meta name="keywords" content="">
  
    <meta name="description" content="一 相关概念1 什么是机器学习机器学习定义：让计算机在没有明确编程的情况下学习的研究领域。（从数据中寻找规律、建立关系，根据建立的关系去解决问题的方法，即从数据中学习并实现自我优化与升级）。 机器学习又分为分类任务、和回归任务。主要的区别在于分类可以理解为离散的点，而回归任务是连续的线。 机器学习、深度学习、人工智能的关系  机器学习是实现人工智能的方法，深度学习是一种实现机器学习的技术  2 科">
<meta property="og:type" content="article">
<meta property="og:title" content="Machine Learning">
<meta property="og:url" content="http://example.com/2025/03/02/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/index.html">
<meta property="og:site_name" content="Alaskaboo&#39;s Blog">
<meta property="og:description" content="一 相关概念1 什么是机器学习机器学习定义：让计算机在没有明确编程的情况下学习的研究领域。（从数据中寻找规律、建立关系，根据建立的关系去解决问题的方法，即从数据中学习并实现自我优化与升级）。 机器学习又分为分类任务、和回归任务。主要的区别在于分类可以理解为离散的点，而回归任务是连续的线。 机器学习、深度学习、人工智能的关系  机器学习是实现人工智能的方法，深度学习是一种实现机器学习的技术  2 科">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214357844.png">
<meta property="article:published_time" content="2025-03-02T02:30:22.000Z">
<meta property="article:modified_time" content="2025-07-16T13:30:17.273Z">
<meta property="article:author" content="Alaskaboo">
<meta property="article:tag" content="计算机视觉">
<meta property="article:tag" content="机器学习">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625214357844.png">
  
  
  
  <title>Machine Learning - Alaskaboo&#39;s Blog</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":"akJv1KA0MwGLTy6JWX7w0dA4-gzGzoHsz","app_key":"tLxfRjWzNlEaAQyKovK194Yt","server_url":"https://akjv1ka0.lc-cn-n1-shared.com","path":"window.location.pathname","ignore_local":true},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  
    
  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>Alaskaboo&#39;s Blog</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/" target="_self">
                <i class="iconfont icon-link-fill"></i>
                <span>友链</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/default.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Machine Learning"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2025-03-02 10:30" pubdate>
          2025年3月2日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          21k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          174 分钟
        
      </span>
    

    
    
      
        <span id="leancloud-page-views-container" class="post-meta" style="display: none">
          <i class="iconfont icon-eye" aria-hidden="true"></i>
          <span id="leancloud-page-views"></span> 次
        </span>
        
      
      
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">Machine Learning</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="一-相关概念"><a href="#一-相关概念" class="headerlink" title="一 相关概念"></a>一 相关概念</h1><h2 id="1-什么是机器学习"><a href="#1-什么是机器学习" class="headerlink" title="1 什么是机器学习"></a>1 什么是机器学习</h2><p>机器学习定义：让计算机在没有明确编程的情况下学习的研究领域。（从数据中寻找规律、建立关系，根据建立的关系去解决问题的方法，即从数据中学习并实现自我优化与升级）。</p>
<p>机器学习又分为分类任务、和回归任务。<font color='red'>主要的区别在于分类可以理解为<strong>离散的点</strong>，而<strong>回归任务是连续的线</strong>。</font></p>
<p>机器学习、深度学习、人工智能的关系</p>
<blockquote>
<p>机器学习是实现人工智能的方法，深度学习是一种实现机器学习的技术</p>
</blockquote>
<h2 id="2-科学计算库"><a href="#2-科学计算库" class="headerlink" title="2 科学计算库"></a>2 科学计算库</h2><h3 id="2-1-numpy"><a href="#2-1-numpy" class="headerlink" title="2.1 numpy"></a>2.1 numpy</h3><p>概念：NumPy(Numerical Python)是Python的一种开源的数值计算扩展。提供多维数组对象，各种派生对象(如掩码数组和矩阵)，这种工具可用来存储和处理大型矩阵，比Python自身的嵌套列表(nested list structure)结构要高效的多(该结构也可以用来表示矩阵(matrix))，支持大量的维度数组与矩阵运算，此外也针对数组运算提供大量的数学函数库，包括数学、逻辑、形状操作、排序、选择、输入输出、离散傅立叶变换、基本线性代数基本统计运算和随机模拟等等。</p>
<blockquote>
<p>会把其中元素转换成相同的类型。</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 02 array数组</span><br>ala_list = [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>,<span class="hljs-number">4</span>,<span class="hljs-string">&quot;5&quot;</span>]<br>ala_list = np.array(ala_list)<br><span class="hljs-built_in">print</span>(ala_list)<br><br><span class="hljs-comment"># 等差数列</span><br>np.linspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,<span class="hljs-number">10</span>)<br><br><span class="hljs-comment"># 等比数列</span><br>np.logspace(<span class="hljs-number">1</span>,<span class="hljs-number">10</span>,num=<span class="hljs-number">10</span>, base=<span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 保存，默认是.npz</span><br>np.save(<span class="hljs-string">&quot;./arr1&quot;</span>, arr1)<br><br>np.load(<span class="hljs-string">&quot;./arr1.npy&quot;</span>)<br><br><span class="hljs-comment"># 保存txt、csv</span><br>np.savetxt(fname=<span class="hljs-string">&quot;./arr1.txt&quot;</span>, X=arr1, delimiter=<span class="hljs-string">&quot;,&quot;</span>, fmt=<span class="hljs-string">&quot;%0.5f&quot;</span>)<br></code></pre></td></tr></table></figure>



<blockquote>
<p>array当中数值不是赋值，而是将其地址指向前一个，如果不想影响应当使用copy</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173112436.png" srcset="/img/loading.gif" lazyload alt="image-20250307152448430" style="zoom: 50%;" />



<h3 id="2-2-Pandas"><a href="#2-2-Pandas" class="headerlink" title="2.2 Pandas"></a>2.2 Pandas</h3><blockquote>
<p>其他正常操作即可，注意merge操作可以合并两个表，同时可以选择按照左边或右边为基准</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">pd.set_option(<span class="hljs-string">&#x27;display.precision&#x27;</span>, <span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>



<h3 id="2-3-Keras"><a href="#2-3-Keras" class="headerlink" title="2.3 Keras"></a>2.3 Keras</h3><p>​	Keras是一个用Python编写的用于神经网络开发的应用接调用开接口可以实现神经网络、卷积神经网络、循环神经网络等常用深度学习算法的开发。Keras为用户提供了一个易于交互的外壳，方便进行深度学习的快速开发。</p>
<p>特点：</p>
<blockquote>
<p>集成了深度学习中各类成熟的算法，容易安装和使用，样例丰富教程和文档也非常详细</p>
<p>能够以 TensorFlow，或者 Theano 作为后端运行</p>
</blockquote>
<p>Keras or Tensorflow：</p>
<blockquote>
<p>Tensorflow 是一个采用数据流图，用于数值计算的开源软件库可自动计算模型相关的微分导数：非常适合用于神经网络模型的求解。</p>
<p>Keras可看作为tensorflow封装后的一个接口（Keras作为前端TensorFlow作为后端）。</p>
</blockquote>
<h3 id="2-4-Scikit-learn"><a href="#2-4-Scikit-learn" class="headerlink" title="2.4 Scikit-learn"></a>2.4 Scikit-learn</h3><p>概念：Python语言中专门针对机器学习应用而发展起来的一款开源框架(算法库)，可以实现数据预处理、分类、回归、降维、模型选择等常用的机器学习算法。</p>
<p>特点：</p>
<blockquote>
<p>优点：集成了机器学习中各类成熟的算法，容易安装和使用，样例丰富，教程和文档也非常详细</p>
<p>缺点：不支持Python之外的语言，不支持深度学习和强化学习</p>
</blockquote>
<h2 id="3-专业名词"><a href="#3-专业名词" class="headerlink" title="3 专业名词"></a>3 专业名词</h2><h3 id="3-1-准确率-精度-ACC-precision"><a href="#3-1-准确率-精度-ACC-precision" class="headerlink" title="3.1 准确率(精度)ACC&#x2F;precision"></a>3.1 准确率(精度)ACC&#x2F;precision</h3><p>精度Accuracy是指模型预测正确（包括真正例TP、真反例TN）的样本数与总体样本数的占比。</p>
<h3 id="3-2-召回率TPR-查全率Recall"><a href="#3-2-召回率TPR-查全率Recall" class="headerlink" title="3.2 召回率TPR&#x2F;查全率Recall"></a>3.2 <strong>召回率</strong>TPR&#x2F;查全率Recall</h3><p>​	正样本中，预测正确的比例。<strong><font color = 'red'>召回率高则说明漏检率低</font></strong>，它的一个应用场景便是疾病的检测，因为在在这种情况下我们是希望患病病例（正样本）被尽可能的检测出来，不然漏检的话后果很严重。</p>
<p>​	精确率计算的是<font color='red'><strong>预测对的正样本在整个预测为正样本中的比重</strong></font>，而召回率计算的是<font color='red'><strong>预测对的正样本在整个真实正样本中的比重</strong></font>。因此一般来说，召回率越高也就意味着这个模型找寻正样本的能力越强。</p>
<h3 id="3-3-特异度TNR"><a href="#3-3-特异度TNR" class="headerlink" title="3.3 特异度TNR"></a>3.3 特异度<strong>TNR</strong></h3><p>负样本中，预测正确的比例。<strong><font color='red'>特异度高则说明误诊率高</font></strong>，它的一个应用场景便是诊断实验确定非患病患者的能力。</p>
<h3 id="3-4-精确率PPV"><a href="#3-4-精确率PPV" class="headerlink" title="3.4 精确率PPV"></a>3.4 精确率PPV</h3><p>被预测为正样本中有多少是正确的，<font color='red'><strong>精确率高则说明误检率低</strong></font>。召回率是尽可能的把正样本都查找出来，而精确率尽可能地保证预测的正确率。</p>
<h3 id="3-5-F1分数"><a href="#3-5-F1分数" class="headerlink" title="3.5 F1分数"></a>3.5 F1分数</h3><p>精确率和召回率的调和平均值，<font color='red'><strong>通常值越大越好</strong></font>。</p>
<p>比如：</p>
<ul>
<li>在涉及到严重事故如癌病检测的系统中，我们要注重召回率，越高越好，因为我们不希望有病的人被漏诊；</li>
<li>而对于垃圾邮箱检测系统来说，我们要注重精确度，越高越好，因为我们宁愿多看一封垃圾邮件，也不能错失一封重要的邮件；</li>
<li>再举个不太恰当的例子，比如对于刑事诉讼审判系统来说，我国司法机关偏向于高召回率，即天网恢恢疏而不漏绝不放过一个坏人；</li>
<li>而美国司法偏向于高精确率，即人权大于一切绝不冤枉一个好人；有时候很难说孰是孰非，更合理的做法便是提高F1分数。</li>
</ul>
<h3 id="3-6-P-R曲线"><a href="#3-6-P-R曲线" class="headerlink" title="3.6 P-R曲线"></a>3.6 P-R曲线</h3><p>即精确率-召回率曲线，其中横轴是召回率（TPR），纵轴是精确率（PPV）。PR曲线实质上是通过设置不同的阈值，最终将一系列的点汇聚起来连成一条线。我们知道，通过设置不同的阈值我们所划分的正样本或负样本均有所不同，一般来说将大于阈值的样本划分为正样本，而小于当前阈值的样本划分为负样本。需要注意的是，<strong><font color='red'>PR曲线对正负样本的比例异常敏感，即当正负样本的分布发生变化时，PR曲线的形状会发生巨大的变化</font></strong>。</p>
<h3 id="3-7-Epoch、Batch以及Batch-size"><a href="#3-7-Epoch、Batch以及Batch-size" class="headerlink" title="3.7 Epoch、Batch以及Batch size"></a>3.7 Epoch、Batch以及Batch size</h3><p><strong>Epoch（时期）：</strong></p>
<p>当一个完整的数据集通过了神经网络一次并且返回了一次，这个过程称为一次epoch。（也就是说，所有训练样本在神经网络中都 进行了一次正向传播 和一次反向传播 ）</p>
<p>再通俗一点，一个Epoch就是将所有训练样本训练一次的过程。</p>
<p>然而，当一个Epoch的样本（也就是所有的训练样本）数量可能太过庞大（对于计算机而言），就需要把它分成多个小块，也就是就是分成多个Batch 来进行训练。</p>
<ul>
<li><strong>Batch（批 &#x2F; 一批样本）：</strong></li>
</ul>
<p>将整个训练样本分成若干个Batch。</p>
<ul>
<li><strong>Batch_Size（批大小）：</strong></li>
</ul>
<p>每批样本的大小。</p>
<ul>
<li><strong>Iteration（一次迭代）：</strong></li>
</ul>
<p>训练一个Batch就是一次Iteration（这个概念跟程序语言中的迭代器相似）</p>
<ul>
<li><strong>dropout（随机失活）：</strong></li>
</ul>
<p>防止模型训练过拟合</p>
<h3 id="3-7-AP"><a href="#3-7-AP" class="headerlink" title="3.7 AP"></a>3.7 AP</h3><p>AP是PR曲线下面积的近似值，计算方式因任务和数据集标准不同而有所差异。</p>
<p>计算方法：</p>
<ul>
<li>全点插值法（COCO标准）</li>
<li>11点插值法（PASCAL VOC标准）</li>
</ul>
<h3 id="3-8-mAP"><a href="#3-8-mAP" class="headerlink" title="3.8 mAP"></a>3.8 mAP</h3><p>mAP，即平均精度均值，是目标检测任务中常用的性能评估指标。在目标检测中，我们不仅要判断图像中是否存在某个目标，还需要定位目标的位置。因此，评估指标需要综合考虑分类和定位的准确性。<font color='red'><strong>mAP结合了精确率和召回率，能够全面评估模型的性能</strong></font>。</p>
<h3 id="3-9-交并比IoU"><a href="#3-9-交并比IoU" class="headerlink" title="3.9 交并比IoU"></a>3.9 交并比IoU</h3><p><strong>IoU</strong>度量两个边界之间的重叠，<font color='red'><strong>越大越好</strong></font>。我们使用它来度量我们的预测边界与ground truth(实际对象边界)的重叠程度。</p>
<h3 id="3-10-均方误差（MSE）"><a href="#3-10-均方误差（MSE）" class="headerlink" title="3.10 均方误差（MSE）"></a>3.10 均方误差（MSE）</h3><p>y’和y的均方误差（MSE）：$MSE&#x3D;\frac{1}{m}\sum\limits_{i&#x3D;1}^{n}(y’{i}-y_{i})^2$</p>
<p>R方值（$R^2$）：$R^2&#x3D;1-\frac{limits_{i&#x3D;1}^{n}(y’{i}-y_{i})^2}{limits_{i&#x3D;1}^{n}(y’{i}-\overline y_{i})^2} &#x3D; 1 - \frac{MSE}{方差}$</p>
<blockquote>
<p>MSE越小越好， ${R^2}$分数越接近1越好</p>
<p>y’ vs y集中度越高越好（越接近直线分布）</p>
</blockquote>
<h3 id="3-11-梯度"><a href="#3-11-梯度" class="headerlink" title="3.11 梯度"></a>3.11 梯度</h3><p>这样几乎就没有梯度信号通过神经元传递到前面层的梯度更新中，因此这时前面层的权值几乎没有更新，这就叫梯度消失。</p>
<h3 id="3-12-正则化"><a href="#3-12-正则化" class="headerlink" title="3.12 正则化"></a>3.12 正则化</h3><p><strong>正则化（Regularization）</strong> 是一种防止模型过拟合（overfitting）的方法。它通过对模型的损失函数增加额外的约束项，使模型在训练时不会对训练数据“记得太牢”，从而提升在新数据上的泛化能力。</p>
<h2 id="4-过拟合与欠拟合"><a href="#4-过拟合与欠拟合" class="headerlink" title="4 过拟合与欠拟合"></a>4 过拟合与欠拟合</h2><blockquote>
<p>模型不合适，导致其无法对数据实现有效预测。</p>
<p><strong>过拟合</strong>是指模型在训练集上表现很好，但在测试集上表现很差，原因是模型太复杂，学到了训练数据中的“噪声”。</p>
</blockquote>
 <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173133619.png" srcset="/img/loading.gif" lazyload alt="image-20250226163911929" style="zoom:33%;" />



<p>原因：</p>
<blockquote>
<p>模型结构过于复杂（维度过高）<br>使用了过多属性，模型训练时包含了干扰项信息</p>
</blockquote>
<p>解决办法：</p>
<blockquote>
<p>简化模型结构（比如线性模型，使用低阶模型）</p>
<p>数据预处理，保留主成分信息（数据PCA处理）</p>
<p>在模型训练时，增加正则化项（regularization）</p>
</blockquote>
<h2 id="5-数据分离与混淆矩阵"><a href="#5-数据分离与混淆矩阵" class="headerlink" title="5 数据分离与混淆矩阵"></a>5 数据分离与混淆矩阵</h2><p>数据分离：</p>
<blockquote>
<p>1、把数据分成两部分：训练集、测试集<br>2、使用训练集数据进行模型训练<br>3、使用测试集数据进行预测，更有效地评估模型对于新数据的预测表现</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173136368.png" srcset="/img/loading.gif" lazyload alt="image-20250226181038198" style="zoom:33%;" />

<p><strong>混淆矩阵：</strong> </p>
<blockquote>
<p>概念：又称为误差矩阵、用于衡量分类算法的准确程度。</p>
<p>●True Positives（TP）：预测准确、实际为正样本的数量（实际为1，预测为1），<font color='red'><strong>真阳性</strong></font></p>
<p>●True Negatives（TN）：预测准确、实际为负样本的数量（实际为0，预测为0），<font color='red'><strong>真阴性</strong></font></p>
<p>●False Positives（FP）：预测错误、实际为负样本的数量（实际为0，预测为1），<font color='red'><strong>假阳性</strong></font></p>
<p>●False Negatives（FN）：预测错误、实际为正样本的数量（实际为1，预测为0），<font color='red'><strong>假阴性</strong></font></p>
<p>（预测结果正确或错误，预测结果为正样本或负样本）</p>
<p>指标特点:</p>
<blockquote>
<p>分类任务中，相比单一的预测准确率，混淆矩阵提供了更全面的模型评估信息（TP\TN\FP\FN)</p>
<p>通过混淆矩阵，我们可以计算出多样的模型表现衡量指标，从而更好地选择模型</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173138907.png" srcset="/img/loading.gif" lazyload alt="image-20250227103857268" style="zoom:33%;" /></blockquote>
<p>例子：</p>
<blockquote>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173141940.png" srcset="/img/loading.gif" lazyload alt="image-20250227124801561" style="zoom:29%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173143884.png" srcset="/img/loading.gif" lazyload alt="image-20250227103637225" style="zoom: 33%;" /></p>
</blockquote>
<h2 id="6-模型优化"><a href="#6-模型优化" class="headerlink" title="6 模型优化"></a>6 模型优化</h2><p>数据的重要性：</p>
<blockquote>
<p>检查：</p>
<p>1、<strong>数据属性的意义</strong>，是否为无关数据（查看是否能做PCA的主成分分析，如果可以就可降维处理）</p>
<p>2、不同属性数据的<strong>数量级差异性</strong>如何</p>
<p>3、是否有<strong>异常数据</strong></p>
<p>4、采集数据的<strong>方法</strong>是否合理，采集到的数据是否有代表性</p>
<p>5、对于标签结果，<strong>要确保标签判定规则的一致性</strong>（统一标准）</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173147328.png" srcset="/img/loading.gif" lazyload alt="image-20250227131418824" style="zoom:33%;" />

<p>鲁棒性：系统或算法在面临输入错误、环境变化、噪声干扰、参数变化等不确定性和异常情况时，仍能保持其性能和稳定性的能力</p>
</blockquote>
<p>模型优化：在确定模型类别后，如何让模型表现更好（三方面：数据、模型核心参数、正则化）</p>
<blockquote>
<p>遍历核心参数组合，评估对应模型表现（比如：逻辑回归边界函数考虑多项式、KNN尝试不同的n_neighbors值）<br>扩大数据样本<br>增加或减少数据属性<br>对数据进行降维处理<br>对模型进行正则化处理，调整正则项λ的数值</p>
</blockquote>
<h2 id="7-常用激活函数"><a href="#7-常用激活函数" class="headerlink" title="7 常用激活函数"></a>7 常用激活函数</h2><p>​	<em>激活函数</em>（activation function）通过计算加权和并加上偏置来确定神经元是否应该被激活， 它们将输入信号转换为输出的可微运算。 大多数激活函数都是非线性的。 由于激活函数是深度学习的基础，下面简要介绍一些常见的激活函数。</p>
<p>​	<em>激活函数，并不是去激活什么，而是指如何把”激活的神经元的特征”通过函数把特征保留并映射出来，即*<em>负责将神经元的输入映射到输出端</em></em>。*</p>
<p>​	<strong>为何引入非线性的激活函数？</strong>——如果不用激活函数，在这种情况下每一层输出都是上层输入的线性函数，无论神经网络有多少层，输出都是输入的线性组合，与没有隐藏层效果相当，这种情况就是最原始的感知机（Perceptron）了。因此引入非线性函数作为激活函数，这样深层神经网络就有意义了（不再是输入的线性组合，可以逼近任意函数）</p>
<h3 id="7-1-Relu"><a href="#7-1-Relu" class="headerlink" title="7.1  Relu"></a>7.1  Relu</h3><p>​	<em>修正线性单元</em>（Rectified linear unit，<em>ReLU</em>）， 因为它实现简单，同时在各种预测任务中表现良好。 ReLU提供了一种非常简单的非线性变换。</p>
<p>​	公式：<font color='red'>$ReLU(x)&#x3D;max(x, 0)$</font>，当输入为负时，ReLU函数的导数为0，而当输入为正时，ReLU函数的导数为1。 注意，当输入值精确等于0时，ReLU函数不可导。 在此时，我们默认使用左侧的导数，即当输入为0时导数为0。 我们可以忽略这种情况，因为输入可能永远都不会是0。</p>
<p>​	</p>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173149852.png" srcset="/img/loading.gif" lazyload alt="image-20250526112919525"></p>
<p>**引入ReLu的原因？**它求导表现得特别好：要么让参数消失，要么让参数通过。</p>
<blockquote>
<p>第一，采用sigmoid等函数，算激活函数时（指数运算），<strong>计算量大</strong>，反向传播求误差梯度时，求导涉及除法，计算量相对大，而采用Relu激活函数，整个过程的计算量节省很多。</p>
<p>第二，对于深层网络，sigmoid函数反向传播时，很容易就会出现<strong>梯度消失</strong>的情况（在sigmoid接近饱和区时，变换太缓慢，导数趋于0，这种情况会造成信息丢失），从而无法完成深层网络的训练。</p>
<p>第三，ReLu会使一部分神经元的输出为0，这样就造成了<strong>网络的稀疏性</strong>，并且减少了参数的相互依存关系，<strong>缓解了过拟合</strong>问题的发生。</p>
</blockquote>
<h3 id="7-2-sigmoid"><a href="#7-2-sigmoid" class="headerlink" title="7.2 sigmoid"></a>7.2 sigmoid</h3><p>​	对于一个定义域在R中的输入， <em>sigmoid函数</em>将输入变换为区间(0, 1)上的输出。 因此，sigmoid通常称为<strong><em>挤压函数</em>（squashing function）</strong>： 它将范围（-inf, inf）中的任意输入压缩到区间（0, 1）中的某个值：<font color='red'>$sigmoid(x)&#x3D;\frac{1}{1+e^{-x}}$</font></p>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173152122.png" srcset="/img/loading.gif" lazyload alt="image-20250526114203896"></p>
<p>​	阈值单元在其输入低于某个阈值时取值0，当输入超过阈值时取值1。</p>
<p><strong>适用范围：</strong></p>
<blockquote>
<p>Sigmoid 函数的输出范围是 0 到 1。非常适合作为模型的输出函数用于输出一个0~1范围内的概率值，比如用于表示二分类的类别或者用于表示置信度。梯度平滑，便于求导，也防止模型训练过程中出现突变的梯度</p>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>容易造成梯度消失。我们从导函数图像中了解到sigmoid的导数都是小于0.25的，那么在进行反向传播的时候，梯度相乘结果会慢慢的趋向于0。除此之外，为了防止饱和，必须对于权重矩阵的初始化特别留意。如果初始化权重过大，可能很多神经元得到一个比较小的梯度，致使神经元不能很好的更新权重提前饱和，神经网络就几乎不学习。</li>
<li>函数输出不是以 0 为中心的，梯度可能就会向特定方向移动，从而降低权重更新的效率</li>
<li>Sigmoid 函数执行指数运算，计算机运行得较慢，比较消耗计算资源。</li>
</ul>
</blockquote>
<h3 id="7-3-Tanh"><a href="#7-3-Tanh" class="headerlink" title="7.3 Tanh"></a>7.3 Tanh</h3><p>​	与sigmoid函数类似， tanh(双曲正切)函数也能将其输入压缩转换到区间(-1, 1)上。 tanh函数的公式如下：</p>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173157270.png" srcset="/img/loading.gif" lazyload alt="image-20250526114404948"></p>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173154945.png" srcset="/img/loading.gif" lazyload alt="image-20250526114433659"></p>
<p><strong>适用范围</strong></p>
<blockquote>
<ul>
<li>tanh 的输出间隔为 1，并且整个函数以 0 为中心，比 sigmoid 函数更好；</li>
<li>在 tanh 图中，负输入将被强映射为负，而零输入被映射为接近零。</li>
</ul>
</blockquote>
<p><strong>缺点：</strong></p>
<blockquote>
<ul>
<li>仍然存在梯度饱和的问题</li>
<li>依然进行的是指数运算</li>
</ul>
</blockquote>
<h1 id="二-相关模型"><a href="#二-相关模型" class="headerlink" title="二 相关模型"></a>二 相关模型</h1><h2 id="1-相关技术"><a href="#1-相关技术" class="headerlink" title="1 相关技术"></a>1 相关技术</h2><h3 id="1-组成成分分析PCA"><a href="#1-组成成分分析PCA" class="headerlink" title="1 组成成分分析PCA"></a>1 组成成分分析PCA</h3><h4 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><p>数据降维：</p>
<blockquote>
<p>数据降维，是指在某些限定条件下，降低随机变量个数，得到一组”不相关“主变量的过程。<br>作用:</p>
<blockquote>
<p>减少模型分析数据量，提升处理效率，降低计算难度;<br>实现数据可视化。</p>
</blockquote>
</blockquote>
<blockquote>
<p>PCA(principal components analysis)：数据降维技术中，应用最最多的方法</p>
<p>目标：寻找k(k&lt;6)维新数据，使它们反映事物的主要特征，</p>
<p>核心：在信息损失尽可能少的情况下，降低数据维度</p>
<p>如何保留主要信息：投影后的不同特征数据尽可能分得开（即不相关）</p>
<p>如何实现？使投影后数据的方差最大，因为方差越大数据也越分散</p>
<p>计算过程:</p>
<blockquote>
<p>原始数据预处理（标准化：u&#x3D; 0，σ&#x3D;1)</p>
<p>计算协方差矩阵特征向量、及数据在各特征向量投影后的方差</p>
<p>根据需求（任务指定或方差比例）确定降维维度k</p>
<p>选取k维特征向量，计算数据在其形成空间的投影</p>
</blockquote>
</blockquote>
<p>应用范围：</p>
<blockquote>
<ol>
<li>根据设备上传感器1与2的数据，自动监测设备异常工作状态</li>
<li>自动寻找图片中异常的目标</li>
<li>异常消费检测(商业)</li>
<li>劣质产品检测(工业)</li>
<li>缺陷基因检测(医疗)</li>
</ol>
</blockquote>
<h4 id="2-代码实现"><a href="#2-代码实现" class="headerlink" title="2 代码实现"></a>2 代码实现</h4><blockquote>
<p>PCA实战task：<br>1、基于iris_data.csv数据，建立KNN模型实现数据分类（n_neighbors&#x3D;3）<br>2、对数据进行标准化处理，选取一个维度可视化处理后的效果<br>3、进行与原数据等维度PCA，查看各主成分的方差比例<br>4、保留合适的主成分，可视化降维后的数据<br>5、基于降维后数据建立KNN模型，与原数据表现进行对比</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load data</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.read_csv(<span class="hljs-string">&#x27;iris_data.csv&#x27;</span>)<br>data.head()<br><br><span class="hljs-comment"># define the X and y</span><br>X = data.drop([<span class="hljs-string">&#x27;target&#x27;</span>, <span class="hljs-string">&#x27;label&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>y = data.loc[:, <span class="hljs-string">&#x27;label&#x27;</span>]<br>y.head()<br><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br><br>knn = KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>knn.fit(X, y)<br><br>y_pred = knn.predict(X)<br>accuracy_score(y, y_pred)<br><br><span class="hljs-comment"># 数据标准化处理</span><br><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><br>X_norm = StandardScaler().fit_transform(X)<br><span class="hljs-built_in">print</span>(X_norm)<br><br><span class="hljs-comment"># calculate the mean and sigma</span><br>x1_mean = X.loc[:, <span class="hljs-string">&#x27;sepal length&#x27;</span>].mean()<br>x1_sigma = X.loc[:, <span class="hljs-string">&#x27;sepal length&#x27;</span>].std()<br><br>x1_norm_mean = X_norm[:, <span class="hljs-number">0</span>].mean()<br>x1_norm_sigma = X_norm[:, <span class="hljs-number">0</span>].std()<br><br><span class="hljs-built_in">print</span>(x1_mean, x1_sigma)<br><span class="hljs-built_in">print</span>(x1_norm_mean, x1_norm_sigma)<br><br><span class="hljs-comment"># 可视化处理</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>fig1 = plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.hist(X.loc[:, <span class="hljs-string">&#x27;sepal length&#x27;</span>], bins=<span class="hljs-number">100</span>)<br><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.hist(X_norm[:, <span class="hljs-number">0</span>], bins=<span class="hljs-number">100</span>)<br>plt.show()<br><br><span class="hljs-comment"># 检测维度</span><br><span class="hljs-built_in">print</span>(X.shape)<br><br><span class="hljs-comment"># PCA calculate</span><br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br><br>pca_4 = PCA(n_components=<span class="hljs-number">4</span>)<br>X_PCA_4=pca_4.fit_transform(X_norm)<br><br><span class="hljs-comment"># calculate the variance ratio of each principle components</span><br>var_ratio = pca_4.explained_variance_ratio_<br><span class="hljs-built_in">print</span>(var_ratio)<br><br>fig2 = plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">5</span>))<br>plt.bar([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], var_ratio)<br>plt.xticks([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>], [<span class="hljs-string">&#x27;PC1&#x27;</span>, <span class="hljs-string">&#x27;PC2&#x27;</span>, <span class="hljs-string">&#x27;PC3&#x27;</span>, <span class="hljs-string">&#x27;PC4&#x27;</span>])<br>plt.xlabel(<span class="hljs-string">&#x27;Principle Components&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Variance Ratio Of each PC&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># 降维后的数据可视化</span><br>pca_2 = PCA(n_components=<span class="hljs-number">2</span>)<br>X_PCA_2 = pca_2.fit_transform(X_norm)<br>var_ratio_2 = pca_2.explained_variance_ratio_<br><br><span class="hljs-comment"># 降维后的数据可视化</span><br>fig3 = plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))<br>setosa = plt.scatter(X_norm[:, <span class="hljs-number">0</span>][y == <span class="hljs-number">0</span>], X_norm[:, <span class="hljs-number">1</span>][y == <span class="hljs-number">0</span>])<br>versicolor = plt.scatter(X_norm[:, <span class="hljs-number">0</span>][y == <span class="hljs-number">1</span>], X_norm[:, <span class="hljs-number">1</span>][y == <span class="hljs-number">1</span>])<br>virginica = plt.scatter(X_norm[:, <span class="hljs-number">0</span>][y == <span class="hljs-number">2</span>], X_norm[:, <span class="hljs-number">1</span>][y == <span class="hljs-number">2</span>])<br>plt.legend((setosa, versicolor, virginica), [<span class="hljs-string">&#x27;setosa&#x27;</span>, <span class="hljs-string">&#x27;versicolor&#x27;</span>, <span class="hljs-string">&#x27;virginica&#x27;</span>])<br>plt.show()<br><br><span class="hljs-comment"># 基于降维后数据建立KNN模型</span><br>knn_2 = KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>knn_2.fit(X_PCA_2, y)<br><br>y_pred_2 = knn_2.predict(X_PCA_2)<br><br>accuracy_score(y, y_pred_2)<br><br><br></code></pre></td></tr></table></figure>



<h3 id="2-Xgboost"><a href="#2-Xgboost" class="headerlink" title="2 Xgboost"></a>2 Xgboost</h3><h4 id="1-概念"><a href="#1-概念" class="headerlink" title="1 概念"></a>1 概念</h4><p>本质上Xgboost还是一种决策树的集成算法</p>
<h2 id="2-监督式学习"><a href="#2-监督式学习" class="headerlink" title="2 监督式学习"></a>2 监督式学习</h2><h3 id="1-线性回归"><a href="#1-线性回归" class="headerlink" title="1 线性回归"></a>1 线性回归</h3><h4 id="1-1-概念"><a href="#1-1-概念" class="headerlink" title="1.1 概念"></a>1.1 概念</h4><p>回归分析：根据数据，确定两种或两种以上变量间相互依赖的定量关系。</p>
<p>函数表达式：$f(x_{1},x_{2}…x_{n})$</p>
<p>相关分类：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173200091.png" srcset="/img/loading.gif" lazyload alt="image-20250220162540776" style="zoom: 25%;" />



<p>求解步骤：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173201937.png" srcset="/img/loading.gif" lazyload alt="image-20250220162721563" style="zoom: 25%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173204102.png" srcset="/img/loading.gif" lazyload alt="image-20250220162826626" style="zoom: 25%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173206276.png" srcset="/img/loading.gif" lazyload alt="image-20250220162927906" style="zoom: 25%;" />



<h4 id="1-2-实现"><a href="#1-2-实现" class="headerlink" title="1.2 实现"></a>1.2 实现</h4><p><strong>1、使用：</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># a、b(y=ax + b)</span><br><span class="hljs-keyword">from</span> sklearn.linear model<br><span class="hljs-keyword">import</span> LinearRegression<br>lr_model=LinearRegression()<br>lr_model.fit(X,y)<br><br><span class="hljs-comment"># 展示a，b</span><br>a = lr_model.coef_<br>b = lr_model.intercept_<br><br><span class="hljs-comment"># 对新数据做预测</span><br>predictions = lr_model.predict(x_new)<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算y与y&#x27;的均方误差(MSE)、R方值(R2_score):</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> mean_squared_error,r2_socre<br>MSE = mean_squared_error(y, y_predict)<br>R2 =r2_score(y, y_predict)<br><span class="hljs-comment"># 画图对比y 与 y&#x27;可视化模型表现:</span><br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>plt.scatter(y,y<span class="hljs-string">&#x27;)</span><br></code></pre></td></tr></table></figure>

<p><strong>2、图形展示</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 散点图</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br>plt.scatter(x,y)<br><span class="hljs-comment"># 多张图同时展示</span><br><span class="hljs-comment"># 211是将图形分为2行1列，在第1个方块画图</span><br>fig1 = plt.subplot(<span class="hljs-number">211</span>)<br>plt.scatter(x1,y1)<br><span class="hljs-comment"># 212是将图形分为2行1列，在第2个方块画图</span><br>fig2 = plt.subplot(<span class="hljs-number">212</span>)<br>plt.scatter(x2,y2)<br></code></pre></td></tr></table></figure>



<p>步骤总结：</p>
<blockquote>
<ol>
<li>导入工具包：numpy（数据由1D转换为2D）、pandas（加载数据）、 pyplot（画图）</li>
<li>读取数据并设计关系图的分布：设计图的大小、多张图同时展示的分布</li>
<li>训练模型<ul>
<li>训练数据的赋值，即加载X和y</li>
<li>X数据由1D转换为2D，np.array(X).reshape(-1,1)</li>
<li>用X，y加载并训练模型</li>
</ul>
</li>
<li>模型训练好后，再用已有的数据预测，得到预测值</li>
<li>模型评估<ul>
<li>sklearn的导入（from sklearn metrics import mean_squared_error，r2_score）</li>
<li>使用数据</li>
</ul>
</li>
<li>画图呈现，plt.plot（X, y_predict, ‘r’）</li>
</ol>
</blockquote>
<h3 id="2-逻辑回归"><a href="#2-逻辑回归" class="headerlink" title="2 逻辑回归"></a>2 逻辑回归</h3><h4 id="2-1-基本概念"><a href="#2-1-基本概念" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><p>分类：根据已知样本的某些特征，判断新的样本属于哪种已知的样本类。</p>
<p>基本框架：$f(x)&#x3D;\left{ \begin{aligned}y&#x3D; f(x_{1},x_{2}…x_{n}) \ 判断为类别N，如果y &#x3D; n\end{aligned} \right. $</p>
<p>分类方法：逻辑回归、KNN近邻模型、决策树、神经网络。</p>
<blockquote>
<p>逻辑回归：用于解决分类问题的一种模型。根据数据特征或属性，计算其归属于某一类别的概率$P(X)$根据概率数值判断其所属类别。</p>
<p>主要应用场景：二分类问题。</p>
</blockquote>
<blockquote>
<p>逻辑公式（sigmoid）：$P(x)&#x3D;\frac{1}{1+e^{-g(x)}}$， g(x) &#x3D; $\Theta_{0}+\Theta_{1}X_{1}+….$</p>
<p>   $y&#x3D;\left{ \begin{aligned}1, P(x)≥ 0.5 \ 1, P(x)＜ 0.5\end{aligned} \right. $，其中y为类别结果，P为概率分布函数，x为特征值</p>
</blockquote>
<blockquote>
<p>最小损失函数$J$：</p>
<p>​                                                                                      $y&#x3D;\left{ \begin{aligned}-log{P(x_{i})}, ify_{i}&#x3D;1 \ -log(1-P(x_{i})), ify_{i}&#x3D;0\end{aligned} \right. $</p>
<p>化简后：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173210864.png" srcset="/img/loading.gif" lazyload alt="image-20250221154950824" style="zoom: 33%;" />

<p>求解：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173214507.png" srcset="/img/loading.gif" lazyload alt="image-20250221155835458" style="zoom:33%;" /></blockquote>
<blockquote>
<p>sigmoid函数是指一种激活函数，该函数将输入值映射到(0,1)区间，常用于分类问题，尤其是二分类问题中作为逻辑回归的分类器。<strong>它的输出范围有限，优化稳定，便于求导，但存在梯度消失问题</strong>，即在输入值远离原点时，其导数接近于0，导致反向传播时权重更新缓慢。sigmoid函数在早期的神经网络中广泛使用，但随着ReLU等激活函数的出现，其在深层网络中的应用逐渐减少</p>
</blockquote>
<h4 id="2-2-实现步骤"><a href="#2-2-实现步骤" class="headerlink" title="2.2 实现步骤"></a>2.2 实现步骤</h4><blockquote>
<ol>
<li><p>导入工具包：numpy（数据由1D转换为2D）、pandas（加载数据）、 pyplot（画图）</p>
</li>
<li><p>读取数据</p>
</li>
<li><p>分类散点图及可视化</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加标签，区分散点图</span><br>mask = data.loc[:,<span class="hljs-string">&#x27;Pass&#x27;</span>] == <span class="hljs-number">1</span><br><br>fig2 = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>passed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][mask])<br>failed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][~mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][~mask], marker=<span class="hljs-string">&#x27;^&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;Exam1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Exam2&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Exam1 - Exam2&#x27;</span>)<br>plt.legend(handles=[passed, failed], labels=[<span class="hljs-string">&#x27;Passed&#x27;</span>, <span class="hljs-string">&#x27;Failed&#x27;</span>])<br>plt.show()<br></code></pre></td></tr></table></figure>
</li>
<li><p>整理数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">X = data.drop([<span class="hljs-string">&#x27;Pass&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>y = data.loc[:,<span class="hljs-string">&#x27;Pass&#x27;</span>]<br>X1 = X.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>].sort_values()<br>X2 = X.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>]<br>y.head()<br></code></pre></td></tr></table></figure>
</li>
<li><p>训练模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 整理数据集</span><br>X = data.drop([<span class="hljs-string">&#x27;Pass&#x27;</span>], axis=<span class="hljs-number">1</span>)<br>y = data.loc[:,<span class="hljs-string">&#x27;Pass&#x27;</span>]<br>X1 = X.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>].sort_values()<br>X2 = X.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>]<br>y.head()<br><br><span class="hljs-comment"># 导入模型并训练</span><br><span class="hljs-keyword">from</span> sklearn.linear_model <span class="hljs-keyword">import</span> LogisticRegression<br>LR = LogisticRegression()<br>LR.fit(X, y)<br><br></code></pre></td></tr></table></figure>
</li>
<li><p>模型训练好后，再用已有的数据预测，得到新数据集</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 预测结果展示</span><br>y_predict = LR.predict(X)<br><span class="hljs-built_in">print</span>(y_predict)<br></code></pre></td></tr></table></figure>
</li>
<li><p>模型评估</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型性能准确率评估</span><br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br>accuracy = accuracy_score(y, y_predict)<br><span class="hljs-built_in">print</span>(accuracy)<br></code></pre></td></tr></table></figure>
</li>
<li><p>拿到公式</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 拿到公式</span><br>Theta0 = LR.intercept_<br>Theta1,Theta2 = LR.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], LR.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>]<br><span class="hljs-built_in">print</span>(Theta0, Theta1, Theta2)<br>                                                                                                                                                                                                                                                <br>X2_new = -(Theta0 + Theta1 * X1) / Theta2<br>X2_new.head()<br></code></pre></td></tr></table></figure>


</li>
<li><p>使用数据画图呈现，plt.plot（X, y_predict, ‘r’）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">fig3 = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>passed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][mask])<br>failed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][~mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][~mask], marker=<span class="hljs-string">&#x27;^&#x27;</span>)<br>plt.plot(X1, X2_new)<br>plt.xlabel(<span class="hljs-string">&#x27;Exam1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Exam2&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Exam1 - Exam2&#x27;</span>)<br>plt.legend(handles=[passed, failed], labels=[<span class="hljs-string">&#x27;Passed&#x27;</span>, <span class="hljs-string">&#x27;Failed&#x27;</span>])<br></code></pre></td></tr></table></figure></li>
</ol>
</blockquote>
<p>二阶边界模型</p>
<blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python">&gt;<span class="hljs-comment"># 训练二阶边界模型</span><br>&gt;LR2 = LogisticRegression()<br>&gt;LR2.fit(X_new_dict, y)<br><br>&gt;<span class="hljs-comment"># 模型预测</span><br>&gt;y2_predict = LR2.predict(X_new_dict)<br><br>&gt;<span class="hljs-comment"># 模型评估</span><br>&gt;accuracy2 =  accuracy_score(y, y2_predict)<br>&gt;<span class="hljs-built_in">print</span>(accuracy2)<br><br>&gt;<span class="hljs-comment"># 计算公式</span><br>&gt;<span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><br>&gt;Theta0 = LR2.intercept_<br>&gt;Theta1, Theta2, Theta3, Theta4, Theta5 = LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>], LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">2</span>], LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">3</span>],LR2.coef_[<span class="hljs-number">0</span>][<span class="hljs-number">4</span>]<br>&gt;<span class="hljs-built_in">print</span>(Theta0, Theta1, Theta2, Theta3, Theta4, Theta5)<br>&gt;a = Theta4<br>&gt;b = Theta5 * X1 + Theta2<br>&gt;c = Theta0 + Theta1 * X1 + Theta3 * X1 ** <span class="hljs-number">2</span><br><br>&gt;X2_new_boundary = (-b + np.sqrt(b ** <span class="hljs-number">2</span> - <span class="hljs-number">4</span> * a * c)) / (<span class="hljs-number">2</span> * a)<br><br>&gt;<span class="hljs-comment"># 画图呈现</span><br>&gt;fig4 = plt.figure(figsize=(<span class="hljs-number">8</span>, <span class="hljs-number">8</span>))<br>&gt;passed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][mask])<br>&gt;failed = plt.scatter(data.loc[:,<span class="hljs-string">&#x27;Exam1&#x27;</span>][~mask], data.loc[:,<span class="hljs-string">&#x27;Exam2&#x27;</span>][~mask], marker=<span class="hljs-string">&#x27;^&#x27;</span>)<br><br>&gt;plt.plot(X1, X2_new_boundary)<br>&gt;plt.xlabel(<span class="hljs-string">&#x27;Exam1&#x27;</span>)<br>&gt;plt.ylabel(<span class="hljs-string">&#x27;Exam2&#x27;</span>)<br>&gt;plt.title(<span class="hljs-string">&#x27;Exam1 - Exam2&#x27;</span>)<br>&gt;plt.legend(handles=[passed, failed], labels=[<span class="hljs-string">&#x27;Passed&#x27;</span>, <span class="hljs-string">&#x27;Failed&#x27;</span>])<br><br>&gt;plt.show()<br></code></pre></td></tr></table></figure></blockquote>
<h3 id="3-决策树"><a href="#3-决策树" class="headerlink" title="3 决策树"></a>3 决策树</h3><h4 id="1-基本概念-1"><a href="#1-基本概念-1" class="headerlink" title="1 基本概念"></a>1 基本概念</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173444935.png" srcset="/img/loading.gif" lazyload alt="image-20250223100806340" style="zoom: 25%;" />

<blockquote>
<p>决策树（Decision Tree）：一种有监督对实例进行<strong>分类</strong>的<strong>树形结构</strong>，通过<strong>多层判断</strong>区分目标所属类别</p>
<p>本质：通过多层判断，从训练数据集中归纳出一组分类规则。</p>
<p>优点：</p>
<blockquote>
<p>计算量小，运算速度快<br>易于理解，可清晰查看各属性的重要性</p>
</blockquote>
<p>缺点：</p>
<blockquote>
<p>忽略属性间的相关性<br>样本类别分布不均匀时，容易影响模型表现</p>
</blockquote>
<p>求解：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173447212.png" srcset="/img/loading.gif" lazyload alt="image-20250223101640079" style="zoom:33%;" />

<p>三种求解方法：ID3、C4.5、CART</p>
<blockquote>
<p>ID3：利用<strong>信息嫡</strong>原理选择<strong>信息增益最大</strong>的属性作为<strong>分类属性</strong>，递归地拓展决策树的分枝，完成决策树的构造</p>
</blockquote>
<p>信息熵：</p>
<blockquote>
<p>信息嫡（entropy）是度量随机变量不确定性的指标，商越大，变量的不确定性就越大。假定当前样本集合D中第k类样本所占的比例为$P_{k}$，亦则D的信息嫡为：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173449480.png" srcset="/img/loading.gif" lazyload alt="image-20250223102538613" style="zoom:33%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173451723.png" srcset="/img/loading.gif" lazyload alt="image-20250223102609805" style="zoom:33%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173453700.png" srcset="/img/loading.gif" lazyload alt="image-20250223102802335" style="zoom: 25%;" /></blockquote>
</blockquote>
<p>举例：</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173456308.png" srcset="/img/loading.gif" lazyload alt="image-20250223103308740" style="zoom: 25%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173458148.png" srcset="/img/loading.gif" lazyload alt="image-20250223103418760" style="zoom:25%;" />

</blockquote>
<h4 id="2-代码实现-1"><a href="#2-代码实现-1" class="headerlink" title="2 代码实现"></a>2 代码实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#load the data</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>data = pd.read_csv(<span class="hljs-string">&#x27;iris_data.csv&#x27;</span>)<br>data.head()<br><br><span class="hljs-comment">#define the X and y</span><br>X = data.drop([<span class="hljs-string">&#x27;target&#x27;</span>,<span class="hljs-string">&#x27;label&#x27;</span>],axis=<span class="hljs-number">1</span>)<br>y = data.loc[:,<span class="hljs-string">&#x27;label&#x27;</span>]<br><span class="hljs-built_in">print</span>(X.shape,y.shape)<br><br><span class="hljs-comment">#establish the decision tree model</span><br><span class="hljs-keyword">from</span> sklearn <span class="hljs-keyword">import</span> tree<br>dc_tree = tree.DecisionTreeClassifier(criterion=<span class="hljs-string">&#x27;entropy&#x27;</span>,min_samples_leaf=<span class="hljs-number">5</span>)<br>dc_tree.fit(X,y)<br><br><span class="hljs-comment">#evaluate the model</span><br>y_predict = dc_tree.predict(X)<br><span class="hljs-keyword">from</span> sklearn.metrics <span class="hljs-keyword">import</span> accuracy_score<br>accuracy = accuracy_score(y,y_predict)<br><span class="hljs-built_in">print</span>(accuracy)<br><br><span class="hljs-comment">#visualize the tree</span><br>%matplotlib inline<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>fig = plt.figure(figsize=(<span class="hljs-number">20</span>,<span class="hljs-number">20</span>))<br>tree.plot_tree(dc_tree,filled=<span class="hljs-string">&#x27;True&#x27;</span>,feature_names=[<span class="hljs-string">&#x27;SepalLength&#x27;</span>, <span class="hljs-string">&#x27;SepalWidth&#x27;</span>, <span class="hljs-string">&#x27;PetalLength&#x27;</span>, <span class="hljs-string">&#x27;PetalWidth&#x27;</span>],class_names=[<span class="hljs-string">&#x27;setosa&#x27;</span>,<span class="hljs-string">&#x27;versicolor&#x27;</span>,<span class="hljs-string">&#x27;virginica&#x27;</span>])<br><br>dc_tree = tree.DecisionTreeClassifier(criterion=<span class="hljs-string">&#x27;entropy&#x27;</span>,min_samples_leaf=<span class="hljs-number">10</span>)<br>dc_tree.fit(X,y)<br>fig = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>tree.plot_tree(dc_tree,filled=<span class="hljs-string">&#x27;True&#x27;</span>,feature_names=[<span class="hljs-string">&#x27;SepalLength&#x27;</span>, <span class="hljs-string">&#x27;SepalWidth&#x27;</span>, <span class="hljs-string">&#x27;PetalLength&#x27;</span>, <span class="hljs-string">&#x27;PetalWidth&#x27;</span>],class_names=[<span class="hljs-string">&#x27;setosa&#x27;</span>,<span class="hljs-string">&#x27;versicolor&#x27;</span>,<span class="hljs-string">&#x27;virginica&#x27;</span>])<br><br><span class="hljs-keyword">import</span> matplotlib <span class="hljs-keyword">as</span> mpl<br>font2 = &#123;<span class="hljs-string">&#x27;family&#x27;</span> : <span class="hljs-string">&#x27;SimHei&#x27;</span>,<br><span class="hljs-string">&#x27;weight&#x27;</span> : <span class="hljs-string">&#x27;normal&#x27;</span>,<br><span class="hljs-string">&#x27;size&#x27;</span>   : <span class="hljs-number">20</span>,<br>&#125;<br>mpl.rcParams[<span class="hljs-string">&#x27;font.family&#x27;</span>] = <span class="hljs-string">&#x27;SimHei&#x27;</span><br>mpl.rcParams[<span class="hljs-string">&#x27;axes.unicode_minus&#x27;</span>] = <span class="hljs-literal">False</span><br><br>fig = plt.figure(figsize=(<span class="hljs-number">8</span>,<span class="hljs-number">8</span>))<br>tree.plot_tree(dc_tree,filled=<span class="hljs-string">&#x27;True&#x27;</span>,feature_names=[<span class="hljs-string">&#x27;花萼长&#x27;</span>, <span class="hljs-string">&#x27;花萼宽&#x27;</span>, <span class="hljs-string">&#x27;花瓣长&#x27;</span>, <span class="hljs-string">&#x27;花瓣宽&#x27;</span>],class_names=[<span class="hljs-string">&#x27;setosa&#x27;</span>,<span class="hljs-string">&#x27;versicolor&#x27;</span>,<span class="hljs-string">&#x27;virginica&#x27;</span>])<br><br>fig.savefig(<span class="hljs-string">&#x27;test.png&#x27;</span>)<br></code></pre></td></tr></table></figure>



<h2 id="3-无监督学习"><a href="#3-无监督学习" class="headerlink" title="3 无监督学习"></a>3 无监督学习</h2><p>机器学习的一种方法，没有给定事先标记过的训练示例，自动对输入的数据进行分类或分群。</p>
<blockquote>
<p>优点：算法不受监督信息（偏见）的约束，可能考虑到新的信息&gt;A不需要标签数据，极大程度扩大数据样本。</p>
<p><strong>主要应用</strong>：聚类分析（应用最广）、关联规则、维度缩减。</p>
<p><font color = 'red'>聚类分析</font>概念：聚类分析又称为群分析，根据对象某些属性的相似度)将其自动化分为不同的类别。</p>
</blockquote>
<h3 id="1-K-Means聚类"><a href="#1-K-Means聚类" class="headerlink" title="1 K-Means聚类"></a>1 K-Means聚类</h3><h4 id="1-1-基本概念"><a href="#1-1-基本概念" class="headerlink" title="1.1 基本概念"></a>1.1 基本概念</h4><blockquote>
<p><strong>K-Means</strong>：以空间揪个点为中心进行聚类，对最靠近他们的对象归类，是聚类算法中最为基础但也最为重要的算法。</p>
<p><strong>特点</strong>：根据数据与中心点距离划分类别；基于类别数据更新中心点；重复过程直到收敛。</p>
<p><strong>优点</strong>：原理简单、实现容易、收敛快；参数少，方便使用</p>
<p><strong>缺点</strong>：必须设置簇的数量；随机选择初始类聚中心，结果可能缺乏一致性</p>
</blockquote>
<p><strong>公式：</strong></p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173220658.png" srcset="/img/loading.gif" lazyload alt="image-20250222135853451" style="zoom: 33%;" />

<p><strong>算法流程：</strong></p>
<blockquote>
<p>1、选择聚类的个数k</p>
<p>2、确定聚类中心</p>
<p>3、根据点到聚类中心聚类确定各个点所属类别</p>
<p>4、根据各个类别数据更新聚类中心</p>
<p>5、重复以上步骤直到收敛（中心点不再变化）</p>
</blockquote>
<h4 id="1-2-KNN和K-Means区别"><a href="#1-2-KNN和K-Means区别" class="headerlink" title="1.2 KNN和K-Means区别"></a><strong>1.2 KNN和K-Means区别</strong></h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173222815.png" srcset="/img/loading.gif" lazyload alt="image-20250222140608621" style="zoom: 25%;" />

<blockquote>
<p>KNN概念：给定一个训练数据集，对新的输入实例，在训练数据集中找到与该实例最邻近的K个实例（也就是上面所说的K个邻居），这K个实例的多数属于某个类，就把该输入实例分类到这个类中最简单的机器学习算法之一</p>
</blockquote>
<p>KNN代码实现：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br><span class="hljs-keyword">from</span> sklearn.neighbors <span class="hljs-keyword">import</span> KNeighborsClassifier<br>KNN = KNeighborsClassifier(n_neighbors=<span class="hljs-number">3</span>)<br>KNN.fit(X,y)<br></code></pre></td></tr></table></figure>







<h4 id="1-3-实现代码"><a href="#1-3-实现代码" class="headerlink" title="1.3 实现代码"></a>1.3 实现代码</h4><div align=center><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173250584.png" srcset="/img/loading.gif" lazyload alt="image-20250222150421856" style="zoom: 33%;" align=center/><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173252821.png" srcset="/img/loading.gif" lazyload alt="image-20250222150508887" style="zoom:33%;" align=center/></div>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br><span class="hljs-keyword">from</span> sklearn.cluster imyport KMeans<br>KM= KMeans(n_clusters=<span class="hljs-number">3</span>,random _state = <span class="hljs-number">0</span>)<br>KM.fit(X)<br><br><span class="hljs-comment"># 获取模型确定的中心点:</span><br>center=KM.cluster centers<br><span class="hljs-comment"># 准确率计算:from sklearn.metrics import accuracy_score</span><br>accuracy= accuracy_score(y,y predict)<br><br><span class="hljs-comment"># 结果矫正:</span><br>y_cal = []<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> y predict:<br>	<span class="hljs-keyword">if</span> i == <span class="hljs-number">0</span>:<br>        y _cal.append(<span class="hljs-number">2</span>)<br>    <span class="hljs-keyword">elif</span> i == <span class="hljs-number">1</span>:<br>        y_cal.append(<span class="hljs-number">1</span>)<br>    <span class="hljs-keyword">else</span>:<br>        y_cal.append(<span class="hljs-number">0</span>)<br><span class="hljs-built_in">print</span>(y predict,y_cal)<br><br></code></pre></td></tr></table></figure>



<h3 id="2-Meanshift聚类"><a href="#2-Meanshift聚类" class="headerlink" title="2 Meanshift聚类"></a>2 Meanshift聚类</h3><h4 id="2-1-基本概念-1"><a href="#2-1-基本概念-1" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h4><blockquote>
<p>均值漂移聚类：一种基于密度梯度上升的聚类算法（沿着密度上升方向寻找聚类中心点）</p>
<p>特点：</p>
<p>​	1、自动发现类别数量，不需要人工选择</p>
<p>​	2、需要选择区域平径</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173304951.png" srcset="/img/loading.gif" lazyload alt="image-20250222145120555" style="zoom:33%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173306925.png" srcset="/img/loading.gif" lazyload alt="image-20250222145330994" style="zoom: 25%;" />



<h4 id="2-2-实现代码"><a href="#2-2-实现代码" class="headerlink" title="2.2 实现代码"></a>2.2 实现代码</h4><div align=center><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173424668.png" srcset="/img/loading.gif" lazyload alt="image-20250222152712702" style="zoom: 33%;" />
    <img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173427153.png" srcset="/img/loading.gif" lazyload alt="1740209314376" style="zoom:33%;" />
</div>



<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#自动计算带宽(区域半径)</span><br><span class="hljs-keyword">from</span> sklearn.cluster importMeanShift,estimate bandwidth<br><span class="hljs-comment">#detect bandwidth</span><br>bandwidth =estimate_bandwidth(X,n_samples=<span class="hljs-number">500</span>)<br><br><span class="hljs-comment"># 模型建立和训练</span><br>ms = MeanShit(bandwidth = bandwidth)<br>ms.fit(X)<br></code></pre></td></tr></table></figure>



<p>小结：</p>
<blockquote>
<p>kmeans和meanshift  -&gt;  un-supervised -&gt; training data: X</p>
<p>KNN -&gt;  supervised -&gt; training data: X, y</p>
<p>kmeans-&gt; category number</p>
<p>meanshift-&gt; calculate the bandwidth</p>
</blockquote>
<h3 id="3-DBSCAN算法"><a href="#3-DBSCAN算法" class="headerlink" title="3 DBSCAN算法"></a>3 DBSCAN算法</h3><blockquote>
<p>基于密度的空间聚类算法：基于区域点密度筛选有效数据基于有效数据向周边扩张，直到没有新点加入</p>
<p>特点：</p>
<p>​	1、过滤噪音数据</p>
<p>​	2、不需要人为选择类别数量</p>
<p>​	3、数据密度不同时影响结果</p>
</blockquote>
<h3 id="4-异常检测"><a href="#4-异常检测" class="headerlink" title="4 异常检测"></a>4 异常检测</h3><h4 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173501671.png" srcset="/img/loading.gif" lazyload alt="image-20250223104827763" style="zoom:25%;" />

<p>概率密度：</p>
<blockquote>
<p>概率密度函数是一个描述随机变量在某个确定的取值点附近的可能性的函数</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173503771.png" srcset="/img/loading.gif" lazyload alt="image-20250223105146766" style="zoom:25%;" /></blockquote>
<p>高斯分布：</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173505724.png" srcset="/img/loading.gif" lazyload alt="image-20250223105321284" style="zoom:25%;" /></blockquote>
<p>如果高斯分布是高维度的：</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173508080.png" srcset="/img/loading.gif" lazyload alt="image-20250223152029725" style="zoom:50%;" />

<p>1、计算每个维度下数据均值$u_{1},u_{2}…u_{n}$，标准差$σ_{1},σ_{n}…σ_{n}$</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173509832.png" srcset="/img/loading.gif" lazyload alt="image-20250223152101090" style="zoom:33%;" /></blockquote>
<p>2、计算概率密度函数$P(X)$</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173511858.png" srcset="/img/loading.gif" lazyload alt="image-20250223152216754" style="zoom:33%;" /></blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173513801.png" srcset="/img/loading.gif" lazyload alt="image-20250223153137556" style="zoom: 25%;" /></blockquote>
<h4 id="4-2-代码实现"><a href="#4-2-代码实现" class="headerlink" title="4.2 代码实现"></a>4.2 代码实现</h4><blockquote>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs routeros">异常检测实战task：<br>1、基于 anomaly_data.csv数据，可视化数据分布情况、及其对应高斯分布的概率密度函数<br>2、建立模型，实现异常数据点预测<br>3、可视化异常检测处理结果<br>4、修改概率分布阈值EllipticEnvelope(<span class="hljs-attribute">contamination</span>=0.1)中的contamination，查看阈值改变对结果的影响<br></code></pre></td></tr></table></figure></blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-comment">#load the data</span><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><br>data = pd.read_csv(<span class="hljs-string">&#x27;anomaly_data.csv&#x27;</span>)<br>data.head()<br><br><span class="hljs-comment"># visualize the data</span><br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>plt.figure(figsize=(<span class="hljs-number">7</span>, <span class="hljs-number">5</span>))<br>plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>])<br>plt.title(<span class="hljs-string">&quot;Anomaly Data&quot;</span>)<br>plt.xlabel(<span class="hljs-string">&quot;x1&quot;</span>)<br>plt.ylabel(<span class="hljs-string">&quot;x2&quot;</span>)<br>plt.show()<br><br><span class="hljs-comment"># define the x1 and x2</span><br>x1 = data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>]<br>x2 = data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>]<br><br>fig2 =  plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.hist(x1, bins=<span class="hljs-number">100</span>, alpha=<span class="hljs-number">0.5</span>, label=<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;x1 distribution&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;count&#x27;</span>)<br><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.hist(x2, bins=<span class="hljs-number">100</span>, alpha=<span class="hljs-number">0.5</span>, label=<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;x2 distribution&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;count&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># calculate the mean and sigma of x1 and x2</span><br>x1_mean = x1.mean()<br>x1_sigma = x1.std()<br>x2_mean = x2.mean()<br>x2_sigma = x2.std()<br><span class="hljs-built_in">print</span>(x1_mean, x1_sigma, x2_mean, x2_sigma)<br><br><span class="hljs-comment"># calculate the gaussian distribution p(x)</span><br><span class="hljs-keyword">from</span> scipy.stats <span class="hljs-keyword">import</span> norm<br><br>x1_range = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">300</span>)<br>x2_range = np.linspace(<span class="hljs-number">0</span>, <span class="hljs-number">20</span>, <span class="hljs-number">300</span>)<br>x1_normal = norm.pdf(x1_range, loc=x1_mean, scale=x1_sigma)<br>x2_normal = norm.pdf(x2_range, loc=x2_mean, scale=x2_sigma)<br><span class="hljs-built_in">print</span>(x1_range)<br><br><span class="hljs-comment"># visualize the gaussian distribution</span><br>fig3 = plt.figure(figsize=(<span class="hljs-number">20</span>, <span class="hljs-number">5</span>))<br>plt.subplot(<span class="hljs-number">121</span>)<br>plt.plot(x1_range, x1_normal)<br>plt.title(<span class="hljs-string">&#x27;normal P(x1)&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;p(x1)&#x27;</span>)<br><br>plt.subplot(<span class="hljs-number">122</span>)<br>plt.plot(x2_range, x2_normal)<br>plt.title(<span class="hljs-string">&#x27;normal P(x2)&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;p(x2)&#x27;</span>)<br>plt.show()<br><br><span class="hljs-comment"># establish the model and predict</span><br><span class="hljs-keyword">from</span> sklearn.covariance <span class="hljs-keyword">import</span> EllipticEnvelope<br><br>ad_model = EllipticEnvelope()<br>ad_model.fit(data)<br><br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br>y_pred = ad_model.predict(data)<br><span class="hljs-built_in">print</span>(pd.value_counts(y_pred))<br><br><span class="hljs-comment"># visualize the result</span><br>f4 = plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">8</span>))<br>orange_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>], marker=<span class="hljs-string">&#x27;x&#x27;</span>)<br>anomaly_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>, facecolor=<span class="hljs-string">&#x27;none&#x27;</span>,<br>            edgecolor=<span class="hljs-string">&#x27;red&#x27;</span>,s=<span class="hljs-number">120</span>)<br>plt.title(<span class="hljs-string">&#x27;Anomaly Data&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.legend([orange_data, anomaly_data], [<span class="hljs-string">&#x27;orange data&#x27;</span>, <span class="hljs-string">&#x27;anomaly data&#x27;</span>])<br><br>plt.show()<br><br><span class="hljs-comment"># 修改概率分布阈值EllipticEnvelope(contamination=0.1)中的contamination，查看阈值改变对结果的影响</span><br><span class="hljs-keyword">from</span> sklearn.covariance <span class="hljs-keyword">import</span> EllipticEnvelope<br><br>ad_model = EllipticEnvelope(contamination=<span class="hljs-number">0.02</span>)<br>ad_model.fit(data)<br>y_pred = ad_model.predict(data)<br><br>f5 = plt.figure(figsize=(<span class="hljs-number">15</span>, <span class="hljs-number">8</span>))<br>orange_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>], marker=<span class="hljs-string">&#x27;x&#x27;</span>)<br>anomaly_data = plt.scatter(data.loc[:, <span class="hljs-string">&#x27;x1&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], data.loc[:, <span class="hljs-string">&#x27;x2&#x27;</span>][y_pred == -<span class="hljs-number">1</span>], marker=<span class="hljs-string">&#x27;o&#x27;</span>,<br>                           facecolor=<span class="hljs-string">&#x27;none&#x27;</span>,<br>                           edgecolor=<span class="hljs-string">&#x27;red&#x27;</span>, s=<span class="hljs-number">120</span>)<br>plt.title(<span class="hljs-string">&#x27;Anomaly Data&#x27;</span>)<br>plt.xlabel(<span class="hljs-string">&#x27;x1&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;x2&#x27;</span>)<br>plt.legend([orange_data, anomaly_data], [<span class="hljs-string">&#x27;orange data&#x27;</span>, <span class="hljs-string">&#x27;anomaly data&#x27;</span>])<br><br>plt.show()<br><br></code></pre></td></tr></table></figure>



<h2 id="4-半监督学习"><a href="#4-半监督学习" class="headerlink" title="4 半监督学习"></a>4 半监督学习</h2><p>监督学习与无监督学习相结合的一种学习方法，它同时利用有标记样本与无标记样本进行学习。</p>
<p><strong>目的</strong>：在标记样本有限的情况下，尽可能识别出总样本的共同特性。</p>
<p><strong>英文</strong>：Semi-Supervised Learning</p>
<p><strong>伪标签学习</strong>：用有标签数据训练一个分类器，然后用这个分类器对无标签数据进行分类，产生伪标签(pseudo label)，按一定规则挑选出认为分类正确的无标签样本，将其与有标签样本作为数据对分类器进行训练。</p>
<p><strong>核心</strong>：想办法利用标签数据提供的正确信息，灵活运用于模型中。</p>
<h1 id="三-PyTorch框架"><a href="#三-PyTorch框架" class="headerlink" title="三 PyTorch框架"></a>三 PyTorch框架</h1><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173043878.png" srcset="/img/loading.gif" lazyload alt="image-20250322161937108" style="zoom: 33%;" />

<p>首先是确定自己的显卡算力版本，我现在是NVIDIA GeForce GTX 1660 Ti（现在刚买了5070）</p>
<pre><code class="hljs">驱动程序版本:	31.0.15.1601
驱动程序日期:	2022/4/24
DirectX 版本:	12 (FL 12.1)
物理位置：	PCI 总线 1、设备 0、功能 0

利用率	0%
专用 GPU 内存	0.0/6.0 GB
共享 GPU 内存	0.0/7.9 GB
GPU 内存	0.0/13.9 GB
</code></pre>
<p>然后通过命令查看自己<strong>显卡驱动-cuda driver version</strong>的版本号：nvidia-smi</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173049917.png" srcset="/img/loading.gif" lazyload alt="image-20250322105502383" style="zoom: 50%;" />



<p>然后去官网查看自己的<strong>cuda-runtime version</strong>版本：<a target="_blank" rel="noopener" href="https://en.wikipedia.org/wiki/CUDA">CUDA - Wikipedia</a></p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173051862.png" srcset="/img/loading.gif" lazyload alt="image-20250322162928412" style="zoom: 50%;" />

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173054487.png" srcset="/img/loading.gif" lazyload alt="image-20250322163013307"></p>
<p>由此可见我是算力是7.5，支持的cuda-runtime version版本7.5往上的版本均可，为了不造成cuda-runtime version版本过高导致不必要的错误</p>
<p><strong>切记是cuda版本一定要低于硬件11.7的版本！！！</strong></p>
<p><strong>切记是cuda版本一定要低于硬件11.7的版本！！！</strong></p>
<p><strong>切记是cuda版本一定要低于硬件11.7的版本！！！</strong></p>
<h2 id="1-安装"><a href="#1-安装" class="headerlink" title="1 安装"></a>1 安装</h2><p><strong>装这个版本：Anaconda3-2024.02-1-Windows-x86_64.exe！！！</strong></p>
<p><strong>装这个版本：Anaconda3-2024.02-1-Windows-x86_64.exe！！！</strong></p>
<p><strong>装这个版本：Anaconda3-2024.02-1-Windows-x86_64.exe！！！</strong></p>
<p>利用pip install 或者conda安装</p>
<ol>
<li><p>再anaconda创建一个虚拟环境(比如叫 pytorch)</p>
<ul>
<li><p>利用 conda create 指令创建新的虚拟环境</p>
<blockquote>
<p>conda create -n 虚拟环境名字 python&#x3D;版本 </p>
<p>conda create -n pytorch python&#x3D;3.9</p>
</blockquote>
</li>
<li><p>添加镜像加速</p>
<blockquote>
<p>conda create -n 虚拟环境名字 python&#x3D;版本 -c 镜像地址</p>
</blockquote>
<p>相关镜像</p>
<blockquote>
<p>清华镜像：<a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a></p>
<p>北京外国语大学镜像：<a target="_blank" rel="noopener" href="https://mirrors.bfsu.edu.cn/anaconda/pkgs/main">https://mirrors.bfsu.edu.cn/anaconda/pkgs/main</a><br>阿里巴巴镜像：<a target="_blank" rel="noopener" href="http://mirrors.aliyun.com/anaconda/pkgs/main">http://mirrors.aliyun.com/anaconda/pkgs/main</a></p>
</blockquote>
</li>
<li><p>删除虚拟环境：</p>
<blockquote>
<p>conda remove -n 虚拟环境名字 –all</p>
</blockquote>
</li>
<li><p>如何查看配置文件中有哪些通道？</p>
<blockquote>
<p>conda config –get</p>
<p>conda config –show</p>
</blockquote>
</li>
<li><p>持久添加通道：</p>
<blockquote>
<p>conda config –add channels <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/main</a><br>conda config –add channels <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free">https://mirrors.tuna.tsinghua.edu.cn/anaconda/pkgs/free</a><br>conda config –add channels <a target="_blank" rel="noopener" href="https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge">https://mirrors.tuna.tsinghua.edu.cn/anaconda/cloud/conda-forge</a><br>conda config –set show_channel_urls yes</p>
</blockquote>
</li>
<li><p>删除通道：</p>
<blockquote>
<p>conda config –remove channels 通道地址</p>
</blockquote>
</li>
<li><p>清理缓存：</p>
<blockquote>
<p><strong>conda clean –all</strong></p>
</blockquote>
</li>
<li><p>所有镜像</p>
<blockquote>
<p>conda env list</p>
</blockquote>
</li>
</ul>
</li>
<li><p>我选择CUDA11.3（最稳定），官网安装：</p>
</li>
</ol>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># CUDA 11.3</span><br><span class="hljs-attribute">conda</span> install pytorch torchvision torchaudio cudatoolkit=<span class="hljs-number">11</span>.<span class="hljs-number">3</span> -c pytorch<br><br><span class="hljs-comment"># CUDA 11.7</span><br><span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">1</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">14</span>.<span class="hljs-number">0</span> torchaudio==<span class="hljs-number">0</span>.<span class="hljs-number">13</span>.<span class="hljs-number">0</span> pytorch-cuda=<span class="hljs-number">11</span>.<span class="hljs-number">7</span> -c pytorch -c nvidia<br><br><span class="hljs-comment"># CUDA 12.4</span><br><span class="hljs-attribute">conda</span> install pytorch==<span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span> torchvision==<span class="hljs-number">0</span>.<span class="hljs-number">20</span>.<span class="hljs-number">1</span> torchaudio==<span class="hljs-number">2</span>.<span class="hljs-number">5</span>.<span class="hljs-number">1</span> pytorch-cuda=<span class="hljs-number">12</span>.<span class="hljs-number">4</span> -c pytorch -c nvidia<br></code></pre></td></tr></table></figure>



<p>或者方法二：<a target="_blank" rel="noopener" href="https://download.pytorch.org/whl/torch_stable.html">download.pytorch.org&#x2F;whl&#x2F;torch_stable.html</a></p>
<p>直接到对应包连接下载</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173108822.png" srcset="/img/loading.gif" lazyload alt="image-20250327153117089" style="zoom: 33%;" />

<p>放在Scripts目录下pip install “torch-1.10.0+cu113-cp36-cp36m-win_amd64.whl”即可</p>
<ol start="3">
<li>激活对应的虚拟环境(你安装Pytorch的虚拟环境)</li>
</ol>
<figure class="highlight arcade"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs arcade"><span class="hljs-number">1.</span> conda activate 虚拟环境名<br><span class="hljs-number">2.</span> 输入conda list，看有没有pytorch或者torch<br>python<br><span class="hljs-keyword">import</span> torch<br>torch.cuda.is_available()<br><span class="hljs-number">3.</span> 如果显示<span class="hljs-literal">True</span>，就说明我们这个PyTorch安装成功了<br></code></pre></td></tr></table></figure>



<ol start="4">
<li>测试cudnn</li>
</ol>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">python<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-built_in">print</span>(torch.backends.cudnn.version())<br><span class="hljs-comment">#能够正确返回8200</span><br><span class="hljs-keyword">from</span> torch.backends <span class="hljs-keyword">import</span> cudnn <span class="hljs-comment"># 若正常则静默</span><br>cudnn.is_available() <br><span class="hljs-comment"># 若正常返回True</span><br>a=torch.tensor(<span class="hljs-number">1.</span>)<br>cudnn.is_acceptable(a.cuda())<br><span class="hljs-comment"># 若正常返回True</span><br></code></pre></td></tr></table></figure>

<h2 id="2-基本介绍"><a href="#2-基本介绍" class="headerlink" title="2 基本介绍"></a>2 基本介绍</h2><h3 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h3><p>PyTorch 是一种用于构建深度学习模型的功能完备框架，是一种通常用于图像识别和语言处理等应用程序的机器学习。使用 Python 编写，因此对于大多数机器学习开发者而言，学习和使用起来相对简单。PyTorch 的独特之处在于，它完全支持 GPU，并且使用<strong>反向模式自动微分技术计算梯度</strong>，因此可以动态修改计算图形。这使其成为快速实验和原型设计的常用选择</p>
<h3 id="2-2-相关库简介"><a href="#2-2-相关库简介" class="headerlink" title="2.2 相关库简介"></a>2.2 相关库简介</h3><blockquote>
<p>**torchvision：**内置了常用的数据集和常见的模型</p>
</blockquote>
<blockquote>
<p>**transforms：**用来做数据增强，数据预处理等功能</p>
<p>transforms.ToTensor()：</p>
<ol>
<li><p>将图片转换为Tensor</p>
</li>
<li><p>将图片的像素值从[0,255]转换为[0,1]</p>
</li>
<li><p>将图片的通道channel放到第一个维度上</p>
</li>
</ol>
</blockquote>
<blockquote>
<p>pytorch中图片的表现形式**[batch_size, channel, height, width]**</p>
</blockquote>
<blockquote>
<p>#降维squeeze</p>
<p>img &#x3D; np.squeeze(img)</p>
</blockquote>
<h2 id="3-处理技术"><a href="#3-处理技术" class="headerlink" title="3 处理技术"></a>3 处理技术</h2><h3 id="3-1-数据增强"><a href="#3-1-数据增强" class="headerlink" title="3.1 数据增强"></a>3.1 数据增强</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms<br><span class="hljs-comment"># 图片预处理</span><br>train_transforms = transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">224</span>, <span class="hljs-number">224</span>)),<br>    transforms.RandomCrop(<span class="hljs-number">192</span>), <span class="hljs-comment"># 随机裁剪</span><br>    transforms.RandomHorizontalFlip(), <span class="hljs-comment"># 随机水平翻转</span><br>    transforms.RandomVerticalFlip(),  <span class="hljs-comment"># 随机垂直翻转</span><br>    transforms.RandomRotation(<span class="hljs-number">0.4</span>), <span class="hljs-comment"># 随机旋转</span><br>    transforms.ColorJitter(brightness=<span class="hljs-number">0.5</span>, contrast=<span class="hljs-number">0.5</span>), <span class="hljs-comment"># 随机调整亮度、对比度、饱和度、色相</span><br>    transforms.RandomGrayscale(), <span class="hljs-comment"># 转换为灰度图</span><br><br>    <span class="hljs-comment"># toTensor()有三个作用：1、将数据变化为tensor类型；2、将数据归一化到[0,1]；3、将数据的channel提前</span><br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>])<br><br>test_transforms = transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">224</span>, <span class="hljs-number">224</span>)),<br>    <span class="hljs-comment"># toTensor()有三个作用：1、将数据变化为tensor类型；2、将数据归一化到[0,1]；3、将数据的channel提前</span><br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>])<br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">batch_size = <span class="hljs-number">32</span><br><br>train_dataset = torchvision.datasets.ImageFolder(root=train_dir, transform=train_transforms)<br>test_dataset = torchvision.datasets.ImageFolder(root=test_dir, transform=test_transforms)<br><br>train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>

<h3 id="3-2-学习率衰减"><a href="#3-2-学习率衰减" class="headerlink" title="3.2 学习率衰减"></a>3.2 学习率衰减</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">lr_scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=<span class="hljs-number">10</span>, gamma=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure>



<h3 id="3-3-迁移GPU"><a href="#3-3-迁移GPU" class="headerlink" title="3.3 迁移GPU"></a>3.3 迁移GPU</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">device = torch.device(<span class="hljs-string">&quot;cuda:0&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>model = Model().to(device)<br>model<br></code></pre></td></tr></table></figure>

<h3 id="3-4-损失和优化器"><a href="#3-4-损失和优化器" class="headerlink" title="3.4 损失和优化器"></a>3.4 损失和优化器</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定义损失函数和优化器</span><br>lr = <span class="hljs-number">1e-3</span><br>loss_func = nn.CrossEntropyLoss()<br>optimizer = optim.Adam(model.parameters(), lr)<br></code></pre></td></tr></table></figure>



<h3 id="3-5-定义train函数"><a href="#3-5-定义train函数" class="headerlink" title="3.5 定义train函数"></a>3.5 定义train函数</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">epoches, model, train_loader, test_loader</span>):<br>    correct = <span class="hljs-number">0</span><br>    total = <span class="hljs-number">0</span><br>    running_loss = <span class="hljs-number">0</span><br>    model.train()<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_loader:<br>        x, y = x.to(device), y.to(device)<br>        <span class="hljs-comment"># 前向传播</span><br>        y_pred = model(x)<br>        <span class="hljs-comment"># 计算损失</span><br>        loss = loss_func(y_pred, y)<br>        <span class="hljs-comment"># 反向传播</span><br>        optimizer.zero_grad()<br>        loss.backward()<br>        optimizer.step()<br><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-comment"># argmax() 返回最大值的索引，代表真实预测的类别</span><br>            y_pred = torch.argmax(y_pred, dim=<span class="hljs-number">1</span>)<br>            correct += (y_pred == y).<span class="hljs-built_in">sum</span>().item()<br>            total += y.size(<span class="hljs-number">0</span>)<br>            running_loss += loss.item()<br><br>    lr_scheduler.step()<br>    epoch_loss = running_loss / total<br>    epoch_acc = correct / total<br><br>    <span class="hljs-comment"># 测试过程</span><br>    model.<span class="hljs-built_in">eval</span>()<br>    test_correct = <span class="hljs-number">0</span><br>    test_total = <span class="hljs-number">0</span><br>    test_running_loss = <span class="hljs-number">0</span><br>    <span class="hljs-keyword">with</span> torch.no_grad():<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> test_loader:<br>            x, y = x.to(device), y.to(device)<br>            y_pred = model(x)<br>            loss = loss_func(y_pred, y)<br>            y_pred = torch.argmax(y_pred, dim=<span class="hljs-number">1</span>)<br>            test_correct += (y_pred == y).<span class="hljs-built_in">sum</span>().item()<br>            test_total += y.size(<span class="hljs-number">0</span>)<br>            test_running_loss += loss.item()<br><br>    test_epoch_loss = test_running_loss / test_total<br>    test_epoch_acc = test_correct / test_total<br><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;Epoch: &#123;&#125;, Loss: &#123;:.4f&#125;, Acc: &#123;:.4f&#125;, test_Loss: &#123;:.4f&#125;, test_Acc: &#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(epoches + <span class="hljs-number">1</span>, epoch_loss,<br>                                                                                             epoch_acc,<br>                                                                                             test_epoch_loss,<br>                                                                                             test_epoch_acc))<br>    <span class="hljs-keyword">return</span> epoch_loss, epoch_acc, test_epoch_loss, test_epoch_acc<br></code></pre></td></tr></table></figure>



<h3 id="3-6-模型保存与加载"><a href="#3-6-模型保存与加载" class="headerlink" title="3.6 模型保存与加载"></a>3.6 模型保存与加载</h3><p>保存精度最好的模型</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python">epoches = <span class="hljs-number">20</span><br>train_loss = []<br>train_acc = []<br>test_loss = []<br>test_acc = []<br>best_acc = <span class="hljs-number">0.0</span><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoches):<br>    epoch_loss, epoch_acc, test_epoch_loss, test_epoch_acc = train(epoch, model, train_loader, test_loader)<br>    train_loss.append(epoch_loss)<br>    train_acc.append(epoch_acc)<br>    test_loss.append(test_epoch_loss)<br>    test_acc.append(test_epoch_acc)<br><br>    <span class="hljs-keyword">if</span> test_epoch_acc &gt; best_acc:<br>        best_acc = test_epoch_acc<br>        torch.save(model.state_dict(), <span class="hljs-string">&#x27;./vgg16_best_model.pth&#x27;</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;best_acc: &#123;:.4f&#125;&#x27;</span>.<span class="hljs-built_in">format</span>(best_acc))<br></code></pre></td></tr></table></figure>



<p>加载最好的模型并测试</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 恢复保存的模型</span><br>load_model = models.vgg16()<br>load_model.load_state_dict(torch.load(<span class="hljs-string">&quot;vgg16_best_model.pth&quot;</span>), map_location=device)<br></code></pre></td></tr></table></figure>

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250708113323211.png" srcset="/img/loading.gif" lazyload alt="image-20250708113315979"></p>
<h2 id="3-语法"><a href="#3-语法" class="headerlink" title="3 语法"></a>3 语法</h2><p>tensor创建</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">torch.tensor([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], dtype=torch.float32)<br>torch.tensor(np.array([<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>]))<br><br><span class="hljs-comment"># 随机的矩阵创建</span><br>torch.randn((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><br><span class="hljs-comment"># 将numpy的数值转化成tensor格式</span><br>np.random.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>torch.from_numpy(n)<br></code></pre></td></tr></table></figure>

<p>取值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 从归一化的数中进行随机生成</span><br>x = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)<br><span class="hljs-comment"># 取出第一个矩阵的第一行</span><br>x[<span class="hljs-number">0</span>, :, :]<br><span class="hljs-comment"># 取出所有的第一列</span><br>x[:, :, <span class="hljs-number">0</span>]<br><br><span class="hljs-comment"># 取出224 * 224 </span><br>x = torch.rand(<span class="hljs-number">32</span>, <span class="hljs-number">224</span>, <span class="hljs-number">224</span>, <span class="hljs-number">3</span>)<br>x[<span class="hljs-number">0</span>, :, :, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>

<p>运算</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">t = torch.randn((<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br><span class="hljs-comment"># 转置</span><br>t.T<br><br><span class="hljs-comment"># 求逆运算</span><br>torch.inverse(t)<br><br><span class="hljs-comment"># 矩阵乘法</span><br>a1 = torch.randn(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>)<br>a2 = torch.randn(<span class="hljs-number">3</span>, <span class="hljs-number">5</span>)<br>torch.matmul(a1, a2) <span class="hljs-comment"># a1 @ a2</span><br></code></pre></td></tr></table></figure>

<p><font color='red'><strong>自动微分：微分必须是一个标量，不能是向量~~</strong></font></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">x = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>, requires_grad=<span class="hljs-literal">True</span>)<br>y = x + <span class="hljs-number">2</span><br><br><span class="hljs-comment"># 查看能否求梯度</span><br>x.requires_grad<br>x2 = torch.ones(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 不可求导</span><br>x2.requires_grad<br><br>y.grad_fn<br><br>z = y.mean()<br><br><span class="hljs-comment"># 反向传播</span><br>z.backward()<br><br>x.grad<br><br>z = y * y * <span class="hljs-number">3</span><br>out = z.mean()<br>out<br><br>out.backward()<br><br><span class="hljs-built_in">print</span>(y.requires_grad_(<span class="hljs-literal">True</span>))<br></code></pre></td></tr></table></figure>



<h2 id="4-经典算法实现"><a href="#4-经典算法实现" class="headerlink" title="4 经典算法实现"></a>4 经典算法实现</h2><h3 id="4-1-线性回归"><a href="#4-1-线性回归" class="headerlink" title="4.1 线性回归"></a>4.1 线性回归</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch <span class="hljs-keyword">import</span> nn<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>data = pd.read_csv(<span class="hljs-string">&quot;./data/Income1.csv&quot;</span>)<br><br><span class="hljs-comment"># 取出数据</span><br>X = torch.from_numpy(data.Education.values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).<span class="hljs-built_in">type</span>(torch.float32)<br>Y = torch.from_numpy(data.Income.values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)).<span class="hljs-built_in">type</span>(torch.float32)<br><br><span class="hljs-comment"># wx + b</span><br>model = nn.Linear(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># 定义损失函数</span><br>loss_fn = nn.MSELoss()<br><br><span class="hljs-comment"># 定义优化器</span><br>optim = torch.optim.SGD(model.parameters(), lr=<span class="hljs-number">0.001</span>)<br><br><span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5000</span>):<br>    <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(X, Y):<br>        y_pred = model(x)<br>        loss = loss_fn(y_pred, y)<br>        <span class="hljs-comment"># 梯度清理</span><br>        optim.zero_grad()<br>        loss.backward()<br><br>        <span class="hljs-comment"># 更新操作</span><br>        optim.step()<br><br>plt.scatter(data.Education, data.Income)<br>plt.xlabel(<span class="hljs-string">&#x27;Education&#x27;</span>)<br>plt.ylabel(<span class="hljs-string">&#x27;Income&#x27;</span>)<br>plt.plot(X.numpy(), (torch.matmul(X, w) + b).data.numpy(), color=<span class="hljs-string">&#x27;red&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250705204317331.png" srcset="/img/loading.gif" lazyload alt="output" style="zoom:50%;" />

<h3 id="4-2-二分类封装"><a href="#4-2-二分类封装" class="headerlink" title="4.2 二分类封装"></a>4.2 二分类封装</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> TensorDataset, DataLoader<br><span class="hljs-keyword">from</span> sklearn.model_selection <span class="hljs-keyword">import</span> train_test_split<br><br>data = pd.read_csv(<span class="hljs-string">&#x27;./data/HR_comma_sep.csv&#x27;</span>)<br><br>data<br><br><span class="hljs-comment"># 对于离散的字符串，有两种处理方式：1. 将其转化为one-hot编码；2. 将其转化为数值</span><br>data = data.join(pd.get_dummies(data[<span class="hljs-string">&#x27;part&#x27;</span>], dtype=<span class="hljs-built_in">int</span>)).join(pd.get_dummies(data[<span class="hljs-string">&#x27;salary&#x27;</span>], dtype=<span class="hljs-built_in">int</span>))<br><br><span class="hljs-comment"># 把原始的part和salary剔除</span><br>data = data.drop([<span class="hljs-string">&#x27;part&#x27;</span>, <span class="hljs-string">&#x27;salary&#x27;</span>], axis=<span class="hljs-number">1</span>)<br><br>data<br><br>data[<span class="hljs-string">&#x27;left&#x27;</span>].value_counts()<br><br><span class="hljs-comment"># 取出left中所有0的个数除以总数，算出数据比例大致是3：1</span><br>(data[<span class="hljs-string">&#x27;left&#x27;</span>] == <span class="hljs-number">0</span>).<span class="hljs-built_in">sum</span>() / <span class="hljs-built_in">len</span>(data.left)<br><br>Y_numpy = data[<span class="hljs-string">&#x27;left&#x27;</span>].values.reshape(-<span class="hljs-number">1</span>, <span class="hljs-number">1</span>)<br>Y = torch.from_numpy(Y_numpy).<span class="hljs-built_in">type</span>(torch.FloatTensor)<br><br>X_numpy = data[[columns <span class="hljs-keyword">for</span> columns <span class="hljs-keyword">in</span> data.columns <span class="hljs-keyword">if</span> columns != <span class="hljs-string">&#x27;left&#x27;</span>]].values<br>X = torch.from_numpy(X_numpy).<span class="hljs-built_in">type</span>(torch.FloatTensor)<br>X, Y<br><br>X.shape, Y.shape<br><br><span class="hljs-comment"># pytorch中最常用的一种船舰模型的方式</span><br><span class="hljs-comment"># 子类的写法</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">HRModel</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-comment"># 先调用父类的方法</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 定义所需参数</span><br>        <span class="hljs-variable language_">self</span>.linear1 = nn.Linear(<span class="hljs-number">20</span>, <span class="hljs-number">64</span>)<br>        <span class="hljs-variable language_">self</span>.linear2 = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">64</span>)<br>        <span class="hljs-variable language_">self</span>.linear3 = nn.Linear(<span class="hljs-number">64</span>, <span class="hljs-number">1</span>)<br><br>        <span class="hljs-variable language_">self</span>.activate = nn.ReLU()<br>        <span class="hljs-variable language_">self</span>.sigmoid = nn.Sigmoid()<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = <span class="hljs-variable language_">self</span>.linear1(x)<br>        x = <span class="hljs-variable language_">self</span>.activate(x)<br><br>        x = <span class="hljs-variable language_">self</span>.linear2(x)<br>        x = <span class="hljs-variable language_">self</span>.activate(x)<br><br>        x = <span class="hljs-variable language_">self</span>.linear3(x)<br>        x = <span class="hljs-variable language_">self</span>.sigmoid(x)<br>        <span class="hljs-keyword">return</span> x<br><span class="hljs-comment">#%%</span><br>lr = <span class="hljs-number">1e-3</span><br>epoches = <span class="hljs-number">100</span><br>batch_size = <span class="hljs-number">64</span><br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 定义损失函数</span><br>loss_func = nn.BCELoss()<br>steps = <span class="hljs-built_in">len</span>(X) // batch_size<br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 切割数据-&gt;分别创建训练数据和测试数据得dataloader-&gt;训练过程--&gt; 计算准确率</span><br>train_x, test_x, train_y, test_y = train_test_split(X_numpy, Y_numpy)<br><br><span class="hljs-comment"># 数据转化成tensor</span><br>train_x = torch.tensor(train_x, dtype=torch.float32)<br>test_x = torch.tensor(test_x, dtype=torch.float32)<br><br>train_y = torch.tensor(train_y, dtype=torch.float32)<br>test_y = torch.tensor(test_y, dtype=torch.float32)<br><br><span class="hljs-comment"># 创建dataloader和dataset</span><br><span class="hljs-comment"># dataloader可以分批次取数据</span><br><span class="hljs-comment"># dataloader是由dataset创建出来的</span><br>train_ds = TensorDataset(train_x, train_y)<br>train_dl = DataLoader(train_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br><br>test_ds = TensorDataset(test_x, test_y)<br>test_dl = DataLoader(test_ds, batch_size=batch_size * <span class="hljs-number">2</span>, shuffle=<span class="hljs-literal">True</span>)<br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 定义获取模型得函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_model</span>():<br>    model = HRModel()<br>    <span class="hljs-keyword">return</span> model, torch.optim.Adam(model.parameters(), lr=lr)<br><br><br><span class="hljs-comment"># 按批次计算损失</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">loss_batch</span>(<span class="hljs-params">model, loss_func, x, y, optimizer=<span class="hljs-literal">None</span></span>):<br>    loss = loss_func(model(x), y)<br><br>    <span class="hljs-keyword">if</span> optimizer <span class="hljs-keyword">is</span> <span class="hljs-keyword">not</span> <span class="hljs-literal">None</span>:<br>        loss.backward()<br>        optimizer.step()<br>        optimizer.zero_grad()<br>    <span class="hljs-keyword">return</span> loss.item(), <span class="hljs-built_in">len</span>(x)<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">train</span>(<span class="hljs-params">epoches, model, loss_func, optimizer, train_dl, valid_dl</span>):<br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(epoches):<br>        <span class="hljs-comment"># 训练模式</span><br>        model.train()<br>        <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> train_dl:<br>            loss_batch(model, loss_func, x, y, optimizer)<br>        model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            losses, nums = <span class="hljs-built_in">zip</span>(*[loss_batch(model, loss_func, x, y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> valid_dl])<br>        val_loss = np.<span class="hljs-built_in">sum</span>(np.multiply(losses, nums)) / np.<span class="hljs-built_in">sum</span>(nums)<br>        acc_mean = np.mean([accuracy(model(x), y) <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> valid_dl])<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;epoch: <span class="hljs-subst">&#123;epoch&#125;</span>, val_loss: <span class="hljs-subst">&#123;val_loss&#125;</span>, acc_mean: <span class="hljs-subst">&#123;acc_mean&#125;</span>&#x27;</span>)<br><br><br><span class="hljs-comment"># 定义计算准确率的函数</span><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">accuracy</span>(<span class="hljs-params">output, y_true</span>):<br>    <span class="hljs-keyword">return</span> ((output.data.numpy() &gt; <span class="hljs-number">0.5</span>) == y_true.numpy()).mean()<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_data</span>(<span class="hljs-params">train_ds, valid_ds, batch_size</span>):<br>    train_dl = DataLoader(train_ds, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br>    valid_dl = DataLoader(valid_ds, batch_size=batch_size * <span class="hljs-number">2</span>, shuffle=<span class="hljs-literal">True</span>)<br>    <span class="hljs-keyword">return</span> train_dl, valid_dl<br><span class="hljs-comment">#%%</span><br><span class="hljs-comment"># 模型训练简化代码</span><br>train_dl, valid_dl = get_data(train_ds, test_ds, batch_size)<br>model, optimizer = get_model()<br>train(epoches, model, loss_func, optimizer, train_dl, valid_dl)<br></code></pre></td></tr></table></figure>



<h3 id="4-3-CNN网络"><a href="#4-3-CNN网络" class="headerlink" title="4.3 CNN网络"></a>4.3 CNN网络</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms, datasets<br><br><br><span class="hljs-comment"># 数据预处理</span><br>transform = transforms.Compose([<br>    transforms.ToTensor(),<br>    <span class="hljs-comment"># transforms.Normalize((0.1307,), (0.3081,))</span><br>])<br><br><span class="hljs-comment"># 数据集加载</span><br>train_data = datasets.MNIST(root=<span class="hljs-string">&#x27;../dataset&#x27;</span>, train=<span class="hljs-literal">True</span>, transform=transform, download=<span class="hljs-literal">True</span>)<br>test_data = datasets.MNIST(root=<span class="hljs-string">&#x27;../dataset&#x27;</span>, train=<span class="hljs-literal">False</span>, transform=transform)<br><br><br><span class="hljs-comment"># 转化成dataloader方便进行批量处理</span><br>batch_size = <span class="hljs-number">64</span><br><br>train_loader = DataLoader(dataset=train_data, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 测试集不需要shuffle，并且数据不需要进行反向传播，可以将batch_size数值给大一些</span><br>test_loader = DataLoader(dataset=test_data, batch_size=batch_size * <span class="hljs-number">2</span>, shuffle=<span class="hljs-literal">False</span>)<br><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># in: 64  1 28 28   out: 64 16 26 26</span><br>        <span class="hljs-variable language_">self</span>.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)  <span class="hljs-comment"># in: 64 16 26 26   out: 64 16 13 13</span><br>        <span class="hljs-variable language_">self</span>.conv2 = nn.Conv2d(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>)  <span class="hljs-comment"># in: 64 16 13 13   out: 64 32 11 11</span><br>        <span class="hljs-variable language_">self</span>.fc1 = nn.Linear(<span class="hljs-number">32</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>, <span class="hljs-number">128</span>)  <span class="hljs-comment"># in: 64 32  5  5</span><br>        <span class="hljs-variable language_">self</span>.fc2 = nn.Linear(<span class="hljs-number">128</span>, <span class="hljs-number">10</span>)<br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = F.relu(<span class="hljs-variable language_">self</span>.conv1(x))<br>        x = <span class="hljs-variable language_">self</span>.pool(x)<br>        x = F.relu(<span class="hljs-variable language_">self</span>.conv2(x))<br>        x = <span class="hljs-variable language_">self</span>.pool(x)<br><br>        x = x.view(-<span class="hljs-number">1</span>, <span class="hljs-number">32</span> * <span class="hljs-number">5</span> * <span class="hljs-number">5</span>)<br><br>        x = F.relu(<span class="hljs-variable language_">self</span>.fc1(x))<br>        x = <span class="hljs-variable language_">self</span>.fc2(x)<br>        <span class="hljs-keyword">return</span> x<br>    <br>    <br>    <br>device = torch.device(<span class="hljs-string">&#x27;cuda:0&#x27;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;cpu&#x27;</span>)<br>model = Model().to(device)<br>model<br><br><span class="hljs-comment"># 创建损失函数</span><br>loss_func = nn.CrossEntropyLoss()<br><br><span class="hljs-comment"># 创建优化器</span><br>lr = <span class="hljs-number">1e-3</span><br>optimizer = torch.optim.Adam(model.parameters(), lr)<br><br><span class="hljs-comment"># 学习率衰减</span><br>lr_scheduler = optim.lr_scheduler.StepLR(optimizer, step_size=<span class="hljs-number">10</span>, gamma=<span class="hljs-number">0.1</span>)<br></code></pre></td></tr></table></figure>

<p>接下来定义训练函数和开始训练，代码参考 3 技术板块</p>
<p>绘图</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.plot(train_loss, label=<span class="hljs-string">&#x27;train_loss&#x27;</span>)<br>plt.plot(test_loss, label=<span class="hljs-string">&#x27;test_loss&#x27;</span>)<br>plt.plot(train_acc, label=<span class="hljs-string">&#x27;train_acc&#x27;</span>)<br>plt.plot(test_acc, label=<span class="hljs-string">&#x27;test_acc&#x27;</span>)<br>plt.legend()<br>plt.show()<br></code></pre></td></tr></table></figure>



<h2 id="5-实战"><a href="#5-实战" class="headerlink" title="5 实战"></a>5 实战</h2><h3 id="5-1-天气分类（手写版）"><a href="#5-1-天气分类（手写版）" class="headerlink" title="5.1 天气分类（手写版）"></a>5.1 天气分类（手写版）</h3><p>导入包</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> shutil<br><span class="hljs-keyword">import</span> torchvision<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> torch.optim <span class="hljs-keyword">as</span> optim<br><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br></code></pre></td></tr></table></figure>

<p>数据准备</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python">base_dir = <span class="hljs-string">&#x27;../dataset/weather&#x27;</span><br>train_dir = os.path.join(base_dir, <span class="hljs-string">&#x27;train&#x27;</span>)<br>test_dir = os.path.join(base_dir, <span class="hljs-string">&#x27;test&#x27;</span>)<br><br>species = [<span class="hljs-string">&#x27;cloudy&#x27;</span>, <span class="hljs-string">&#x27;rain&#x27;</span>, <span class="hljs-string">&#x27;shine&#x27;</span>, <span class="hljs-string">&#x27;sunrise&#x27;</span>]<br><br><span class="hljs-comment"># 获取所有图片列表</span><br>filenames = os.listdir(base_dir)<br><br><span class="hljs-comment"># 创建train和test目录</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(train_dir):<br>    os.mkdir(train_dir)<br><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(test_dir):<br>    os.mkdir(test_dir)<br>    <br><span class="hljs-comment"># 先判断是否存在，如果不存在的话，在train_dir和test_dir中分别创建species目录</span><br><span class="hljs-keyword">for</span> species_name <span class="hljs-keyword">in</span> species:<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(os.path.join(train_dir, species_name)):<br>        os.mkdir(os.path.join(train_dir, species_name))<br>    <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(os.path.join(test_dir, species_name)):<br>        os.mkdir(os.path.join(test_dir, species_name))<br></code></pre></td></tr></table></figure>

<p>图片转移到对应数据目录：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 将dataset/weather中的图片分别移动到train和test目录中</span><br><span class="hljs-comment"># 其中i是每隔五个将数据放入test集中</span><br><span class="hljs-keyword">for</span> i, img <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(filenames):<br>    <span class="hljs-keyword">for</span> species_name <span class="hljs-keyword">in</span> species:<br>        <span class="hljs-keyword">if</span> species_name <span class="hljs-keyword">in</span> img:<br>            img_source_path = os.path.join(base_dir, img)<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                img_target_path = os.path.join(test_dir, species_name, img)<br>            <span class="hljs-keyword">else</span>:<br>                img_target_path = os.path.join(train_dir, species_name, img)<br><br>            shutil.copy(img_source_path, img_target_path)<br></code></pre></td></tr></table></figure>

<p>查看train和test目录中的图片数量</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> train_or_test <span class="hljs-keyword">in</span> [<span class="hljs-string">&#x27;train&#x27;</span>, <span class="hljs-string">&#x27;test&#x27;</span>]:<br>    <span class="hljs-keyword">for</span> species_name <span class="hljs-keyword">in</span> species:<br>        <span class="hljs-built_in">print</span>(train_or_test, species_name, <span class="hljs-built_in">len</span>(os.listdir(os.path.join(base_dir, train_or_test, species_name))))<br></code></pre></td></tr></table></figure>

<p>图片增强</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 图片预处理</span><br>transforms = transforms.Compose([<br>    transforms.Resize((<span class="hljs-number">96</span>, <span class="hljs-number">96</span>)),<br>    transforms.RandomCrop(<span class="hljs-number">96</span>),<br>    transforms.RandomHorizontalFlip(),<br>    transforms.RandomVerticalFlip(),<br>    <span class="hljs-comment"># toTensor()有三个作用：1、将数据变化为tensor类型；2、将数据归一化到[0,1]；3、将数据的channel提前</span><br>    transforms.ToTensor(),<br>    transforms.Normalize(mean=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>], std=[<span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>, <span class="hljs-number">0.5</span>])<br>])<br></code></pre></td></tr></table></figure>

<p>数据加载</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">train_dataset = torchvision.datasets.ImageFolder(root=train_dir, transform=transforms)<br>test_dataset = torchvision.datasets.ImageFolder(root=test_dir, transform=transforms)<br><br>batch_size = <span class="hljs-number">32</span><br><br>train_loader = torch.utils.data.DataLoader(dataset=train_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">True</span>)<br>test_loader = torch.utils.data.DataLoader(dataset=test_dataset, batch_size=batch_size, shuffle=<span class="hljs-literal">False</span>, drop_last=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<p>模型定义</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 添加BN层</span><br><span class="hljs-comment"># 定义网络</span><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Model</span>(nn.Module):<br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">__init__</span>(<span class="hljs-params">self</span>):<br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-variable language_">self</span>.conv1 = nn.Conv2d(<span class="hljs-number">3</span>, <span class="hljs-number">16</span>, <span class="hljs-number">3</span>)    <span class="hljs-comment"># 16 * 94 * 94</span><br>        <span class="hljs-variable language_">self</span>.bn1 = nn.BatchNorm2d(<span class="hljs-number">16</span>)<br>        <span class="hljs-variable language_">self</span>.pool = nn.MaxPool2d(<span class="hljs-number">2</span>, <span class="hljs-number">2</span>)      <span class="hljs-comment"># 16 * 47 * 47</span><br><br>        <span class="hljs-variable language_">self</span>.conv2 = nn.Conv2d(<span class="hljs-number">16</span>, <span class="hljs-number">32</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 32 * 45 * 45 --&gt; 32 * 22 * 22</span><br>        <span class="hljs-variable language_">self</span>.bn2 = nn.BatchNorm2d(<span class="hljs-number">32</span>)<br><br>        <span class="hljs-variable language_">self</span>.conv3 = nn.Conv2d(<span class="hljs-number">32</span>, <span class="hljs-number">64</span>, <span class="hljs-number">3</span>)   <span class="hljs-comment"># 64 * 20 * 20 --&gt; 64 * 10 * 10</span><br>        <span class="hljs-variable language_">self</span>.bn3 = nn.BatchNorm2d(<span class="hljs-number">64</span>)<br><br>        <span class="hljs-variable language_">self</span>.dropout = nn.Dropout()<br><br>        <span class="hljs-comment"># 全连接层</span><br>        <span class="hljs-variable language_">self</span>.fc1 = nn.Linear(<span class="hljs-number">64</span> * <span class="hljs-number">10</span> * <span class="hljs-number">10</span>, <span class="hljs-number">1024</span>)<br>        <span class="hljs-variable language_">self</span>.bn_fc1 = nn.BatchNorm1d(<span class="hljs-number">1024</span>)<br>        <span class="hljs-variable language_">self</span>.fc2 = nn.Linear(<span class="hljs-number">1024</span>, <span class="hljs-number">256</span>)<br>        <span class="hljs-variable language_">self</span>.bn_fc2 = nn.BatchNorm1d(<span class="hljs-number">256</span>)<br>        <span class="hljs-variable language_">self</span>.fc3 = nn.Linear(<span class="hljs-number">256</span>, <span class="hljs-number">4</span>)<br><br><br>    <span class="hljs-keyword">def</span> <span class="hljs-title function_">forward</span>(<span class="hljs-params">self, x</span>):<br>        x = <span class="hljs-variable language_">self</span>.pool(<span class="hljs-variable language_">self</span>.bn1(F.relu(<span class="hljs-variable language_">self</span>.conv1(x))))<br>        x = <span class="hljs-variable language_">self</span>.pool(<span class="hljs-variable language_">self</span>.bn2(F.relu(<span class="hljs-variable language_">self</span>.conv2(x))))<br>        x = <span class="hljs-variable language_">self</span>.pool(<span class="hljs-variable language_">self</span>.bn3(F.relu(<span class="hljs-variable language_">self</span>.conv3(x))))<br><br>        <span class="hljs-comment"># x = x.view(-1, 64 * 10 * 10)</span><br>        x = nn.Flatten()(x)<br><br>        x = <span class="hljs-variable language_">self</span>.bn_fc1(F.relu(<span class="hljs-variable language_">self</span>.fc1(x)))<br>        x = <span class="hljs-variable language_">self</span>.dropout(x)<br>        x = <span class="hljs-variable language_">self</span>.bn_fc2(F.relu(<span class="hljs-variable language_">self</span>.fc2(x)))<br>        x = <span class="hljs-variable language_">self</span>.dropout(x)<br>        x = <span class="hljs-variable language_">self</span>.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure>

<p>转移GPU</p>
<p>定义损失函数和优化器</p>
<p>最后训练函数定义，和开始训练，代码参考第三节</p>
<h3 id="5-1-迁移学习"><a href="#5-1-迁移学习" class="headerlink" title="5.1 迁移学习"></a>5.1 迁移学习</h3><p>仅需更换model如下即可：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 导入预训练好的模型</span><br>os.environ[<span class="hljs-string">&#x27;TORCH_HOME&#x27;</span>] = <span class="hljs-string">&#x27;../dataset&#x27;</span><br>model = models.vgg16(weights=models.VGG16_Weights.IMAGENET1K_V1)<br><br><span class="hljs-keyword">for</span> param <span class="hljs-keyword">in</span> model.features.parameters():<br>    param.requires_grad = <span class="hljs-literal">False</span><br><br>model.classifier[-<span class="hljs-number">1</span>].out_features = <span class="hljs-number">4</span><br></code></pre></td></tr></table></figure>



<h2 id="6-tensorboard"><a href="#6-tensorboard" class="headerlink" title="6 tensorboard"></a>6 tensorboard</h2><h3 id="6-1-安装"><a href="#6-1-安装" class="headerlink" title="6.1 安装"></a>6.1 安装</h3><blockquote>
<p>pip install tensorboard</p>
</blockquote>
<h3 id="6-2-使用"><a href="#6-2-使用" class="headerlink" title="6.2 使用"></a>6.2 使用</h3><p>创建总体文件</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> torch.utils.tensorboard <span class="hljs-keyword">import</span> SummaryWriter<br><br><span class="hljs-comment"># default `log_dir` is &quot;runs&quot; - we&#x27;ll be more specific here</span><br>writer = SummaryWriter(<span class="hljs-string">&#x27;runs/fashion_mnist_experiment_1&#x27;</span>)<br></code></pre></td></tr></table></figure>



<p>写入数据</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python">dataiter = <span class="hljs-built_in">iter</span>(trainloader)<br>images, labels = <span class="hljs-built_in">next</span>(dataiter)<br><br><span class="hljs-comment"># create grid of images</span><br>img_grid = torchvision.utils.make_grid(images)<br><br><span class="hljs-comment"># show images</span><br>matplotlib_imshow(img_grid, one_channel=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># write to tensorboard</span><br>writer.add_image(<span class="hljs-string">&#x27;four_fashion_mnist_images&#x27;</span>, img_grid)<br></code></pre></td></tr></table></figure>



<p>运行</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">tensorboard --logdir=runs<br></code></pre></td></tr></table></figure>

<p>添加模型查看</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">writer.add_graph(net, images)<br>writer.close()<br></code></pre></td></tr></table></figure>

<p>等等详情请看官网：<a target="_blank" rel="noopener" href="https://pytorch.ac.cn/tutorials/intermediate/tensorboard_tutorial.html">使用 TensorBoard 可视化模型、数据和训练 — PyTorch 教程 2.7.0+cu126 文档 - PyTorch 深度学习库</a></p>
<h1 id="四-深度学习"><a href="#四-深度学习" class="headerlink" title="四 深度学习"></a>四 深度学习</h1><h2 id="1-多层感知器-MLP"><a href="#1-多层感知器-MLP" class="headerlink" title="1 多层感知器(MLP)"></a>1 多层感知器(MLP)</h2><p>​	感知机（perceptron）是<strong>二分类的线性分类模型</strong>，属于监督学习算法。输入为实例的特征向量，输出为实例的类别（取+1和-1）。感知机<font color='red'><strong>旨在求出将输入空间中的实例划分为两类的分离超平面</strong></font>。为求得超平面，感知机导入了基于误分类的损失函数，利用<strong>梯度下降法</strong>对损失函数进行最优化求解。</p>
<p>​	<strong>多层感知器</strong>（英语：Multilayer Perceptron，缩写：<strong>MLP</strong>）是一种前向结构的人工神经网络，映射一组输入向量到一组输出向量，一种被称为反向传播算法的监督学习方法常被用来训练MLP。</p>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173521155.png" srcset="/img/loading.gif" lazyload alt="image-20250227213130151" style="zoom:30%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173523532.png" srcset="/img/loading.gif" lazyload alt="image-20250227213832655" style="zoom:25%;" /></p>
<p><strong>同或门函数：</strong></p>
<blockquote>
<p>y : $x_{1} OR x_{2}$ ，其中有一个为1，那就是1。</p>
<p><strong>函数表达式为</strong>：$h(\Theta,x)&#x3D;g(-10+15x_{1}+15x_{2})$</p>
</blockquote>
<p><strong>与门函数：</strong></p>
<blockquote>
<p>y : $x_{1} AND x_{2}$ ，只有两个同时为1时候才是1。</p>
<p><strong>函数表达式为</strong>：$h(\Theta,x)&#x3D;g(-20+15x_{1}+15x_{2})$</p>
<p>y : $(NOT x_{1}) AND (NOT x_{2})$ ，只有两个同时为0时候才是1。</p>
<p><strong>函数表达式为</strong>：$h(\Theta,x)&#x3D;g(5-10x_{1}-10x_{2})$</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173527711.png" srcset="/img/loading.gif" lazyload alt="image-20250227215536679" style="zoom:33%;" />



<blockquote>
<p>问题:在建立MLP模型实现图像多分类任务中，其流程应该是怎么样的？（B A C E F D）</p>
<p>A、对输入数据进行维度转换与归一化处理</p>
<p>B、加载图片并将其转换为数字矩阵</p>
<p>C、建立MLP模型结构</p>
<p>D、对输出结果进行格式转化</p>
<p>E、MLP模型训练参数配置</p>
<p>F、模型训练与预测</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 建立一个Sequential顺序模型</span><br><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br>model = Sequential()<br><br><span class="hljs-comment"># 通过.add()叠加各层网络</span><br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense<br>model.add(Dense(units=<span class="hljs-number">3</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>, <span class="hljs-built_in">input</span> dim=<span class="hljs-number">3</span>))<br>model.add(Dense(units=<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>))<br><br><span class="hljs-comment">#通过.compile()配置模型求解过程参数</span><br>model.<span class="hljs-built_in">compile</span>(loss=<span class="hljs-string">&#x27;categorical_crossentropy&#x27;</span>, optimizer=<span class="hljs-string">&#x27;sgd&#x27;</span>)<br><br><span class="hljs-comment">#训练模型</span><br>model.fit(x_train, y_train, epochs=<span class="hljs-number">5</span>)<br></code></pre></td></tr></table></figure>



<h2 id="2-卷积神经网络"><a href="#2-卷积神经网络" class="headerlink" title="2 卷积神经网络"></a>2 卷积神经网络</h2><h3 id="2-1-基本概念-2"><a href="#2-1-基本概念-2" class="headerlink" title="2.1 基本概念"></a>2.1 基本概念</h3><p>对MLP的处理是否可能进一步减少训练参数数量?<br>办法：提取出图像中的关键信息(轮廓)，再建立MLP模型进行训练——即图像卷积运算</p>
<h4 id="2-1-1-卷积层：图像卷积运算（CNN）"><a href="#2-1-1-卷积层：图像卷积运算（CNN）" class="headerlink" title="2.1.1 卷积层：图像卷积运算（CNN）"></a>2.1.1 卷积层：图像卷积运算（CNN）</h4><blockquote>
<p>对图像矩阵与滤波器矩阵进行对应相乘再求和运算，转化得到新的矩阵。</p>
<p><strong>作用：快速定位图像中某些边缘特征</strong></p>
<p><strong>A与B的卷积通常表示为：A * B 或 convolution(A, B)</strong></p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173531314.png" srcset="/img/loading.gif" lazyload alt="image-20250301184958130" style="zoom:33%;" /></blockquote>
<h4 id="2-1-2-池化层：实现维度缩减"><a href="#2-1-2-池化层：实现维度缩减" class="headerlink" title="2.1.2 池化层：实现维度缩减"></a>2.1.2 池化层：实现维度缩减</h4><blockquote>
<p>池化：按照一个固定规则对图像矩阵进行处理，将其转换为更低维度的矩阵</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173533637.png" srcset="/img/loading.gif" lazyload alt="image-20250301190859364" style="zoom: 25%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173536011.png" srcset="/img/loading.gif" lazyload alt="image-20250301191247087" style="zoom:25%;" />



<p><strong>卷积神经网络两大特点：</strong></p>
<blockquote>
<p>参数共享（parameter sharing)：同一个特征过滤器可用于整张图片<br>稀疏连接（sparsity of connections)：生成的特征图片每个节点只与原图片中特定节点连接</p>
</blockquote>
<p>**图像填充：**通过在图像各边增加像素，使其在进行卷积运算后维持原图大小。通过padding增加像素的数量，由过滤器尺气<br>stride决定。</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173538298.png" srcset="/img/loading.gif" lazyload alt="image-20250301195714897" style="zoom:33%;" />



<p><strong>轮廓过滤器</strong></p>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173542027.png" srcset="/img/loading.gif" lazyload alt="image-20250301185647018" style="zoom: 56%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173545123.png" srcset="/img/loading.gif" lazyload alt="image-20250301185315331" style="zoom:33%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173548919.png" srcset="/img/loading.gif" lazyload alt="image-20250301185425962" style="zoom:33%;" /></p>
<p><strong>RGB的图像卷积</strong></p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173552051.png" srcset="/img/loading.gif" lazyload alt="image-20250301190604625" style="zoom:33%;" />



<p><strong>通道计算</strong></p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173556237.png" srcset="/img/loading.gif" lazyload alt="image-20250331171957836" style="zoom:50%;" />

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173558617.png" srcset="/img/loading.gif" lazyload alt="image-20250301194859458" style="zoom:55%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173600830.png" srcset="/img/loading.gif" lazyload alt="image-20250301194937544" style="zoom: 80%;" /></p>
<h3 id="2-2-经典CNN模型"><a href="#2-2-经典CNN模型" class="headerlink" title="2.2 经典CNN模型"></a>2.2 经典CNN模型</h3><h4 id="2-2-1-LeNet-5"><a href="#2-2-1-LeNet-5" class="headerlink" title="2.2.1 LeNet-5"></a>2.2.1 LeNet-5</h4><p>操作：</p>
<blockquote>
<p>输入图像：32 ×32灰度图，1个通道(channel)<br>训练参数：约60,000个</p>
</blockquote>
<p>特点：</p>
<blockquote>
<p>1、随着网络越深，图像的高度和宽度在缩小，通道数在增加<br>2、卷积与池化先后成对使用</p>
</blockquote>
<p>流程图：</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173607634.png" srcset="/img/loading.gif" lazyload alt="image-20250301200543151" style="zoom:33%;" /></blockquote>
<h4 id="2-2-2-AlexNet"><a href="#2-2-2-AlexNet" class="headerlink" title="2.2.2 AlexNet"></a>2.2.2 AlexNet</h4><p>操作：</p>
<blockquote>
<p>输入图像：227×227×3 <strong>RGB图</strong>，3个通道</p>
<p>训练参数：约60,000,000个</p>
</blockquote>
<p>特点：</p>
<blockquote>
<p>1、适用于识别较为复杂的彩色图，可识别1000种类别<br>2、结构比LeNet更为复杂，使用Relu作为激活函数</p>
</blockquote>
<p>流程图：</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173610592.png" srcset="/img/loading.gif" lazyload alt="image-20250301202409445" style="zoom:25%;" /></blockquote>
<p>意义：</p>
<blockquote>
<p>学术界开始相信深度学习技术，在计算机视觉应用中可以得到很不错的结果。</p>
</blockquote>
<h4 id="2-2-3-VGG-16"><a href="#2-2-3-VGG-16" class="headerlink" title="2.2.3 VGG-16"></a>2.2.3 VGG-16</h4><p>操作：</p>
<blockquote>
<p>输入图像：227×227× 3 RGB图，3个通道</p>
<p>训练参数：约138,000,000个</p>
</blockquote>
<p>特点：</p>
<blockquote>
<p>1、所有卷积层filter 宽和高都是3，步长为1，padding 都使用same convolution（相同的卷积操作保证数据的稳定性）；<br>2、所有池化层的filter 宽和高都是2，步长都是2;<br>3、相比AlexNet，有更多的filter用于提取轮廓信息，具有更高精准性</p>
</blockquote>
<p>流程图：</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173616049.png" srcset="/img/loading.gif" lazyload alt="image-20250301203705907" style="zoom:33%;" /></blockquote>
<h3 id="2-3-实战"><a href="#2-3-实战" class="headerlink" title="2.3 实战"></a>2.3 实战</h3><h4 id="2-3-1建立CNN实现猫狗识别"><a href="#2-3-1建立CNN实现猫狗识别" class="headerlink" title="2.3.1建立CNN实现猫狗识别"></a>2.3.1建立CNN实现猫狗识别</h4><blockquote>
<p>图片加载</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> lmageDataGenerator<br><span class="hljs-comment"># 图像增强/预处理配置(数值归一化、缩放、旋转、平移等)</span><br>train_datagen = lmageDataGenerator(rescale = <span class="hljs-number">1.</span>/<span class="hljs-number">255</span>)<br><span class="hljs-comment"># 加载图像:</span><br>training <span class="hljs-built_in">set</span> = train datagen.flow <span class="hljs-keyword">from</span> directory(<span class="hljs-string">&quot;./Dataset/training set, target_size =(50,50), batch_size = 32, class_mode = &#x27;binary&#x27;)</span><br></code></pre></td></tr></table></figure>

<blockquote>
<p>建立CNN模型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.models <span class="hljs-keyword">import</span> Sequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Conv2D,MaxPooling2D, Flatten,Dense<br><br>model = Sequential()<br><span class="hljs-comment">#卷积层</span><br>model.add(Conv2D(<span class="hljs-number">32</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>),input_shape = (<span class="hljs-number">50</span>,<span class="hljs-number">50</span>,<span class="hljs-number">3</span>), activation = <span class="hljs-string">&#x27;relu&#x27;</span>))<br><span class="hljs-comment">#池化层</span><br>model.add(MaxPooling2D(pool_size =(<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><br><span class="hljs-comment">#第二个卷积、池化层</span><br>model.add(Conv2D(<span class="hljs-number">32</span>, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>), activation = <span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(MaxPooling2D(pool_size = (<span class="hljs-number">2</span>,<span class="hljs-number">2</span>)))<br><span class="hljs-comment">#Flattening层</span><br>model.add(Flatten())<br><span class="hljs-comment">#全连接层</span><br>model.add(Dense(units = <span class="hljs-number">128</span>, activation = <span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(units = <span class="hljs-number">1</span>, activation = <span class="hljs-string">&#x27;sigmoid&#x27;</span>))<br><br></code></pre></td></tr></table></figure>

<blockquote>
<p>训练与预测：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 配置模型</span><br>model.<span class="hljs-built_in">compile</span>(optimizer = <span class="hljs-string">&#x27;adam&#x27;</span>, loss = <span class="hljs-string">&#x27;binary_crossentropy&#x27;</span>, metrics = [<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment"># 查看模型结构</span><br>model.summary()<br><span class="hljs-comment">#训练模型</span><br>model.fit_generator(training_set,epochs = <span class="hljs-number">25</span>)<br><span class="hljs-comment">#计算预测准确率</span><br>model.evaluate_generator(training_set)<br><br></code></pre></td></tr></table></figure>



<h4 id="2-3-2-基于VGG-16、结合MLP实现猫狗识别"><a href="#2-3-2-基于VGG-16、结合MLP实现猫狗识别" class="headerlink" title="2.3.2 基于VGG-16、结合MLP实现猫狗识别"></a>2.3.2 基于VGG-16、结合MLP实现猫狗识别</h4><blockquote>
<p>图片加载：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> img_to_array, load_img<br>img_path = <span class="hljs-string">&#x27;1.jpg&#x27;</span><br>img = load_img(img_path, target_size=(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br>img = img_to_array(img)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>图片预处理：</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> preprocess_input<br>x = np.expand_dims(img, axis=<span class="hljs-number">0</span>)<br><span class="hljs-comment">#把图片矩阵转化为可用于VGG16输入的矩阵</span><br>x = preprocess_input(x)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>载入VGG16结构（去除全连接层)∶</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> VGG16<br>model_vgg = vGG16(weights=<span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>特征提取</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">features = model_vgg.predict(x)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>建立mlp模型</p>
</blockquote>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#建立一个Sequential顺序模型并添加各层from keras.models import Sequentialmodel = Sequential()</span><br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense<br>model.add(Dense(units=<span class="hljs-number">10</span>, activation= <span class="hljs-string">&#x27;relu&#x27;</span>, input_dim=<span class="hljs-number">25088</span>))<br>model.add(Dense(units=<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;sigmoid&#x27;</span>))<br>model.summary()<br><span class="hljs-comment">#通过.compile()配置模型求解过程参数</span><br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,loss=<span class="hljs-string">&#x27;binatiry_crossentropy&#x27;</span>, metrics=[<span class="hljs-string">&#x27;accuracy&#x27;</span>])<br><span class="hljs-comment">#训练模型</span><br>model.fit(X_train, y_train, epochs=<span class="hljs-number">50</span>)<br></code></pre></td></tr></table></figure>



<h2 id="3-循环神经网络RNN"><a href="#3-循环神经网络RNN" class="headerlink" title="3 循环神经网络RNN"></a>3 循环神经网络RNN</h2><h3 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h3><p>序列模型：</p>
<blockquote>
<p>输入或者输出中包含有序列数据的模型</p>
<p>两大特点：</p>
<ol>
<li>输入（输出）元素之间是具有顺序关系。不同的顺序，得到的结果应该是不同的，比如“不吃饭”和“吃饭不”这两个短语的意思是不同的</li>
<li>输入输出不定长。比如文章生成、聊天机器人</li>
</ol>
</blockquote>
<blockquote>
<p>应用场景：语音识别、翻译、股价预测、行为预测</p>
</blockquote>
<h3 id="3-2-常见结构"><a href="#3-2-常见结构" class="headerlink" title="3.2 常见结构"></a>3.2 常见结构</h3><p>结构一：多输入多输出</p>
<blockquote>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173620915.png" srcset="/img/loading.gif" lazyload alt="image-20250303173149107" style="zoom: 25%;" /><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173623264.png" srcset="/img/loading.gif" lazyload alt="image-20250303174355242" style="zoom:23%;" /></p>
</blockquote>
<p>结构二：一对多，多对一</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173626343.png" srcset="/img/loading.gif" lazyload alt="image-20250303174222083" style="zoom:23%;" /></blockquote>
<h3 id="3-2-LSTM"><a href="#3-2-LSTM" class="headerlink" title="3.2 LSTM"></a>3.2 LSTM</h3><p>目的：为解决前部序列信息距离远丢失信息多的问题</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173628923.png" srcset="/img/loading.gif" lazyload alt="image-20250303174947897" style="zoom:25%;" /></blockquote>
<p>结构：</p>
<blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173631035.png" srcset="/img/loading.gif" lazyload alt="image-20250303175226965" style="zoom:25%;" /></blockquote>
<p>特点：</p>
<blockquote>
<p>在网络结构很深(很多层)的情况下，也能保留重要信息;</p>
<p>解决了普通RNN求解过程中的梯度消失问题；解决长期依赖问题，通过引入记忆单元和门控制机制来控制信息得流动</p>
</blockquote>
<p>应用场景：</p>
<blockquote>
<p>语音识别、文本生成、情感分析</p>
</blockquote>
<h3 id="3-3-其他常见模型"><a href="#3-3-其他常见模型" class="headerlink" title="3.3 其他常见模型"></a>3.3 其他常见模型</h3><p>双向循环神经网络BRNN：前后均可判断信息，提高判断得准确性</p>
<p>深层循环神经网络DRNN：解决更复杂的序列任务，可以把单层RNN叠起来或者在输出前和普通mlp结构结合使用</p>
<h3 id="3-4-实战"><a href="#3-4-实战" class="headerlink" title="3.4 实战"></a>3.4 实战</h3><h4 id="3-4-1-RNN股价预测"><a href="#3-4-1-RNN股价预测" class="headerlink" title="3.4.1 RNN股价预测"></a>3.4.1 RNN股价预测</h4><p>基于zgpa_train.csv数据，建立RNN模型，预测股价：</p>
<blockquote>
<p>完成数据颈处理，将序列数据转化为可用下RNN输入的数据</p>
<p>对新数据zgpa_test.csv进行预测，可视化结果</p>
<p>存储预测结果，并观察局部预测结果</p>
</blockquote>
<p>模型要求：</p>
<blockquote>
<p>单层RNN输出有5个神经元</p>
<p>每次使用前8个数据预测第9个数据</p>
</blockquote>
<h4 id="3-4-2-LSTM自动生成文本"><a href="#3-4-2-LSTM自动生成文本" class="headerlink" title="3.4.2 LSTM自动生成文本"></a>3.4.2 LSTM自动生成文本</h4><p>基于flare文本数据，建立LSTM模型预测序列文字：</p>
<blockquote>
<p>完成数据预处理将文字序列数据转化为可用于LSTM输入的数据</p>
<p>查看文字数据预处理后的数据结构，并进行数据分离操作</p>
<p>针对字符串输入(”flare is a teacher in AI industry. He obtained his phd in Australia.“)，预测其对应的后续字符</p>
<p>模型结构：(单层LSTM输出有20个神经元；每次使用前20个字符预测）</p>
</blockquote>
<h2 id="4-迁移学习"><a href="#4-迁移学习" class="headerlink" title="4 迁移学习"></a>4 迁移学习</h2><h3 id="4-1-相关概念"><a href="#4-1-相关概念" class="headerlink" title="4.1 相关概念"></a>4.1 相关概念</h3><p>概念：以已经训练好的模型A为起点，在新场景中，根据新数据建立模型B。</p>
<p>目的：将某个领域或任务上学习到的知识或模式，应用到不同但相关的领域或问题中。</p>
<p>英文：transfer learning</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173635309.png" srcset="/img/loading.gif" lazyload alt="image-20250304145644120" style="zoom:25%;" />

<p>学习方式：</p>
<blockquote>
<ol>
<li>特征提取：使用模型A，移除输出层，提取目标特征信息</li>
<li>结构引用：使用模型A的结构，重新&#x2F;二次训练权重系数参数</li>
<li>部分训练：使用模型A的结构，重新训练部分层的权重系数参数</li>
</ol>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173637324.png" srcset="/img/loading.gif" lazyload alt="image-20250304154502818" style="zoom:25%;" />

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173639999.png" srcset="/img/loading.gif" lazyload alt="image-20250304154731985" style="zoom:25%;" />

<h3 id="4-2-实战"><a href="#4-2-实战" class="headerlink" title="4.2 实战"></a>4.2 实战</h3><h4 id="4-2-1-迁移预测"><a href="#4-2-1-迁移预测" class="headerlink" title="4.2.1 迁移预测"></a>4.2.1 迁移预测</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173642407.png" srcset="/img/loading.gif" lazyload alt="image-20250304163510651" style="zoom:23%;" />

<p>要求：</p>
<blockquote>
<p>模型结构：mlp</p>
<p>两个隐藏层，每层50个神经元，</p>
<p>激活函数relu，</p>
<p>输出层激活函数linear,</p>
<p>迭代次数：100次</p>
</blockquote>
<p>操作：</p>
<blockquote>
<p>建立MLP模型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.models importSequential<br><span class="hljs-keyword">from</span> keras.layers <span class="hljs-keyword">import</span> Dense<br>model = Sequentia()<br>model.add(Dense(units= <span class="hljs-number">50</span>, input_dim= <span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(units = <span class="hljs-number">50</span>, activation=<span class="hljs-string">&#x27;relu&#x27;</span>))<br>model.add(Dense(units =<span class="hljs-number">1</span>, activation=<span class="hljs-string">&#x27;linear&#x27;</span>))<br>model.<span class="hljs-built_in">compile</span>(optimizer=<span class="hljs-string">&#x27;adam&#x27;</span>,loss=<span class="hljs-string">&#x27;mean_squared_error&#x27;</span>)<br><br>model.summary()<br></code></pre></td></tr></table></figure>

<p>模型训练与二次训练:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model.fit(x,y)<br>model.fit(x2,y2)<br></code></pre></td></tr></table></figure>

<p>模型保存到本地:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.externals <span class="hljs-keyword">import</span> joblib<br>joblib.dump(model, <span class="hljs-string">&quot;model1.m&quot;</span>)<br></code></pre></td></tr></table></figure>

<p>加载本地模型:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">model2=joblib.load(<span class="hljs-string">&quot;model1.m&quot;</span>)<br></code></pre></td></tr></table></figure></blockquote>
<h4 id="4-2-2-苹果检测"><a href="#4-2-2-苹果检测" class="headerlink" title="4.2.2 苹果检测"></a>4.2.2 苹果检测</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173645557.png" srcset="/img/loading.gif" lazyload alt="image-20250304165859988" style="zoom:25%;" />

<p>数据增强，扩充确认为普通苹果的样本数量：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> ImageDataGenerator<br><span class="hljs-comment">#待增强图片的路径</span><br>path = <span class="hljs-string">&#x27;origin_data&#x27;</span><br><span class="hljs-comment">#图片增强后的存储路径#创建实例、配置图片增强参数</span><br>dst_path = <span class="hljs-string">&#x27;gen_data&#x27;</span><br>datagen = ImageDataGenerator(rotation_range=<span class="hljs-number">10</span>, width_shift_range=<span class="hljs-number">0.1</span>, height_shift_range=<span class="hljs-number">0.02</span>, horizontal_flip=<span class="hljs-literal">True</span>,vertical_flip=<span class="hljs-literal">True</span>)<br>gen = datagen.flow_from_directory(path, target_size=(<span class="hljs-number">224</span>, <span class="hljs-number">224</span>), batch_size=<span class="hljs-number">2</span>, save_to_dir=dst_path,<br>                                  save_prefix=<span class="hljs-string">&#x27;gen&#x27;</span>, save_format=<span class="hljs-string">&#x27;jpg&#x27;</span>)<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">100</span>):<br>    gen.<span class="hljs-built_in">next</span>()<br></code></pre></td></tr></table></figure>

<p>单张图片载入：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> keras.preprocessing.image <span class="hljs-keyword">import</span> load_img,img_to_array<br>img_path = <span class="hljs-string">&#x27;1.jpg&#x27;</span><br>img = load_img(img_path, target_size=(<span class="hljs-number">224</span>,<span class="hljs-number">224</span>))<br>img = img_to_array(img)<br></code></pre></td></tr></table></figure>

<p>单张图片可视化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">%matplotlib inline<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br>fig = plt.figure(figsize=(<span class="hljs-number">5</span>,<span class="hljs-number">5</span>))<br>img = load_img(img_path, target_size=(<span class="hljs-number">224</span>,<span class="hljs-number">224</span>))<br>plt.imshow(img)<br></code></pre></td></tr></table></figure>

<p>单张图片特征提取：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#模型加载、图像矩阵预处理</span><br><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> VGG16<br><span class="hljs-keyword">from</span> keras.applications.vgg16 <span class="hljs-keyword">import</span> preprocess_input<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br>model_vgg = VGG16(weights = <span class="hljs-string">&#x27;imagenet&#x27;</span>, include_top = <span class="hljs-literal">False</span>)<br>x = np.expand_dims(img, axis=O)<br>x = preprocess_input(x)<br><br><span class="hljs-comment">#特征提取</span><br>features = model_vgg.predict(x)<br><br><span class="hljs-comment">#特征数据格式预处理</span><br>features = features.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">7</span> * <span class="hljs-number">7</span> * <span class="hljs-number">512</span>)<br></code></pre></td></tr></table></figure>

<p>批量图片路径加载：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-comment">#训练数据文件夹名称</span><br>folder = <span class="hljs-string">&quot;train_data&quot;</span><br><span class="hljs-comment">#获取文件夹下所有文件名称#图片路径合成</span><br>dirs = os.listdir(folder)<br>img_path =[]<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> dirs:<br>    <span class="hljs-keyword">if</span> os.path.splitext(i)[<span class="hljs-number">1</span>] == <span class="hljs-string">&quot;.jpg&quot;</span>:<br>        img_path.append(i)<br>    img_path = [folder+<span class="hljs-string">&quot;//&quot;</span> + i <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> img_path]<br><br></code></pre></td></tr></table></figure>

<p>定义一个提取图片特征的方法:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">def</span> <span class="hljs-title function_">modelProcess</span>(<span class="hljs-params">img_path,model</span>):<br>    img = load_img(img_path, target_size = (<span class="hljs-number">224</span>, <span class="hljs-number">224</span>))<br>    img = img_to_array(img)<br>    x = np.expand_dims(img, axis=O)<br>    x = preprocess_input(x)<br>    x_vgg = model.predict(x)<br>    x_vgg = x_vgg.reshape(<span class="hljs-number">1</span>, <span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">512</span>)<br>    <span class="hljs-keyword">return</span> x_vgg<br></code></pre></td></tr></table></figure>

<p>批量提取图片特征：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">features1 = np.zeros([<span class="hljs-built_in">len</span>(img_path), <span class="hljs-number">7</span>*<span class="hljs-number">7</span>*<span class="hljs-number">512</span>])<br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-built_in">len</span>(img_path)):<br>    feature_i = modelProcess(img_path[i], model_vgg)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">&#x27;preprocessed:&#x27;</span>, img_path[i])<br>    features1[i]= feature_i<br><br></code></pre></td></tr></table></figure>

<p>KMeans聚类(2类)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.cluster Import KMeans<br>cnn_kmeans = KMeans(n_clusters=<span class="hljs-number">2</span>, max_iter=<span class="hljs-number">2000</span>)<br>cnn kmeans.fit(x)<br>y_pred_kmeans  =cnn_kmeans.fit_predict(X)<br></code></pre></td></tr></table></figure>

<p>Meanshift聚类:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> MeanShift,estimate_bandwidth<br><span class="hljs-comment">#自动获取区域宽度</span><br>bw = estimate_bandwidth(X1, n_samples=<span class="hljs-number">140</span>)<br><span class="hljs-comment">#建立模型</span><br>ms = MeanShift(bandwidth = bw)<br>ms.fit(X)<br>y_pred_ms = ms.predict(X)<br></code></pre></td></tr></table></figure>

<p>数据降维(PCA处理)：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> sklearn.preprocessing <span class="hljs-keyword">import</span> StandardScaler<br><span class="hljs-comment">#数据标准化处理</span><br>stds = StandardScaler()<br>X_norm = stds.fit_transform(X)<br><span class="hljs-comment">#PCA降维</span><br><span class="hljs-keyword">from</span> sklearn.decomposition <span class="hljs-keyword">import</span> PCA<br>pca = PCA(n_components=<span class="hljs-number">200</span>)<br>x pca = pca.fit_transform(X_norm)<br><span class="hljs-comment">#计算主成分方差比例</span><br>var_ratio = pca.explained_variance_ratio<br><span class="hljs-comment">#查看主成分方差比之和</span><br><span class="hljs-built_in">print</span>(np.<span class="hljs-built_in">sum</span>(var_ratio))<br></code></pre></td></tr></table></figure>

<p>统计数据次数:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> collections <span class="hljs-keyword">import</span> Counter<br><span class="hljs-built_in">print</span>(Counter(y_pred_ms))<br></code></pre></td></tr></table></figure>

<p>批量可视化结果:</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">plt.figure(figsize=(<span class="hljs-number">10</span>,<span class="hljs-number">30</span>))<br>fori <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">45</span>):<br>    <span class="hljs-keyword">for</span> j <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">5</span>):<br>        img = load_img(img_path[i*<span class="hljs-number">5</span>+j]) <span class="hljs-comment">#read the image as a PIL image</span><br>        plt.subplot(<span class="hljs-number">45</span>, i*<span class="hljs-number">5</span>+j+<span class="hljs-number">1</span>)<br>        plt.title(<span class="hljs-string">&#x27;apple&#x27;</span> <span class="hljs-keyword">if</span> y_pred_ms[i*<span class="hljs-number">5</span> + j] == normal_apple_id <span class="hljs-keyword">else</span> <span class="hljs-string">&#x27;others&#x27;</span>)<br>        plt.imshow(img), plt.axis(<span class="hljs-string">&#x27;off&#x27;</span>)<br><br></code></pre></td></tr></table></figure>



<h2 id="5-在线学习"><a href="#5-在线学习" class="headerlink" title="5 在线学习"></a>5 在线学习</h2><p>概念：给已经训练好的模型输入新的数掺，模型将进行更新适应新数据的趋势。</p>
<p>目的：针对新数据，在不需要对全数据集进行再次训练的基础上，实现模型更新</p>
<p>英文：online learning</p>
<p>适合场景：场景中有连续的数据流</p>
<p>特点：不改变模型结构，根据新数据跟新权重系数</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173651414.png" srcset="/img/loading.gif" lazyload alt="image-20250304154959814" style="zoom:33%;" />

<blockquote>
<p>任务:针对航空公司机票价格，在不同时期，如何确定不同的价格<br>方式一：考虑天气、假期、旅行人数、同时期其他公司航班数、历史参考价格等等，建立一个专家模型<br>方式二：根据客户的实时购票情况，预测客户对不同价格的购买意愿，根据意愿度调整价格</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173655401.png" srcset="/img/loading.gif" lazyload alt="image-20250304155221773" style="zoom:33%;" /></blockquote>
<h1 id="五-openCV"><a href="#五-openCV" class="headerlink" title="五 openCV"></a>五 openCV</h1><h2 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h2><p>因为3.4.2之后有一些视觉申请了专利，所以我们选择安装环境版本</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">pip install opencv-python==<span class="hljs-number">3.4</span><span class="hljs-number">.1</span><span class="hljs-number">.15</span><br>pip install opencv-contrib-python==<span class="hljs-number">3.4</span><span class="hljs-number">.1</span><span class="hljs-number">.15</span><br></code></pre></td></tr></table></figure>

<p>安装完成之后对其检验：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 进入python环境下</span><br>python<br><span class="hljs-keyword">import</span> cv2<br>cv2.__version__<br><span class="hljs-comment"># 如果显示出来版本号即安装成功</span><br></code></pre></td></tr></table></figure>

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> tensorflow <span class="hljs-keyword">as</span> tf<br><span class="hljs-built_in">print</span>(tf.__version__)<br><span class="hljs-built_in">print</span>(tf.test.is_gpu_available())<br></code></pre></td></tr></table></figure>



<h2 id="1-图像处理"><a href="#1-图像处理" class="headerlink" title="1 图像处理"></a>1 图像处理</h2><h3 id="1-1-基本操作"><a href="#1-1-基本操作" class="headerlink" title="1.1 基本操作"></a>1.1 基本操作</h3><p><strong>数据读取-图像</strong>：图像分为彩色、灰色图像，实际上彩色图片是分为RGB三个通道组合而成。</p>
<p>灰度图</p>
<ul>
<li>cv2.IMREAD_COLOR：彩色图像</li>
<li>cv2.IMREAD_GRAYSCALE：灰度图像</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> cv2  <span class="hljs-comment">#opencv读取的格式是BGR</span><br><br>img = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>) <span class="hljs-comment"># 默认就是color</span><br>img = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>, cv2.IMREAD_GRAYSCALE) <span class="hljs-comment"># 读取图片为灰度图</span><br><br><span class="hljs-comment">#保存</span><br>cv2.imwrite(<span class="hljs-string">&#x27;mycat.png&#x27;</span>, img)<br></code></pre></td></tr></table></figure>



<p><strong>数据读取-视频</strong></p>
<ul>
<li>cv2.VideoCapture可以捕获摄像头，用数字来控制不同的设备，例如0,1。</li>
<li>如果是视频文件，直接指定好路径即可。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">vc = cv2.VideoCapture(<span class="hljs-string">&#x27;test.mp4&#x27;</span>)<br><br><span class="hljs-comment"># 检查是否打开正确</span><br><span class="hljs-keyword">if</span> vc.isOpened():<br>    <span class="hljs-comment"># open是读取的标志，frame是每一帧的图像</span><br>    <span class="hljs-built_in">open</span>, frame = vc.read()<br><span class="hljs-keyword">else</span>:<br>    <span class="hljs-built_in">open</span> = <span class="hljs-literal">False</span><br>    <br><span class="hljs-comment"># 读取视频</span><br><span class="hljs-keyword">while</span> <span class="hljs-built_in">open</span>:<br>    ret, frame = vc.read()<br>    <span class="hljs-keyword">if</span> frame <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>        <span class="hljs-keyword">break</span><br>    <span class="hljs-keyword">if</span> ret == <span class="hljs-literal">True</span>:<br>        gray = cv2.cvtColor(frame, cv2.COLOR_BGR2GRAY)<br>        cv2.imshow(<span class="hljs-string">&#x27;result&#x27;</span>, gray)<br>        <span class="hljs-keyword">if</span> cv2.waitKey(<span class="hljs-number">50</span>) &amp; <span class="hljs-number">0xFF</span> == <span class="hljs-number">27</span>:<br>            <span class="hljs-keyword">break</span><br>vc.release()<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure>



<p><strong>截取部分数据</strong></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>)<br>cat = img[<span class="hljs-number">0</span>:<span class="hljs-number">200</span>, <span class="hljs-number">0</span>:<span class="hljs-number">200</span>]<br>cv_show(<span class="hljs-string">&#x27;cat&#x27;</span>, cat)<br></code></pre></td></tr></table></figure>

<p><strong>边界填充</strong></p>
<ul>
<li>BORDER_REPLICATE：复制法，也就是复制最边缘像素。</li>
<li>BORDER_REFLECT：反射法，对感兴趣的图像中的像素在两边进行复制例如：fedcba|abcdefgh|hgfedcb   </li>
<li>BORDER_REFLECT_101：反射法，也就是以最边缘像素为轴，对称，gfedcb|abcdefgh|gfedcba</li>
<li>BORDER_WRAP：外包装法cdefgh|abcdefgh|abcdefg  </li>
<li>BORDER_CONSTANT：常量法，常数值填充。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> matplotlib.pyplot <span class="hljs-keyword">as</span> plt<br><br>top_size, bottom_size, left_size, right_size = (<span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>, <span class="hljs-number">50</span>)<br><br>replicate = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, borderType=cv2.BORDER_REPLICATE)<br>reflect = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT)<br>reflect101 = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_REFLECT_101)<br>wrap = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_WRAP)<br>constant = cv2.copyMakeBorder(img, top_size, bottom_size, left_size, right_size, cv2.BORDER_CONSTANT, value=<span class="hljs-number">0</span>)<br><br>plt.subplot(<span class="hljs-number">231</span>), plt.imshow(img, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;ORIGINAL&#x27;</span>)<br>plt.subplot(<span class="hljs-number">232</span>), plt.imshow(replicate, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REPLICATE&#x27;</span>)<br>plt.subplot(<span class="hljs-number">233</span>), plt.imshow(reflect, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REFLECT&#x27;</span>)<br>plt.subplot(<span class="hljs-number">234</span>), plt.imshow(reflect101, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;REFLECT_101&#x27;</span>)<br>plt.subplot(<span class="hljs-number">235</span>), plt.imshow(wrap, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;WRAP&#x27;</span>)<br>plt.subplot(<span class="hljs-number">236</span>), plt.imshow(constant, <span class="hljs-string">&#x27;gray&#x27;</span>), plt.title(<span class="hljs-string">&#x27;CONSTANT&#x27;</span>)<br><br>plt.show()<br></code></pre></td></tr></table></figure>



<p><strong>数值计算</strong>：如果加10，相当于所有均加10，超过256的数值，则需要用当前数值减去256。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">img_cat = cv2.imread(<span class="hljs-string">&#x27;cat.jpg&#x27;</span>)<br>img_dog = cv2.imread(<span class="hljs-string">&#x27;dog.jpg&#x27;</span>)<br><br><span class="hljs-comment"># 选择图像数据的前5行，所有列，以及第0个通道</span><br>img_cat[:<span class="hljs-number">5</span>, :, <span class="hljs-number">0</span>]<br><br>img_cat2 = img_cat + <span class="hljs-number">10</span><br>img_cat2[:<span class="hljs-number">5</span>, :, <span class="hljs-number">0</span>]<br></code></pre></td></tr></table></figure>



<p><strong>图像融合</strong>：两个图像融合必须要shape值相同才能一一对应相加减。</p>
<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173702009.png" srcset="/img/loading.gif" lazyload alt="image-20250319141020278"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 前面一个是高度，后面一个是宽度，最后一个是通道数RGB</span><br>img_cat.shape<br><br><span class="hljs-comment"># 记住(500， 414)是图像的大小</span><br>img_dog = cv2.resize(img_dog, (<span class="hljs-number">500</span>, <span class="hljs-number">414</span>))<br>img_dog.shape<br><br><span class="hljs-comment"># 融合。0.4代表前面的图像占40%，后面的图像占60%</span><br>res = cv2.addWeighted(img_cat, <span class="hljs-number">0.4</span>, img_dog, <span class="hljs-number">0.6</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-comment"># 重新设置图片大小。(0,0)代表左上角，fx代表宽度，fy代表高度</span><br>res = cv2.resize(img, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>), fx=<span class="hljs-number">4</span>, fy=<span class="hljs-number">4</span>)<br>plt.imshow(res)<br></code></pre></td></tr></table></figure>



<h3 id="1-2-阈值和平滑处理"><a href="#1-2-阈值和平滑处理" class="headerlink" title="1.2 阈值和平滑处理"></a>1.2 阈值和平滑处理</h3><h4 id="1-2-1-HSV"><a href="#1-2-1-HSV" class="headerlink" title="1.2.1 HSV"></a>1.2.1 HSV</h4><ul>
<li>H - 色调（主波长）。</li>
<li>S - 饱和度（纯度&#x2F;颜色的阴影）。</li>
<li>V值（强度）</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">hsv=cv2.cvtColor(img,cv2.COLOR_BGR2HSV)<br><br>cv2.imshow(<span class="hljs-string">&quot;hsv&quot;</span>, hsv)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br>cv2.destroyAllWindows()<br></code></pre></td></tr></table></figure>



<h4 id="1-2-2-图像阈值"><a href="#1-2-2-图像阈值" class="headerlink" title="1.2.2 图像阈值"></a>1.2.2 图像阈值</h4><p>ret, dst &#x3D; cv2.threshold(src, thresh, maxval, type)</p>
<ul>
<li><p>dst： 输出图</p>
</li>
<li><p>src： 输入图，只能输入单通道图像，通常来说为灰度图</p>
</li>
<li><p>thresh： 阈值</p>
</li>
<li><p>maxval： 当像素值超过了阈值（或者小于阈值，根据type来决定），所赋予的值</p>
</li>
<li><p>type：二值化操作的类型，包含以下5种类型： cv2.THRESH_BINARY； cv2.THRESH_BINARY_INV； cv2.THRESH_TRUNC； cv2.THRESH_TOZERO；cv2.THRESH_TOZERO_INV</p>
</li>
<li><p>cv2.THRESH_BINARY           超过阈值部分取maxval（最大值），否则取0</p>
</li>
<li><p>cv2.THRESH_BINARY_INV    	  THRESH_BINARY的反转</p>
</li>
<li><p>cv2.THRESH_TRUNC            大于阈值部分设为阈值，否则不变</p>
</li>
<li><p>cv2.THRESH_TOZERO           大于阈值部分不改变，否则设为0</p>
</li>
<li><p>cv2.THRESH_TOZERO_INV  THRESH_TOZERO的反转</p>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">ret, thresh1 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>ret, thresh2 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY_INV)<br>ret, thresh3 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TRUNC)<br>ret, thresh4 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO)<br>ret, thresh5 = cv2.threshold(img_gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_TOZERO_INV)<br><br>titles = [<span class="hljs-string">&#x27;Original Image&#x27;</span>, <span class="hljs-string">&#x27;BINARY&#x27;</span>, <span class="hljs-string">&#x27;BINARY_INV&#x27;</span>, <span class="hljs-string">&#x27;TRUNC&#x27;</span>, <span class="hljs-string">&#x27;TOZERO&#x27;</span>, <span class="hljs-string">&#x27;TOZERO_INV&#x27;</span>]<br>images = [img, thresh1, thresh2, thresh3, thresh4, thresh5]<br><br><span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">6</span>):<br>    plt.subplot(<span class="hljs-number">2</span>, <span class="hljs-number">3</span>, i + <span class="hljs-number">1</span>), plt.imshow(images[i], <span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.title(titles[i])<br>    plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173708312.png" srcset="/img/loading.gif" lazyload alt="image-20250319142521046"></p>
<h4 id="1-2-3图像平滑"><a href="#1-2-3图像平滑" class="headerlink" title="1.2.3图像平滑"></a>1.2.3图像平滑</h4><blockquote>
<p>均值滤波：将滤波器覆盖范围内的所有像素值相加，然后除以滤波器的元素个数，得到均值并更新。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 均值滤波</span><br><span class="hljs-comment"># 简单的平均卷积操作</span><br>blur = cv2.blur(img, (<span class="hljs-number">3</span>, <span class="hljs-number">3</span>))<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173711376.png" srcset="/img/loading.gif" lazyload alt="image-20250319144047951" style="zoom: 50%;" />

<p>方框滤波：基本和均值滤波一样，可以选择归一化（normalize&#x3D;True）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># True的话和均值滤波一模一样</span><br>box = cv2.boxFilter(img,-<span class="hljs-number">1</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), normalize=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173713668.png" srcset="/img/loading.gif" lazyload alt="image-20250319144618220" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 可以不选择归一化,容易越界，造成曝光</span><br>box = cv2.boxFilter(img,-<span class="hljs-number">1</span>,(<span class="hljs-number">3</span>,<span class="hljs-number">3</span>), normalize=<span class="hljs-literal">False</span>)<br></code></pre></td></tr></table></figure>



<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173716375.png" srcset="/img/loading.gif" lazyload alt="image-20250319144733135" style="zoom:50%;" />

<p>高斯滤波：高斯模糊的卷积核里的数值是满足高斯分布，相当于更重视中间的(离中心越远越不重视)</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># img:输入图像</span><br><span class="hljs-comment"># (5, 5):卷积核的大小</span><br><span class="hljs-comment"># 1: 高斯分布的标准差</span><br>aussian = cv2.GaussianBlur(img, (<span class="hljs-number">5</span>, <span class="hljs-number">5</span>), <span class="hljs-number">1</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173718362.png" srcset="/img/loading.gif" lazyload alt="image-20250319161205150" style="zoom:50%;" />

<p>中值滤波：相当于用中值代替，即先排序，然后直接用中间的值</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">median = cv2.medianBlur(img, <span class="hljs-number">5</span>)  <span class="hljs-comment"># 中值滤波</span><br></code></pre></td></tr></table></figure>



<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173722097.png" srcset="/img/loading.gif" lazyload alt="image-20250319173416236" style="zoom:50%;" /></blockquote>
<blockquote>
<p>上诉整合：可以看出中值滤波效果相对最好</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173726443.png" srcset="/img/loading.gif" lazyload alt="image-20250319173540170" style="zoom:50%;" />



<h3 id="1-3-图像形态学操作"><a href="#1-3-图像形态学操作" class="headerlink" title="1.3 图像形态学操作"></a>1.3 图像形态学操作</h3><h4 id="1-3-1-腐蚀操作"><a href="#1-3-1-腐蚀操作" class="headerlink" title="1.3.1 腐蚀操作"></a>1.3.1 腐蚀操作</h4><blockquote>
<p><strong>腐蚀操作（Erosion）</strong>：是图像处理和计算机视觉中的一种基本的形态学操作。它主要用于减少图像中的噪声、细化图像中的对象、断开相邻的对象等。腐蚀操作通常应用于二值图像，但也可以用于灰度图像</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173731590.png" srcset="/img/loading.gif" lazyload alt="image-20250319174509918" style="zoom:50%;" />

<p><strong>我们可以看出相较于之前未处理的图片来说，腐蚀操作将噪声进行了处理，同时字体变小了</strong></p>
<h4 id="1-3-2-膨胀操作"><a href="#1-3-2-膨胀操作" class="headerlink" title="1.3.2 膨胀操作"></a>1.3.2 膨胀操作</h4><blockquote>
<p>**膨胀操作（Dilation）：**图像处理和计算机视觉中的一种基本的形态学操作。它主要用于扩大图像中的前景对象，通常用于填补对象中的小孔洞，连接相邻的对象，或者增加对象的边界。膨胀操作通常与腐蚀操作（Erosion）结合使用，以实现更复杂的图像处理任务。</p>
</blockquote>
<h4 id="1-3-3-开运算和闭运算"><a href="#1-3-3-开运算和闭运算" class="headerlink" title="1.3.3 开运算和闭运算"></a>1.3.3 开运算和闭运算</h4><blockquote>
<p>**开运算：**先腐蚀，再膨胀。</p>
</blockquote>
<blockquote>
<p>**闭运算：**先膨胀，再腐蚀。</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173734492.png" srcset="/img/loading.gif" lazyload alt="image-20250319175231526" style="zoom:50%;" />



<h4 id="1-3-4-梯度计算"><a href="#1-3-4-梯度计算" class="headerlink" title="1.3.4 梯度计算"></a>1.3.4 梯度计算</h4><p>**梯度运算：**梯度&#x3D;膨胀-腐蚀，可以理解为就是轮廓边缘检测。</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 梯度=膨胀-腐蚀</span><br>pie = cv2.imread(<span class="hljs-string">&#x27;pie.png&#x27;</span>)<br>kernel = np.ones((<span class="hljs-number">7</span>,<span class="hljs-number">7</span>),np.uint8)<br>dilate = cv2.dilate(pie,kernel,iterations = <span class="hljs-number">5</span>)<br>erosion = cv2.erode(pie,kernel,iterations = <span class="hljs-number">5</span>)<br><br>res = np.hstack((dilate,erosion))<br><br>cv_show(<span class="hljs-string">&#x27;res&#x27;</span>, res)<br></code></pre></td></tr></table></figure>



<h4 id="1-3-5-礼帽与黑帽"><a href="#1-3-5-礼帽与黑帽" class="headerlink" title="1.3.5 礼帽与黑帽"></a>1.3.5 礼帽与黑帽</h4><ul>
<li>礼帽 &#x3D; 原始输入-开运算结果</li>
</ul>
<blockquote>
<p>留下的就是去除掉的噪声</p>
</blockquote>
<ul>
<li>黑帽 &#x3D; 闭运算-原始输入</li>
</ul>
<blockquote>
<p>去除效果不佳</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173736955.png" srcset="/img/loading.gif" lazyload alt="image-20250319175921036" style="zoom:50%;" />



<h3 id="1-4-图像梯度"><a href="#1-4-图像梯度" class="headerlink" title="1.4 图像梯度"></a>1.4 图像梯度</h3><h4 id="1-4-1-sobel算子"><a href="#1-4-1-sobel算子" class="headerlink" title="1.4.1 sobel算子"></a>1.4.1 sobel算子</h4><p>**sobel算子：**使用两个3x3的卷积核分别在水平和垂直方向上对图像进行卷积操作，从而得到图像在两个方向上的梯度值。</p>
<p><img src="E:\Markdown\img\sobel_1.png" srcset="/img/loading.gif" lazyload alt="sobel_1"></p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># CV_64F相当于把负数保留下来；1表示x方向，0表示y方向，两者合起来相当于只要水平方向；ksize表示卷积核的大小</span><br>sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">3</span>)<br><span class="hljs-comment"># 这里只显示了左边的半个框，因为始终是右边减去左边，所以只显示左边的半个框</span><br>cv_show(sobelx, <span class="hljs-string">&#x27;sobelx&#x27;</span>) <br></code></pre></td></tr></table></figure>



<p>具体实现步骤：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 白到黑是正数，黑到白就是负数了，所有的负数会被截断成0，所以要取绝对值</span><br>sobelx = cv2.Sobel(img, cv2.CV_64F, <span class="hljs-number">1</span>, <span class="hljs-number">0</span>, ksize=<span class="hljs-number">3</span>)<br>sobelx = cv2.convertScaleAbs(sobelx)<br>cv_show(sobelx, <span class="hljs-string">&#x27;sobelx&#x27;</span>)<br><br>sobely = cv2.Sobel(img,cv2.CV_64F,<span class="hljs-number">0</span>,<span class="hljs-number">1</span>,ksize=<span class="hljs-number">3</span>)<br>sobely = cv2.convertScaleAbs(sobely)  <br>cv_show(sobely,<span class="hljs-string">&#x27;sobely&#x27;</span>)<br><br><span class="hljs-comment"># 分别计算再求和</span><br>sobelxy = cv2.addWeighted(sobelx,<span class="hljs-number">0.5</span>,sobely,<span class="hljs-number">0.5</span>,<span class="hljs-number">0</span>)<br>cv_show(sobelxy,<span class="hljs-string">&#x27;sobelxy&#x27;</span>)<br></code></pre></td></tr></table></figure>



<blockquote>
<p>不建议直接计算，效果很差！！！</p>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173739738.png" srcset="/img/loading.gif" lazyload alt="image-20250319191532319" style="zoom: 67%;" />

<h4 id="1-4-2-Scharr算子"><a href="#1-4-2-Scharr算子" class="headerlink" title="1.4.2 Scharr算子"></a>1.4.2 Scharr算子</h4><p><img src="E:\Markdown\img\scharr-1742278952995-2.png" srcset="/img/loading.gif" lazyload alt="scharr"></p>
<h4 id="1-4-3-laplacian算子"><a href="#1-4-3-laplacian算子" class="headerlink" title="1.4.3 laplacian算子"></a>1.4.3 laplacian算子</h4><p>噪音点比较敏感</p>
<p><img src="E:\Markdown\img\l.png" srcset="/img/loading.gif" lazyload alt="l"></p>
<p>三个算子对比图（从左2至右分别是sobel、scharrx、laplacian）：</p>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173742746.png" srcset="/img/loading.gif" lazyload alt="image-20250319191811454" style="zoom:67%;" />



<h3 id="1-5-边缘检测"><a href="#1-5-边缘检测" class="headerlink" title="1.5 边缘检测"></a>1.5 边缘检测</h3><p>Canny边缘检测</p>
<ul>
<li><ol>
<li><pre><code class="hljs">   使用高斯滤波器，以平滑图像，滤除噪声。
</code></pre>
</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173747933.png" srcset="/img/loading.gif" lazyload alt="canny_1" style="zoom:50%;" />


</li>
<li><ol start="2">
<li><pre><code class="hljs">   计算图像中每个像素点的梯度强度和方向。
</code></pre>
</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173752403.png" srcset="/img/loading.gif" lazyload alt="canny_2" style="zoom: 50%;" />
</li>
<li><ol start="3">
<li><pre><code class="hljs">   应用非极大值（Non-Maximum Suppression）抑制，以消除边缘检测带来的杂散响应。
</code></pre>
</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173755911.png" srcset="/img/loading.gif" lazyload alt="canny_3" style="zoom:50%;" />

<img src="E:\Markdown\img\canny_4.png" srcset="/img/loading.gif" lazyload alt="canny_4" style="zoom:50%;" />
</li>
<li><ol start="4">
<li><pre><code class="hljs">   应用双阈值（Double-Threshold）检测来确定真实的和潜在的边缘。
</code></pre>
</li>
</ol>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173758902.png" srcset="/img/loading.gif" lazyload alt="canny_5" style="zoom:50%;" />
</li>
<li><ol start="5">
<li><pre><code class="hljs">   通过抑制孤立的弱边缘最终完成边缘检测。
</code></pre>
</li>
</ol>
</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">img=cv2.imread(<span class="hljs-string">&quot;car.png&quot;</span>,cv2.IMREAD_GRAYSCALE)<br><br><span class="hljs-comment"># 二值设定不同，展现出来的效果就不同</span><br>v1=cv2.Canny(img,<span class="hljs-number">120</span>,<span class="hljs-number">250</span>)<br>v2=cv2.Canny(img,<span class="hljs-number">50</span>,<span class="hljs-number">100</span>)<br><br>res = np.hstack((v1,v2))<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173808188.png" srcset="/img/loading.gif" lazyload alt="image-20250319192157423" style="zoom:50%;" />



<h3 id="1-6-图像金字塔"><a href="#1-6-图像金字塔" class="headerlink" title="1.6 图像金字塔"></a>1.6 图像金字塔</h3><h4 id="1-6-1-高斯金字塔"><a href="#1-6-1-高斯金字塔" class="headerlink" title="1.6.1 高斯金字塔"></a>1.6.1 高斯金字塔</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173811652.png" srcset="/img/loading.gif" lazyload alt="Pyramid_1" style="zoom:50%;" />



<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">高斯金字塔：向下采样方法（图像缩小，提取特征，降噪）<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173817518.png" srcset="/img/loading.gif" lazyload alt="Pyramid_2" style="zoom:50%;" />

<figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs">高斯金字塔：向上采样方法（图像放大，生成模型，恢复细节）<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173820289.png" srcset="/img/loading.gif" lazyload alt="Pyramid_3" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs python">img=cv2.imread(<span class="hljs-string">&quot;AM.png&quot;</span>)<br>cv_show(img,<span class="hljs-string">&#x27;img&#x27;</span>)<br><span class="hljs-built_in">print</span> (img.shape)<br><br>up=cv2.pyrUp(img)<br>cv_show(up,<span class="hljs-string">&#x27;up&#x27;</span>)<br><span class="hljs-built_in">print</span> (up.shape)<br><br>down=cv2.pyrDown(img)<br>cv_show(down,<span class="hljs-string">&#x27;down&#x27;</span>)<br><span class="hljs-built_in">print</span> (down.shape)<br><br>up2=cv2.pyrUp(up)<br>cv_show(up2,<span class="hljs-string">&#x27;up2&#x27;</span>)<br><span class="hljs-built_in">print</span> (up2.shape)<br><br>up=cv2.pyrUp(img)<br>up_down=cv2.pyrDown(up)<br>cv_show(up_down,<span class="hljs-string">&#x27;up_down&#x27;</span>)<br><br>cv_show(np.hstack((img,up_down)),<span class="hljs-string">&#x27;up_down&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173824171.png" srcset="/img/loading.gif" lazyload alt="image-20250319192428274" style="zoom:50%;" />



<h4 id="1-6-2-拉普拉斯金字塔"><a href="#1-6-2-拉普拉斯金字塔" class="headerlink" title="1.6.2 拉普拉斯金字塔"></a>1.6.2 拉普拉斯金字塔</h4><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173827560.png" srcset="/img/loading.gif" lazyload alt="Pyramid_4" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python">up=cv2.pyrUp(img)<br>up_down=cv2.pyrDown(up)<br>cv_show(img-up_down,<span class="hljs-string">&#x27;img-up_down&#x27;</span>)<br><br>down=cv2.pyrDown(img)<br>down_up=cv2.pyrUp(down)<br>l_1=img-down_up<br>cv_show(l_1,<span class="hljs-string">&#x27;l_1&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173831333.png" srcset="/img/loading.gif" lazyload alt="image-20250319193325256" style="zoom: 67%;" />

<h3 id="1-7-图像轮廓"><a href="#1-7-图像轮廓" class="headerlink" title="1.7 图像轮廓"></a>1.7 图像轮廓</h3><p>操作解析：</p>
<blockquote>
<p>cv2.findContours(img, mode,method)</p>
<p>mode：轮廓检索模式</p>
<ul>
<li>RETR_EXTERNAL ：只检索最外面的轮廓；</li>
<li>RETR_LIST：检索所有的轮廓，并将其保存到一条链表当中；</li>
<li>RETR_CCOMP：检索所有的轮廓，并将他们组织为两层：顶层是各部分的外部边界，第二层是空洞的边界;</li>
<li>RETR_TREE：检索所有的轮廓，并重构嵌套轮廓的整个层次;</li>
</ul>
<p>method：轮廓逼近方法</p>
<ul>
<li>CHAIN_APPROX_NONE：以Freeman链码的方式输出轮廓，所有其他方法输出多边形（顶点的序列）。</li>
<li>CHAIN_APPROX_SIMPLE：压缩水平的、垂直的和斜的部分，也就是，函数只保留他们的终点部分。</li>
</ul>
</blockquote>
<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173834572.png" srcset="/img/loading.gif" lazyload alt="chain" style="zoom: 67%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 为了更高的准确率，使用二值图像</span><br>img = cv2.imread(<span class="hljs-string">&#x27;car.png&#x27;</span>)<br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>cv_show(thresh,<span class="hljs-string">&#x27;thresh&#x27;</span>)<br><br>binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br></code></pre></td></tr></table></figure>



<p>绘制轮廓</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 注意需要copy,要不原图会变。</span><br>draw_img = img.copy()<br><span class="hljs-comment"># 传入绘制图像，轮廓，轮廓索引，颜色模式，线条厚度</span><br>res = cv2.drawContours(draw_img, contours, -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv_show(res,<span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173837687.png" srcset="/img/loading.gif" lazyload alt="image-20250319193949988" style="zoom:50%;" />



<p>轮廓特征</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># (5, 1, 2)</span><br>cnt = contours[<span class="hljs-number">0</span>]<br><br><span class="hljs-comment">#面积</span><br>cv2.contourArea(cnt)<br><br><span class="hljs-comment">#周长，True表示闭合的</span><br>cv2.arcLength(cnt, <span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure>



<p>轮廓近似</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;contours2.png&#x27;</span>)<br><span class="hljs-comment"># 将图像转换为灰度图像</span><br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br><br><span class="hljs-comment"># 对灰度图像进行二值化处理</span><br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br><span class="hljs-comment"># 查找图像中的轮廓</span><br>binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br><span class="hljs-comment"># 选择第一个轮廓</span><br><br>cnt = contours[<span class="hljs-number">0</span>]<br><span class="hljs-comment"># 复制原图像，用于绘制轮廓</span><br>draw_img = img.copy()<br><span class="hljs-comment"># 在复制的图像上绘制选定的轮廓</span><br>res = cv2.drawContours(draw_img, [cnt], -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><span class="hljs-comment"># 显示绘制了轮廓的图像</span><br>cv_show(res, <span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173841108.png" srcset="/img/loading.gif" lazyload alt="image-20250319202106877" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 计算轮廓的弧长</span><br>epsilon = <span class="hljs-number">0.1</span> * cv2.arcLength(cnt, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 近似轮廓</span><br>approx = cv2.approxPolyDP(cnt, epsilon, <span class="hljs-literal">True</span>)<br><span class="hljs-comment"># 复制原始图像</span><br>draw_img = img.copy()<br><span class="hljs-comment"># 绘制近似轮廓，[approx]：包含近似轮廓的列表。注意这里是一个列表，即使只有一个轮廓</span><br>res = cv2.drawContours(draw_img, [approx], -<span class="hljs-number">1</span>, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br>cv_show(res, <span class="hljs-string">&#x27;res&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173844024.png" srcset="/img/loading.gif" lazyload alt="image-20250319202133764" style="zoom:50%;" />

<blockquote>
<p>注：这个不规整主要是跟计算轮廓的0.1有关</p>
</blockquote>
<p>边界矩形：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;contours.png&#x27;</span>)<br><br>gray = cv2.cvtColor(img, cv2.COLOR_BGR2GRAY)<br>ret, thresh = cv2.threshold(gray, <span class="hljs-number">127</span>, <span class="hljs-number">255</span>, cv2.THRESH_BINARY)<br>binary, contours, hierarchy = cv2.findContours(thresh, cv2.RETR_TREE, cv2.CHAIN_APPROX_NONE)<br>cnt = contours[<span class="hljs-number">5</span>]<br><br>x,y,w,h = cv2.boundingRect(cnt)<br>img = cv2.rectangle(img,(x,y),(x+w,y+h),(<span class="hljs-number">0</span>,<span class="hljs-number">255</span>,<span class="hljs-number">0</span>),<span class="hljs-number">2</span>)<br>cv_show(img,<span class="hljs-string">&#x27;img&#x27;</span>)<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173847483.png" srcset="/img/loading.gif" lazyload alt="image-20250319202702057" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">area = cv2.contourArea(cnt)<br>x, y, w, h = cv2.boundingRect(cnt)<br>rect_area = w * h<br>extent = <span class="hljs-built_in">float</span>(area) / rect_area<br><span class="hljs-built_in">print</span> (<span class="hljs-string">&#x27;轮廓面积与边界矩形比&#x27;</span>,extent)<br></code></pre></td></tr></table></figure>

<blockquote>
<p>输出结果：轮廓面积与边界矩形比 0.5154317244724715</p>
</blockquote>
<p>外接圆</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">(x, y), radius = cv2.minEnclosingCircle(cnt)<br>center = (<span class="hljs-built_in">int</span>(x), <span class="hljs-built_in">int</span>(y))<br>radius = <span class="hljs-built_in">int</span>(radius)<br>img = cv2.circle(img, center, radius, (<span class="hljs-number">0</span>, <span class="hljs-number">255</span>, <span class="hljs-number">0</span>), <span class="hljs-number">2</span>)<br>cv_show(img, <span class="hljs-string">&#x27;img&#x27;</span>)<br></code></pre></td></tr></table></figure>



<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173850298.png" srcset="/img/loading.gif" lazyload alt="image-20250319202857356" style="zoom:50%;" />



<h3 id="1-8-模板匹配"><a href="#1-8-模板匹配" class="headerlink" title="1.8 模板匹配"></a>1.8 模板匹配</h3><blockquote>
<p>模板匹配和卷积原理很像，模板在原图像上从原点开始滑动，计算模板与（图像被模板覆盖的地方）的差别程度，这个差别程度的计算方法在opencv里有6种，然后将每次计算的结果放入一个矩阵里，作为结果输出。假如原图形是AxB大小，而模板是axb大小，则输出结果的矩阵是(A-a+1)x(B-b+1)</p>
</blockquote>
<ul>
<li>TM_SQDIFF：计算平方不同，计算出来的值越小，越相关        </li>
<li>TM_CCORR：计算相关性，计算出来的值越大，越相关</li>
<li>TM_CCOEFF：计算相关系数，计算出来的值越大，越相关</li>
<li>TM_SQDIFF_NORMED：计算归一化平方不同，计算出来的值越接近0，越相关</li>
<li>TM_CCORR_NORMED：计算归一化相关性，计算出来的值越接近1，越相关</li>
<li>TM_CCOEFF_NORMED：计算归一化相关系数，计算出来的值越接近1，越相关</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs python">methods = [<span class="hljs-string">&#x27;cv2.TM_CCOEFF&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_CCOEFF_NORMED&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_CCORR&#x27;</span>,<br>           <span class="hljs-string">&#x27;cv2.TM_CCORR_NORMED&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_SQDIFF&#x27;</span>, <span class="hljs-string">&#x27;cv2.TM_SQDIFF_NORMED&#x27;</span>]<br><br><span class="hljs-comment"># 计算模板匹配</span><br>res = cv2.matchTemplate(img, template, cv2.TM_SQDIFF)<br>res.shape<br><br>min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)<br><br><span class="hljs-keyword">for</span> meth <span class="hljs-keyword">in</span> methods:<br>    img2 = img.copy()<br><br>    <span class="hljs-comment"># 匹配方法的真值</span><br>    method = <span class="hljs-built_in">eval</span>(meth)<br>    <span class="hljs-built_in">print</span>(method)<br>    res = cv2.matchTemplate(img, template, method)<br>    min_val, max_val, min_loc, max_loc = cv2.minMaxLoc(res)<br><br>    <span class="hljs-comment"># 如果是平方差匹配TM_SQDIFF或归一化平方差匹配TM_SQDIFF_NORMED，取最小值</span><br>    <span class="hljs-keyword">if</span> method <span class="hljs-keyword">in</span> [cv2.TM_SQDIFF, cv2.TM_SQDIFF_NORMED]:<br>        top_left = min_loc<br>    <span class="hljs-keyword">else</span>:<br>        top_left = max_loc<br>    bottom_right = (top_left[<span class="hljs-number">0</span>] + w, top_left[<span class="hljs-number">1</span>] + h)<br><br>    <span class="hljs-comment"># 画矩形</span><br>    cv2.rectangle(img2, top_left, bottom_right, <span class="hljs-number">255</span>, <span class="hljs-number">2</span>)<br><br>    plt.subplot(<span class="hljs-number">121</span>), plt.imshow(res, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.xticks([]), plt.yticks([])  <span class="hljs-comment"># 隐藏坐标轴</span><br>    plt.subplot(<span class="hljs-number">122</span>), plt.imshow(img2, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>    plt.xticks([]), plt.yticks([])<br>    plt.suptitle(meth, c=<span class="hljs-string">&#x27;w&#x27;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173857774.png" srcset="/img/loading.gif" lazyload alt="image-20250319204828072"><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173906813.png" srcset="/img/loading.gif" lazyload alt="image-20250319204901151"></p>
<p>匹配多个对象（超级玛丽的小金币）</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">img_rgb = cv2.imread(<span class="hljs-string">&#x27;mario.jpg&#x27;</span>)<br>img_gray = cv2.cvtColor(img_rgb, cv2.COLOR_BGR2GRAY)<br>template = cv2.imread(<span class="hljs-string">&#x27;mario_coin.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br>h, w = template.shape[:<span class="hljs-number">2</span>]<br><br>res = cv2.matchTemplate(img_gray, template, cv2.TM_CCOEFF_NORMED)<br>threshold = <span class="hljs-number">0.8</span><br><span class="hljs-comment"># 取匹配程度大于%80的坐标</span><br>loc = np.where(res &gt;= threshold)<br><span class="hljs-keyword">for</span> pt <span class="hljs-keyword">in</span> <span class="hljs-built_in">zip</span>(*loc[::-<span class="hljs-number">1</span>]):  <span class="hljs-comment"># *号表示可选参数</span><br>    bottom_right = (pt[<span class="hljs-number">0</span>] + w, pt[<span class="hljs-number">1</span>] + h)<br>    cv2.rectangle(img_rgb, pt, bottom_right, (<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">255</span>), <span class="hljs-number">2</span>)<br><br>cv2.imshow(<span class="hljs-string">&#x27;img_rgb&#x27;</span>, img_rgb)<br>cv2.waitKey(<span class="hljs-number">0</span>)<br></code></pre></td></tr></table></figure>

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173914806.png" srcset="/img/loading.gif" lazyload alt="image-20250319204943249"></p>
<h3 id="1-9-直方图"><a href="#1-9-直方图" class="headerlink" title="1.9 直方图"></a>1.9 直方图</h3><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173917399.png" srcset="/img/loading.gif" lazyload alt="hist_1" style="zoom: 50%;" />

<p>cv2.calcHist(images,channels,mask,histSize,ranges)</p>
<ul>
<li>images: 原图像图像格式为 uint8 或 ﬂoat32。当传入函数时应 用中括号 [] 括来例如[img]</li>
<li>channels: 同样用中括号括来它会告函数我们统幅图 像的直方图。如果入图像是灰度图它的值就是 [0]如果是彩色图像 的传入的参数可以是 [0][1][2] 它们分别对应着 BGR。 </li>
<li>mask: 掩模图像。统整幅图像的直方图就把它为 None。但是如果你想统图像某一分的直方图的你就制作一个掩模图像并使用它。</li>
<li>histSize:BIN 的数目。也应用中括号括来</li>
<li>ranges: 像素值范围常为 [0, 256]</li>
</ul>
<p>直方图均衡化：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;clahe.jpg&#x27;</span>,<span class="hljs-number">0</span>) <span class="hljs-comment">#0表示灰度图 #clahe</span><br>plt.hist(img.ravel(),<span class="hljs-number">256</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173922007.png" srcset="/img/loading.gif" lazyload alt="image-20250319204303994" style="zoom:50%;" />

<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">equ = cv2.equalizeHist(img) <br>plt.hist(equ.ravel(),<span class="hljs-number">256</span>)<br>plt.show()<br></code></pre></td></tr></table></figure>

<img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173924308.png" srcset="/img/loading.gif" lazyload alt="image-20250319204327529" style="zoom:50%;" />



<h3 id="1-10-傅里叶变换"><a href="#1-10-傅里叶变换" class="headerlink" title="1.10 傅里叶变换"></a>1.10 傅里叶变换</h3><blockquote>
<p>我们生活在时间的世界中，早上7:00起来吃早饭，8:00去挤地铁，9:00开始上班。。。以时间为参照就是时域分析。</p>
<p>但是在频域中一切都是静止的！</p>
<p><a target="_blank" rel="noopener" href="https://zhuanlan.zhihu.com/p/19763358">https://zhuanlan.zhihu.com/p/19763358</a></p>
</blockquote>
<p><strong>傅里叶变换的作用</strong></p>
<ul>
<li><p>高频：变化剧烈的灰度分量，例如边界</p>
</li>
<li><p>低频：变化缓慢的灰度分量，例如一片大海</p>
</li>
</ul>
<p><strong>滤波</strong></p>
<ul>
<li><p>低通滤波器：只保留低频，会使得图像模糊</p>
</li>
<li><p>高通滤波器：只保留高频，会使得图像细节增强</p>
</li>
</ul>
<p><strong>操作流程：</strong></p>
<ul>
<li>opencv中主要就是cv2.dft()和cv2.idft()，输入图像需要先转换成np.float32 格式。</li>
<li>得到的结果中频率为0的部分会在左上角，通常要转换到中心位置，可以通过shift变换来实现。</li>
<li>cv2.dft()返回的结果是双通道的（实部，虚部），通常还需要转换成图像格式才能展示（0,255）。</li>
</ul>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br>dft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><span class="hljs-comment"># 得到灰度图能表示的形式</span><br>magnitude_spectrum = <span class="hljs-number">20</span> * np.log(cv2.magnitude(dft_shift[:, :, <span class="hljs-number">0</span>], dft_shift[:, :, <span class="hljs-number">1</span>]))<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(magnitude_spectrum, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Magnitude Spectrum&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173928562.png" srcset="/img/loading.gif" lazyload alt="image-20250319203356606"></p>
<blockquote>
<p>上面输出的图片中，input Image由 dft 变换后的图片，Magnitude Spectrum是频谱图</p>
<p>Magnitude Spectrum由 idft 可转化为input Image</p>
</blockquote>
<p>低通滤波：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> cv2<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><br>img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br><span class="hljs-comment"># 傅里叶变换</span><br>dft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><br>rows, cols = img.shape<br>crow, ccol = <span class="hljs-built_in">int</span>(rows / <span class="hljs-number">2</span>), <span class="hljs-built_in">int</span>(cols / <span class="hljs-number">2</span>)<br><br><span class="hljs-comment"># 低通滤波</span><br>mask = np.zeros((rows, cols, <span class="hljs-number">2</span>), np.uint8)<br>mask[crow - <span class="hljs-number">30</span>:crow + <span class="hljs-number">30</span>, ccol - <span class="hljs-number">30</span>:ccol + <span class="hljs-number">30</span>] = <span class="hljs-number">1</span><br><br><span class="hljs-comment"># IDFT</span><br>fshift = dft_shift * mask<br>f_ishift = np.fft.ifftshift(fshift)<br>img_back = cv2.idft(f_ishift)  <span class="hljs-comment">#之前转换到中间了，这是转换回去，但是这是实部 虚部双通道不能绘图观看</span><br>img_back = cv2.magnitude(img_back[:, :, <span class="hljs-number">0</span>], img_back[:, :, <span class="hljs-number">1</span>])  <span class="hljs-comment"># 合并实部虚部</span><br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(img_back, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Result&#x27;</span>, c=<span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br><br>plt.show()                <br></code></pre></td></tr></table></figure>

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173931795.png" srcset="/img/loading.gif" lazyload alt="image-20250319203922133"></p>
<p>高通滤波：</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python">img = cv2.imread(<span class="hljs-string">&#x27;lena.jpg&#x27;</span>, <span class="hljs-number">0</span>)<br><br>img_float32 = np.float32(img)<br><br>dft = cv2.dft(img_float32, flags=cv2.DFT_COMPLEX_OUTPUT)<br>dft_shift = np.fft.fftshift(dft)<br><br>rows, cols = img.shape<br>crow, ccol = <span class="hljs-built_in">int</span>(rows / <span class="hljs-number">2</span>), <span class="hljs-built_in">int</span>(cols / <span class="hljs-number">2</span>)  <span class="hljs-comment"># 中心位置</span><br><br><span class="hljs-comment"># 高通滤波</span><br>mask = np.ones((rows, cols, <span class="hljs-number">2</span>), np.uint8)<br>mask[crow - <span class="hljs-number">30</span>:crow + <span class="hljs-number">30</span>, ccol - <span class="hljs-number">30</span>:ccol + <span class="hljs-number">30</span>] = <span class="hljs-number">0</span><br><br><span class="hljs-comment"># IDFT</span><br>fshift = dft_shift * mask<br>f_ishift = np.fft.ifftshift(fshift)<br>img_back = cv2.idft(f_ishift)<br>img_back = cv2.magnitude(img_back[:, :, <span class="hljs-number">0</span>], img_back[:, :, <span class="hljs-number">1</span>])<br><br>plt.subplot(<span class="hljs-number">121</span>), plt.imshow(img, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Input Image&#x27;</span>, c = <span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br>plt.subplot(<span class="hljs-number">122</span>), plt.imshow(img_back, cmap=<span class="hljs-string">&#x27;gray&#x27;</span>)<br>plt.title(<span class="hljs-string">&#x27;Result&#x27;</span>, c = <span class="hljs-string">&#x27;w&#x27;</span>), plt.xticks([]), plt.yticks([])<br><br>plt.show()<br></code></pre></td></tr></table></figure>

<p><img src="https://alaskaboo-picgo.oss-cn-shanghai.aliyuncs.com/20250625173934317.png" srcset="/img/loading.gif" lazyload alt="image-20250319203947157"></p>
<blockquote>
<p><strong>总结</strong><br>为什么我们会转换到频域当中做处理？</p>
<ul>
<li>因为在频域中，我们可以很容易的分离出图像的高频和低频部分，然后通过滤波的方式，去除图像中的噪声，或者是增强图像的细节。</li>
<li>这样的方式更加的高效，而且更加的方便。</li>
</ul>
</blockquote>
<h2 id="2-背景建模"><a href="#2-背景建模" class="headerlink" title="2 背景建模"></a>2 背景建模</h2><p>帧差法</p>
<blockquote>
<p>由于场景中的目标在运动，目标的影像在不同图像帧中的位置不同。该类算法对<strong>时间上连续的两帧图像</strong>进行<strong>差分运算</strong>，不同帧对应的像素点相减，判断灰度差的绝对值，当绝对值超过一定阈值时，即可判断为运动目标，从而实现目标的检测功能。</p>
</blockquote>
<blockquote>
<p>帧差法非常简单，但是会引入噪音和空洞问题</p>
</blockquote>
<h2 id="3-label标注"><a href="#3-label标注" class="headerlink" title="3 label标注"></a>3 label标注</h2><blockquote>
<p>安装：pip install labelme</p>
<p>启动：labelme</p>
</blockquote>
<h1 id="六-爬虫相关"><a href="#六-爬虫相关" class="headerlink" title="六 爬虫相关"></a>六 爬虫相关</h1><h2 id="1-正则表达式"><a href="#1-正则表达式" class="headerlink" title="1 正则表达式"></a>1 正则表达式</h2><p>Regular Expression，正则表达式，一种使用表达式的方式对字符串进行匹配的语法规则。</p>
<p>正则的语法: </p>
<blockquote>
<p> 使用元字符进行排列组合用来匹配字符串，<a target="_blank" rel="noopener" href="https://tool.oschina.net/regex">在线测试正则表达式</a></p>
</blockquote>
<p>元字符：具有固定含义的特殊符号</p>
<p>常用元字符：</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs markdown">.       匹配除换行符以外的任意字符<br>\w      匹配字母或数字或下划线<br>\s      匹配任意的空白符<br>\d      匹配数字<br>\n      匹配一个换行符<br>\t      匹配一个制表符<br><br>^       匹配字符串的开始<br>$       匹配字符串的结尾<br><br>\W      匹配非字母或数字或下划线<br>\S      匹配非空白符<br>\D      匹配非数字<br>a|b     匹配字符a或字符b<br>()      匹配括号内的表达式，也表示一个组<br>[...]   匹配字符组中的字符<br>[^...]  匹配除了字符组中字符的所有字符<br></code></pre></td></tr></table></figure>



<p>量词：控制前面的元字符出现的次数</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs markdown"><span class="hljs-bullet">*</span>     重复零次或更多次<br><span class="hljs-bullet">+</span>     重复一次或更多次<br>?     重复零次或一次<br>&#123;n&#125;   重复n次<br>&#123;n,&#125;  重复n次或更多次<br>&#123;n,m&#125; 重复n到m次<br></code></pre></td></tr></table></figure>



<p>贪婪匹配和惰性匹配</p>
<figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">.*    贪婪匹配<br>.*?   惰性匹配<br></code></pre></td></tr></table></figure>



<h2 id="2-re模块"><a href="#2-re模块" class="headerlink" title="2 re模块"></a>2 re模块</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> re<br><br><span class="hljs-comment"># # findall：匹配字符串中所有符合正则的内容</span><br><span class="hljs-comment"># lst = re.findall(&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># print(lst)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # finditer：匹配字符串中所有的内容【返回的是迭代器】，从迭代器中拿数据需要.group()</span><br><span class="hljs-comment"># it = re.finditer(&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># for item in it:</span><br><span class="hljs-comment">#     print(item.group())</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # search：匹配字符串中第一个符合正则的内容，拿数据需要.group()</span><br><span class="hljs-comment"># s = re.search(r&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment"># print(s.group())</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # match：从头开始匹配</span><br><span class="hljs-comment"># match = re.match(r&quot;\d+&quot;, &quot;我的电话是10086，我女朋友的电话是10010&quot;)</span><br><span class="hljs-comment"># print(match)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># # 预加载正则表达式</span><br><span class="hljs-comment"># pattern = re.compile(r&quot;\d+&quot;)</span><br><span class="hljs-comment"># print(pattern.findall(&quot;我的电话是10086，我女朋友的电话是10010&quot;))</span><br><br><span class="hljs-comment"># (?P&lt;分组名字&gt;正则) 可以单独从正则匹配的内容中进一步提取到目标数据</span><br>s = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">&lt;div class=&#x27;jay&#x27;&gt;&lt;span id=&#x27;1&#x27;&gt;郭麒麟&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;jj&#x27;&gt;&lt;span id=&#x27;2&#x27;&gt;宋铁&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;join&#x27;&gt;&lt;span id=&#x27;3&#x27;&gt;大聪明&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;solar&#x27;&gt;&lt;span id=&#x27;4&#x27;&gt;范思哲&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&lt;div class=&#x27;tory&#x27;&gt;&lt;span id=&#x27;5&#x27;&gt;胡说八道&lt;/span&gt;&lt;/div&gt;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>obj = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;div class=&#x27;(?P&lt;class&gt;.*?)&#x27;&gt;&lt;span id=&#x27;(?P&lt;id&gt;\d+)&#x27;&gt;(?P&lt;name&gt;.*?)&lt;/span&gt;&lt;/div&gt;&quot;</span>, re.S)<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> obj.finditer(s):<br>    <span class="hljs-built_in">print</span>(item.group(<span class="hljs-string">&quot;class&quot;</span>))<br>    <span class="hljs-built_in">print</span>(item.group(<span class="hljs-string">&quot;id&quot;</span>))<br>    <span class="hljs-built_in">print</span>(item.group(<span class="hljs-string">&quot;name&quot;</span>))<br></code></pre></td></tr></table></figure>



<h2 id="3-request模块"><a href="#3-request模块" class="headerlink" title="3 request模块"></a>3 request模块</h2><h3 id="3-1-人名搜索"><a href="#3-1-人名搜索" class="headerlink" title="3.1 人名搜索"></a>3.1 人名搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br><br><span class="hljs-keyword">def</span> <span class="hljs-title function_">get_html</span>(<span class="hljs-params">url</span>):<br>    headers = &#123;<br>        <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#x27;</span><br>    &#125;<br>    resp = requests.get(url, headers=headers)<br>    <span class="hljs-keyword">return</span> resp.text<br><br>query = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你想查询的人名：&quot;</span>)<br><br>url = <span class="hljs-string">f&#x27;https://www.sogou.com/web?query=<span class="hljs-subst">&#123;query&#125;</span>&#x27;</span><br><br><span class="hljs-built_in">print</span>(get_html(url))<br></code></pre></td></tr></table></figure>



<h3 id="3-2-百度翻译"><a href="#3-2-百度翻译" class="headerlink" title="3.2 百度翻译"></a>3.2 百度翻译</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://fanyi.baidu.com/sug&#x27;</span><br><br>query = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入你想查询的单词：&quot;</span>)<br><br>data = &#123;<br>    <span class="hljs-string">&#x27;kw&#x27;</span>: query<br>&#125;<br><br>resp = requests.post(url, data=data)<br><br><span class="hljs-built_in">print</span>(resp.json())<br>resp.close()<br></code></pre></td></tr></table></figure>



<h3 id="3-3-豆瓣电影"><a href="#3-3-豆瓣电影" class="headerlink" title="3.3 豆瓣电影"></a>3.3 豆瓣电影</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span><br><br>params = &#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;24&quot;</span>,<br>    <span class="hljs-string">&quot;interval_id&quot;</span>: <span class="hljs-string">&quot;100:90&quot;</span>,<br>    <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;limit&quot;</span>: <span class="hljs-number">20</span><br>&#125;<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#x27;</span><br>&#125;<br><br>resp = requests.get(url, params=params, headers=headers)<br><br><span class="hljs-built_in">print</span>(resp.request.headers)<br><span class="hljs-built_in">print</span>(resp.json())<br><br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;movie.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).write(resp.text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ok&quot;</span>)<br><br>resp.close()<br></code></pre></td></tr></table></figure>



<h2 id="4-实战模块"><a href="#4-实战模块" class="headerlink" title="4 实战模块"></a>4 实战模块</h2><h3 id="4-1-bs4图片下载"><a href="#4-1-bs4图片下载" class="headerlink" title="4.1 bs4图片下载"></a>4.1 bs4图片下载</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> requests<br><br>url = <span class="hljs-string">&#x27;https://movie.douban.com/j/chart/top_list&#x27;</span><br><br>params = &#123;<br>    <span class="hljs-string">&quot;type&quot;</span>: <span class="hljs-string">&quot;24&quot;</span>,<br>    <span class="hljs-string">&quot;interval_id&quot;</span>: <span class="hljs-string">&quot;100:90&quot;</span>,<br>    <span class="hljs-string">&quot;action&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>    <span class="hljs-string">&quot;start&quot;</span>: <span class="hljs-number">0</span>,<br>    <span class="hljs-string">&quot;limit&quot;</span>: <span class="hljs-number">20</span><br>&#125;<br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/134.0.0.0 Safari/537.36&#x27;</span><br>&#125;<br><br>resp = requests.get(url, params=params, headers=headers)<br><br><span class="hljs-built_in">print</span>(resp.request.headers)<br><span class="hljs-built_in">print</span>(resp.json())<br><br><span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;movie.txt&#x27;</span>, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).write(resp.text)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;ok&quot;</span>)<br><br>resp.close()<br></code></pre></td></tr></table></figure>



<h3 id="4-2-盗版天堂"><a href="#4-2-盗版天堂" class="headerlink" title="4.2 盗版天堂"></a>4.2 盗版天堂</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># -*- coding: utf-8 -*-</span><br><span class="hljs-comment"># 拿到页面源代码 request</span><br><span class="hljs-comment"># 通过re来提取想要的有效信息 re</span><br><br><span class="hljs-keyword">import</span> requests<br><span class="hljs-keyword">import</span> re<br><br>url = <span class="hljs-string">&#x27;https://www.dytt8899.com/&#x27;</span><br><br>headers = &#123;<br>    <span class="hljs-string">&#x27;User-Agent&#x27;</span>: <span class="hljs-string">&#x27;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/135.0.0.0 Safari/537.36 Edg/135.0.0.0&#x27;</span><br>&#125;<br><br>resp = requests.get(url, headers=headers, verify=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># verify=False 忽略证书</span><br>resp.encoding = <span class="hljs-string">&#x27;gb2312&#x27;</span><br><span class="hljs-comment"># print(resp.text)</span><br><br>ul = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;2025必看热片.*?&lt;ul&gt;(?P&lt;content&gt;.*?)&lt;/ul&gt;&quot;</span>, re.S)<br>movie_href = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&quot;&lt;a href=&#x27;(?P&lt;href&gt;.*?)&#x27;&quot;</span>, re.S)<br>movie_name = re.<span class="hljs-built_in">compile</span>(<span class="hljs-string">r&#x27;◎片　　名(?P&lt;name&gt;.*?)&lt;br /&gt;.*?&lt;td &#x27;</span><br>                        <span class="hljs-string">r&#x27;style=&quot;WORD-WRAP: break-word&quot; bgcolor=&quot;#fdfddf&quot;&gt;&lt;a href=&quot;(?P&lt;download&gt;.*?)&quot;&#x27;</span>, re.S)<br><br>res = ul.finditer(resp.text)<br>child_href_list = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> res:<br>    content = item.group(<span class="hljs-string">&quot;content&quot;</span>)<br>    <span class="hljs-comment"># 提取子页面链接</span><br>    movie_url = movie_href.finditer(content)<br>    <span class="hljs-keyword">for</span> movie_item <span class="hljs-keyword">in</span> movie_url:<br>        all_url =url + movie_item.group(<span class="hljs-string">&quot;href&quot;</span>).strip(<span class="hljs-string">&quot;/&quot;</span>)<br>        child_href_list.append(all_url)<br><br><span class="hljs-comment"># 提取子页面内容</span><br><span class="hljs-keyword">for</span> child_url <span class="hljs-keyword">in</span> child_href_list:<br>    child_resp = requests.get(child_url, verify=<span class="hljs-literal">False</span>)<br>    child_resp.encoding = <span class="hljs-string">&#x27;gb2312&#x27;</span><br>    <span class="hljs-comment"># print(child_resp.text)</span><br>    <span class="hljs-comment"># 提取片名和下载地址</span><br>    result = movie_name.search(child_resp.text)<br>    <span class="hljs-comment"># 将name和download写入进csv文件</span><br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;看片爬虫.csv&quot;</span>, <span class="hljs-string">&quot;a&quot;</span>, encoding=<span class="hljs-string">&quot;gb2312&quot;</span>) <span class="hljs-keyword">as</span> f:<br>        f.write(result.group(<span class="hljs-string">&quot;name&quot;</span>) + <span class="hljs-string">&quot;,&quot;</span> + result.group(<span class="hljs-string">&quot;download&quot;</span>) + <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure>
































                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="category-chain-item">机器学习</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E8%A7%86%E8%A7%89/" class="print-no-link">#计算机视觉</a>
      
        <a href="/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/" class="print-no-link">#机器学习</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Machine Learning</div>
      <div>http://example.com/2025/03/02/机器学习/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>Alaskaboo</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2025年3月2日</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>更新于</div>
          <div>2025年7月16日</div>
        </div>
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2025/04/24/%E6%B0%B4%E4%B8%8B%E6%9C%BA%E5%99%A8%E4%BA%BA%E6%80%9D%E8%B7%AF/" title="深眸慧扫项目">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">深眸慧扫项目</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2025/02/28/SpringCloud/" title="SpringCould">
                        <span class="hidden-mobile">SpringCould</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  
  
    <article id="comments" lazyload>
      
  <div id="gitalk-container"></div>
  <script type="text/javascript">
    Fluid.utils.loadComments('#gitalk-container', function() {
      Fluid.utils.createCssLink('/css/gitalk.css')
      Fluid.utils.createScript('https://lib.baomitu.com/gitalk/1.8.0/gitalk.min.js', function() {
        var options = Object.assign(
          {"clientID":"Ov23liWXOySWQAe0OVjq","clientSecret":"5fb2935947fe65c42f0f5f3f2236c02901650f02","repo":"gittalk-comments","owner":"Alaskaboo","admin":["Alaskaboo"],"language":"zh-CN","labels":["Gitalk"],"perPage":10,"pagerDirection":"last","distractionFreeMode":false,"createIssueManually":true,"proxy":"https://cors-anywhere.azm.workers.dev/https://github.com/login/oauth/access_token"},
          {
            id: 'cde09eb43f41873dc843674d56d83e7f'
          }
        )
        var gitalk = new Gitalk(options);
        gitalk.render('gitalk-container');
      });
    });
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


    </article>
  


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  









    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://www.cnblogs.com/Alaskaboo" target="_blank" rel="nofollow noopener"><span>Alaskaboo</span></a> <i class="iconfont icon-love"></i> <a href="" target="_blank" rel="nofollow noopener"><span>以玖</span></a>
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="leancloud-site-pv-container" style="display: none">
        总访问量 
        <span id="leancloud-site-pv"></span>
         次
      </span>
    
    
      <span id="leancloud-site-uv-container" style="display: none">
        总访客数 
        <span id="leancloud-site-uv"></span>
         人
      </span>
    
    

  

</div>

  
  
    <!-- 备案信息 ICP for China -->
    <div class="beian">
  <span>
    <a href="http://beian.miit.gov.cn/" target="_blank" rel="nofollow noopener">
      渝ICP备2025063032号-2
    </a>
  </span>
  
    
      <span>
        <a
          href="http://www.beian.gov.cn/portal/registerSystemInfo?recordcode=50023102500775"
          rel="nofollow noopener"
          class="beian-police"
          target="_blank"
        >
          
            <span style="visibility: hidden; width: 0">|</span>
            <img src="/img/police_beian.png" srcset="/img/loading.gif" lazyload alt="police-icon"/>
          
          <span>渝公网安备50023102500775号</span>
        </a>
      </span>
    
  
</div>

  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        if (!window.MathJax) {
          window.MathJax = {
            tex    : {
              inlineMath: { '[+]': [['$', '$']] }
            },
            loader : {
              load: ['ui/lazy']
            },
            options: {
              renderActions: {
                insertedScript: [200, () => {
                  document.querySelectorAll('mjx-container').forEach(node => {
                    let target = node.parentNode;
                    if (target.nodeName.toLowerCase() === 'li') {
                      target.parentNode.classList.add('has-jax');
                    }
                  });
                }, '', false]
              }
            }
          };
        } else {
          MathJax.startup.document.state(0);
          MathJax.texReset();
          MathJax.typeset();
          MathJax.typesetPromise();
        }

        Fluid.events.registerRefreshCallback(function() {
          if ('MathJax' in window && MathJax.startup.document && typeof MathJax.startup.document.state === 'function') {
            MathJax.startup.document.state(0);
            MathJax.texReset();
            MathJax.typeset();
            MathJax.typesetPromise();
          }
        });
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.2/es5/tex-mml-chtml.js" ></script>

  <script defer src="/js/leancloud.js" ></script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
